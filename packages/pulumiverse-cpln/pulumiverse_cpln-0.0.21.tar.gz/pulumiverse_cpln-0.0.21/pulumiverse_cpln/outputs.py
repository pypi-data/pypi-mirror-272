# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Callable, Mapping, Optional, Sequence, Union, overload
from . import _utilities
from . import outputs

__all__ = [
    'CloudAccountAws',
    'CloudAccountAzure',
    'CloudAccountGcp',
    'CloudAccountNgs',
    'DomainSpec',
    'DomainSpecPort',
    'DomainSpecPortCors',
    'DomainSpecPortCorsAllowOrigin',
    'DomainSpecPortTls',
    'DomainSpecPortTlsClientCertificate',
    'DomainSpecPortTlsServerCertificate',
    'DomainStatus',
    'DomainStatusDnsConfig',
    'DomainStatusEndpoint',
    'DomainStatusLocation',
    'GroupIdentityMatcher',
    'GroupMemberQuery',
    'GroupMemberQuerySpec',
    'GroupMemberQuerySpecTerm',
    'GvcControlplaneTracing',
    'GvcLightstepTracing',
    'GvcLoadBalancer',
    'GvcOtelTracing',
    'GvcSidecar',
    'IdentityAwsAccessPolicy',
    'IdentityAzureAccessPolicy',
    'IdentityAzureAccessPolicyRoleAssignment',
    'IdentityGcpAccessPolicy',
    'IdentityGcpAccessPolicyBinding',
    'IdentityNativeNetworkResource',
    'IdentityNativeNetworkResourceAwsPrivateLink',
    'IdentityNativeNetworkResourceGcpServiceConnect',
    'IdentityNetworkResource',
    'IdentityNgsAccessPolicy',
    'IdentityNgsAccessPolicyPub',
    'IdentityNgsAccessPolicyResp',
    'IdentityNgsAccessPolicySub',
    'OrgAuthConfig',
    'OrgLoggingCoralogixLogging',
    'OrgLoggingDatadogLogging',
    'OrgLoggingElasticLogging',
    'OrgLoggingElasticLoggingAws',
    'OrgLoggingElasticLoggingElasticCloud',
    'OrgLoggingElasticLoggingGeneric',
    'OrgLoggingLogzioLogging',
    'OrgLoggingS3Logging',
    'OrgObservability',
    'OrgStatus',
    'OrgTracingControlplaneTracing',
    'OrgTracingLightstepTracing',
    'OrgTracingOtelTracing',
    'PolicyBinding',
    'PolicyTargetQuery',
    'PolicyTargetQuerySpec',
    'PolicyTargetQuerySpecTerm',
    'SecretAws',
    'SecretAzureConnector',
    'SecretEcr',
    'SecretKeypair',
    'SecretNatsAccount',
    'SecretOpaque',
    'SecretTls',
    'SecretUserpass',
    'VolumeSetAutoscaling',
    'VolumeSetSnapshots',
    'VolumeSetStatus',
    'WorkloadContainer',
    'WorkloadContainerGpuNvidia',
    'WorkloadContainerLifecycle',
    'WorkloadContainerLifecyclePostStart',
    'WorkloadContainerLifecyclePostStartExec',
    'WorkloadContainerLifecyclePreStop',
    'WorkloadContainerLifecyclePreStopExec',
    'WorkloadContainerLivenessProbe',
    'WorkloadContainerLivenessProbeExec',
    'WorkloadContainerLivenessProbeGrpc',
    'WorkloadContainerLivenessProbeHttpGet',
    'WorkloadContainerLivenessProbeTcpSocket',
    'WorkloadContainerMetrics',
    'WorkloadContainerPort',
    'WorkloadContainerReadinessProbe',
    'WorkloadContainerReadinessProbeExec',
    'WorkloadContainerReadinessProbeGrpc',
    'WorkloadContainerReadinessProbeHttpGet',
    'WorkloadContainerReadinessProbeTcpSocket',
    'WorkloadContainerVolume',
    'WorkloadFirewallSpec',
    'WorkloadFirewallSpecExternal',
    'WorkloadFirewallSpecExternalOutboundAllowPort',
    'WorkloadFirewallSpecInternal',
    'WorkloadJob',
    'WorkloadLocalOption',
    'WorkloadLocalOptionAutoscaling',
    'WorkloadOptions',
    'WorkloadOptionsAutoscaling',
    'WorkloadRolloutOptions',
    'WorkloadSecurityOptions',
    'WorkloadSidecar',
    'WorkloadStatus',
    'WorkloadStatusHealthCheck',
    'WorkloadStatusResolvedImage',
    'WorkloadStatusResolvedImageImage',
    'WorkloadStatusResolvedImageImageManifest',
    'GetGvcControlplaneTracingResult',
    'GetGvcLightstepTracingResult',
    'GetGvcLoadBalancerResult',
    'GetGvcOtelTracingResult',
    'GetGvcSidecarResult',
    'GetLocationGeoResult',
    'GetLocationsLocationResult',
    'GetLocationsLocationGeoResult',
]

@pulumi.output_type
class CloudAccountAws(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "roleArn":
            suggest = "role_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CloudAccountAws. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CloudAccountAws.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CloudAccountAws.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 role_arn: str):
        CloudAccountAws._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            role_arn=role_arn,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             role_arn: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'roleArn' in kwargs:
            role_arn = kwargs['roleArn']

        _setter("role_arn", role_arn)

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> str:
        return pulumi.get(self, "role_arn")


@pulumi.output_type
class CloudAccountAzure(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secretLink":
            suggest = "secret_link"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CloudAccountAzure. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CloudAccountAzure.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CloudAccountAzure.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 secret_link: str):
        CloudAccountAzure._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            secret_link=secret_link,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             secret_link: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'secretLink' in kwargs:
            secret_link = kwargs['secretLink']

        _setter("secret_link", secret_link)

    @property
    @pulumi.getter(name="secretLink")
    def secret_link(self) -> str:
        return pulumi.get(self, "secret_link")


@pulumi.output_type
class CloudAccountGcp(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "projectId":
            suggest = "project_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CloudAccountGcp. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CloudAccountGcp.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CloudAccountGcp.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 project_id: str):
        CloudAccountGcp._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            project_id=project_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             project_id: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'projectId' in kwargs:
            project_id = kwargs['projectId']

        _setter("project_id", project_id)

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> str:
        return pulumi.get(self, "project_id")


@pulumi.output_type
class CloudAccountNgs(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secretLink":
            suggest = "secret_link"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CloudAccountNgs. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CloudAccountNgs.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CloudAccountNgs.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 secret_link: str):
        CloudAccountNgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            secret_link=secret_link,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             secret_link: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'secretLink' in kwargs:
            secret_link = kwargs['secretLink']

        _setter("secret_link", secret_link)

    @property
    @pulumi.getter(name="secretLink")
    def secret_link(self) -> str:
        return pulumi.get(self, "secret_link")


@pulumi.output_type
class DomainSpec(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "acceptAllHosts":
            suggest = "accept_all_hosts"
        elif key == "dnsMode":
            suggest = "dns_mode"
        elif key == "gvcLink":
            suggest = "gvc_link"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainSpec. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainSpec.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainSpec.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ports: Sequence['outputs.DomainSpecPort'],
                 accept_all_hosts: Optional[bool] = None,
                 dns_mode: Optional[str] = None,
                 gvc_link: Optional[str] = None):
        DomainSpec._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            ports=ports,
            accept_all_hosts=accept_all_hosts,
            dns_mode=dns_mode,
            gvc_link=gvc_link,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             ports: Sequence['outputs.DomainSpecPort'],
             accept_all_hosts: Optional[bool] = None,
             dns_mode: Optional[str] = None,
             gvc_link: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'acceptAllHosts' in kwargs:
            accept_all_hosts = kwargs['acceptAllHosts']
        if 'dnsMode' in kwargs:
            dns_mode = kwargs['dnsMode']
        if 'gvcLink' in kwargs:
            gvc_link = kwargs['gvcLink']

        _setter("ports", ports)
        if accept_all_hosts is not None:
            _setter("accept_all_hosts", accept_all_hosts)
        if dns_mode is not None:
            _setter("dns_mode", dns_mode)
        if gvc_link is not None:
            _setter("gvc_link", gvc_link)

    @property
    @pulumi.getter
    def ports(self) -> Sequence['outputs.DomainSpecPort']:
        return pulumi.get(self, "ports")

    @property
    @pulumi.getter(name="acceptAllHosts")
    def accept_all_hosts(self) -> Optional[bool]:
        return pulumi.get(self, "accept_all_hosts")

    @property
    @pulumi.getter(name="dnsMode")
    def dns_mode(self) -> Optional[str]:
        return pulumi.get(self, "dns_mode")

    @property
    @pulumi.getter(name="gvcLink")
    def gvc_link(self) -> Optional[str]:
        return pulumi.get(self, "gvc_link")


@pulumi.output_type
class DomainSpecPort(dict):
    def __init__(__self__, *,
                 tls: 'outputs.DomainSpecPortTls',
                 cors: Optional['outputs.DomainSpecPortCors'] = None,
                 number: Optional[int] = None,
                 protocol: Optional[str] = None):
        DomainSpecPort._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            tls=tls,
            cors=cors,
            number=number,
            protocol=protocol,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             tls: 'outputs.DomainSpecPortTls',
             cors: Optional['outputs.DomainSpecPortCors'] = None,
             number: Optional[int] = None,
             protocol: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("tls", tls)
        if cors is not None:
            _setter("cors", cors)
        if number is not None:
            _setter("number", number)
        if protocol is not None:
            _setter("protocol", protocol)

    @property
    @pulumi.getter
    def tls(self) -> 'outputs.DomainSpecPortTls':
        return pulumi.get(self, "tls")

    @property
    @pulumi.getter
    def cors(self) -> Optional['outputs.DomainSpecPortCors']:
        return pulumi.get(self, "cors")

    @property
    @pulumi.getter
    def number(self) -> Optional[int]:
        return pulumi.get(self, "number")

    @property
    @pulumi.getter
    def protocol(self) -> Optional[str]:
        return pulumi.get(self, "protocol")


@pulumi.output_type
class DomainSpecPortCors(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowCredentials":
            suggest = "allow_credentials"
        elif key == "allowHeaders":
            suggest = "allow_headers"
        elif key == "allowMethods":
            suggest = "allow_methods"
        elif key == "allowOrigins":
            suggest = "allow_origins"
        elif key == "exposeHeaders":
            suggest = "expose_headers"
        elif key == "maxAge":
            suggest = "max_age"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainSpecPortCors. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainSpecPortCors.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainSpecPortCors.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allow_credentials: Optional[bool] = None,
                 allow_headers: Optional[Sequence[str]] = None,
                 allow_methods: Optional[Sequence[str]] = None,
                 allow_origins: Optional[Sequence['outputs.DomainSpecPortCorsAllowOrigin']] = None,
                 expose_headers: Optional[Sequence[str]] = None,
                 max_age: Optional[str] = None):
        DomainSpecPortCors._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            allow_credentials=allow_credentials,
            allow_headers=allow_headers,
            allow_methods=allow_methods,
            allow_origins=allow_origins,
            expose_headers=expose_headers,
            max_age=max_age,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             allow_credentials: Optional[bool] = None,
             allow_headers: Optional[Sequence[str]] = None,
             allow_methods: Optional[Sequence[str]] = None,
             allow_origins: Optional[Sequence['outputs.DomainSpecPortCorsAllowOrigin']] = None,
             expose_headers: Optional[Sequence[str]] = None,
             max_age: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'allowCredentials' in kwargs:
            allow_credentials = kwargs['allowCredentials']
        if 'allowHeaders' in kwargs:
            allow_headers = kwargs['allowHeaders']
        if 'allowMethods' in kwargs:
            allow_methods = kwargs['allowMethods']
        if 'allowOrigins' in kwargs:
            allow_origins = kwargs['allowOrigins']
        if 'exposeHeaders' in kwargs:
            expose_headers = kwargs['exposeHeaders']
        if 'maxAge' in kwargs:
            max_age = kwargs['maxAge']

        if allow_credentials is not None:
            _setter("allow_credentials", allow_credentials)
        if allow_headers is not None:
            _setter("allow_headers", allow_headers)
        if allow_methods is not None:
            _setter("allow_methods", allow_methods)
        if allow_origins is not None:
            _setter("allow_origins", allow_origins)
        if expose_headers is not None:
            _setter("expose_headers", expose_headers)
        if max_age is not None:
            _setter("max_age", max_age)

    @property
    @pulumi.getter(name="allowCredentials")
    def allow_credentials(self) -> Optional[bool]:
        return pulumi.get(self, "allow_credentials")

    @property
    @pulumi.getter(name="allowHeaders")
    def allow_headers(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "allow_headers")

    @property
    @pulumi.getter(name="allowMethods")
    def allow_methods(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "allow_methods")

    @property
    @pulumi.getter(name="allowOrigins")
    def allow_origins(self) -> Optional[Sequence['outputs.DomainSpecPortCorsAllowOrigin']]:
        return pulumi.get(self, "allow_origins")

    @property
    @pulumi.getter(name="exposeHeaders")
    def expose_headers(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "expose_headers")

    @property
    @pulumi.getter(name="maxAge")
    def max_age(self) -> Optional[str]:
        return pulumi.get(self, "max_age")


@pulumi.output_type
class DomainSpecPortCorsAllowOrigin(dict):
    def __init__(__self__, *,
                 exact: str):
        DomainSpecPortCorsAllowOrigin._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            exact=exact,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             exact: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("exact", exact)

    @property
    @pulumi.getter
    def exact(self) -> str:
        return pulumi.get(self, "exact")


@pulumi.output_type
class DomainSpecPortTls(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cipherSuites":
            suggest = "cipher_suites"
        elif key == "clientCertificate":
            suggest = "client_certificate"
        elif key == "minProtocolVersion":
            suggest = "min_protocol_version"
        elif key == "serverCertificate":
            suggest = "server_certificate"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainSpecPortTls. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainSpecPortTls.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainSpecPortTls.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cipher_suites: Optional[Sequence[str]] = None,
                 client_certificate: Optional['outputs.DomainSpecPortTlsClientCertificate'] = None,
                 min_protocol_version: Optional[str] = None,
                 server_certificate: Optional['outputs.DomainSpecPortTlsServerCertificate'] = None):
        DomainSpecPortTls._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cipher_suites=cipher_suites,
            client_certificate=client_certificate,
            min_protocol_version=min_protocol_version,
            server_certificate=server_certificate,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cipher_suites: Optional[Sequence[str]] = None,
             client_certificate: Optional['outputs.DomainSpecPortTlsClientCertificate'] = None,
             min_protocol_version: Optional[str] = None,
             server_certificate: Optional['outputs.DomainSpecPortTlsServerCertificate'] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'cipherSuites' in kwargs:
            cipher_suites = kwargs['cipherSuites']
        if 'clientCertificate' in kwargs:
            client_certificate = kwargs['clientCertificate']
        if 'minProtocolVersion' in kwargs:
            min_protocol_version = kwargs['minProtocolVersion']
        if 'serverCertificate' in kwargs:
            server_certificate = kwargs['serverCertificate']

        if cipher_suites is not None:
            _setter("cipher_suites", cipher_suites)
        if client_certificate is not None:
            _setter("client_certificate", client_certificate)
        if min_protocol_version is not None:
            _setter("min_protocol_version", min_protocol_version)
        if server_certificate is not None:
            _setter("server_certificate", server_certificate)

    @property
    @pulumi.getter(name="cipherSuites")
    def cipher_suites(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "cipher_suites")

    @property
    @pulumi.getter(name="clientCertificate")
    def client_certificate(self) -> Optional['outputs.DomainSpecPortTlsClientCertificate']:
        return pulumi.get(self, "client_certificate")

    @property
    @pulumi.getter(name="minProtocolVersion")
    def min_protocol_version(self) -> Optional[str]:
        return pulumi.get(self, "min_protocol_version")

    @property
    @pulumi.getter(name="serverCertificate")
    def server_certificate(self) -> Optional['outputs.DomainSpecPortTlsServerCertificate']:
        return pulumi.get(self, "server_certificate")


@pulumi.output_type
class DomainSpecPortTlsClientCertificate(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secretLink":
            suggest = "secret_link"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainSpecPortTlsClientCertificate. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainSpecPortTlsClientCertificate.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainSpecPortTlsClientCertificate.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 secret_link: Optional[str] = None):
        DomainSpecPortTlsClientCertificate._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            secret_link=secret_link,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             secret_link: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'secretLink' in kwargs:
            secret_link = kwargs['secretLink']

        if secret_link is not None:
            _setter("secret_link", secret_link)

    @property
    @pulumi.getter(name="secretLink")
    def secret_link(self) -> Optional[str]:
        return pulumi.get(self, "secret_link")


@pulumi.output_type
class DomainSpecPortTlsServerCertificate(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secretLink":
            suggest = "secret_link"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainSpecPortTlsServerCertificate. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainSpecPortTlsServerCertificate.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainSpecPortTlsServerCertificate.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 secret_link: Optional[str] = None):
        DomainSpecPortTlsServerCertificate._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            secret_link=secret_link,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             secret_link: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'secretLink' in kwargs:
            secret_link = kwargs['secretLink']

        if secret_link is not None:
            _setter("secret_link", secret_link)

    @property
    @pulumi.getter(name="secretLink")
    def secret_link(self) -> Optional[str]:
        return pulumi.get(self, "secret_link")


@pulumi.output_type
class DomainStatus(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dnsConfigs":
            suggest = "dns_configs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainStatus. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainStatus.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainStatus.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dns_configs: Optional[Sequence['outputs.DomainStatusDnsConfig']] = None,
                 endpoints: Optional[Sequence['outputs.DomainStatusEndpoint']] = None,
                 fingerprint: Optional[str] = None,
                 locations: Optional[Sequence['outputs.DomainStatusLocation']] = None,
                 status: Optional[str] = None,
                 warning: Optional[str] = None):
        DomainStatus._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            dns_configs=dns_configs,
            endpoints=endpoints,
            fingerprint=fingerprint,
            locations=locations,
            status=status,
            warning=warning,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             dns_configs: Optional[Sequence['outputs.DomainStatusDnsConfig']] = None,
             endpoints: Optional[Sequence['outputs.DomainStatusEndpoint']] = None,
             fingerprint: Optional[str] = None,
             locations: Optional[Sequence['outputs.DomainStatusLocation']] = None,
             status: Optional[str] = None,
             warning: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'dnsConfigs' in kwargs:
            dns_configs = kwargs['dnsConfigs']

        if dns_configs is not None:
            _setter("dns_configs", dns_configs)
        if endpoints is not None:
            _setter("endpoints", endpoints)
        if fingerprint is not None:
            _setter("fingerprint", fingerprint)
        if locations is not None:
            _setter("locations", locations)
        if status is not None:
            _setter("status", status)
        if warning is not None:
            _setter("warning", warning)

    @property
    @pulumi.getter(name="dnsConfigs")
    def dns_configs(self) -> Optional[Sequence['outputs.DomainStatusDnsConfig']]:
        return pulumi.get(self, "dns_configs")

    @property
    @pulumi.getter
    def endpoints(self) -> Optional[Sequence['outputs.DomainStatusEndpoint']]:
        return pulumi.get(self, "endpoints")

    @property
    @pulumi.getter
    def fingerprint(self) -> Optional[str]:
        return pulumi.get(self, "fingerprint")

    @property
    @pulumi.getter
    def locations(self) -> Optional[Sequence['outputs.DomainStatusLocation']]:
        return pulumi.get(self, "locations")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def warning(self) -> Optional[str]:
        return pulumi.get(self, "warning")


@pulumi.output_type
class DomainStatusDnsConfig(dict):
    def __init__(__self__, *,
                 host: Optional[str] = None,
                 ttl: Optional[int] = None,
                 type: Optional[str] = None,
                 value: Optional[str] = None):
        DomainStatusDnsConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            host=host,
            ttl=ttl,
            type=type,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             host: Optional[str] = None,
             ttl: Optional[int] = None,
             type: Optional[str] = None,
             value: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if host is not None:
            _setter("host", host)
        if ttl is not None:
            _setter("ttl", ttl)
        if type is not None:
            _setter("type", type)
        if value is not None:
            _setter("value", value)

    @property
    @pulumi.getter
    def host(self) -> Optional[str]:
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def ttl(self) -> Optional[int]:
        return pulumi.get(self, "ttl")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class DomainStatusEndpoint(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "workloadLink":
            suggest = "workload_link"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainStatusEndpoint. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainStatusEndpoint.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainStatusEndpoint.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 url: Optional[str] = None,
                 workload_link: Optional[str] = None):
        DomainStatusEndpoint._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            url=url,
            workload_link=workload_link,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             url: Optional[str] = None,
             workload_link: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'workloadLink' in kwargs:
            workload_link = kwargs['workloadLink']

        if url is not None:
            _setter("url", url)
        if workload_link is not None:
            _setter("workload_link", workload_link)

    @property
    @pulumi.getter
    def url(self) -> Optional[str]:
        return pulumi.get(self, "url")

    @property
    @pulumi.getter(name="workloadLink")
    def workload_link(self) -> Optional[str]:
        return pulumi.get(self, "workload_link")


@pulumi.output_type
class DomainStatusLocation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "certificateStatus":
            suggest = "certificate_status"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainStatusLocation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainStatusLocation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainStatusLocation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 certificate_status: Optional[str] = None,
                 name: Optional[str] = None):
        DomainStatusLocation._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            certificate_status=certificate_status,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             certificate_status: Optional[str] = None,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'certificateStatus' in kwargs:
            certificate_status = kwargs['certificateStatus']

        if certificate_status is not None:
            _setter("certificate_status", certificate_status)
        if name is not None:
            _setter("name", name)

    @property
    @pulumi.getter(name="certificateStatus")
    def certificate_status(self) -> Optional[str]:
        return pulumi.get(self, "certificate_status")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class GroupIdentityMatcher(dict):
    def __init__(__self__, *,
                 expression: str,
                 language: Optional[str] = None):
        GroupIdentityMatcher._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            expression=expression,
            language=language,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             expression: str,
             language: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("expression", expression)
        if language is not None:
            _setter("language", language)

    @property
    @pulumi.getter
    def expression(self) -> str:
        return pulumi.get(self, "expression")

    @property
    @pulumi.getter
    def language(self) -> Optional[str]:
        return pulumi.get(self, "language")


@pulumi.output_type
class GroupMemberQuery(dict):
    def __init__(__self__, *,
                 fetch: Optional[str] = None,
                 spec: Optional['outputs.GroupMemberQuerySpec'] = None):
        GroupMemberQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            fetch=fetch,
            spec=spec,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             fetch: Optional[str] = None,
             spec: Optional['outputs.GroupMemberQuerySpec'] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if fetch is not None:
            _setter("fetch", fetch)
        if spec is not None:
            _setter("spec", spec)

    @property
    @pulumi.getter
    def fetch(self) -> Optional[str]:
        return pulumi.get(self, "fetch")

    @property
    @pulumi.getter
    def spec(self) -> Optional['outputs.GroupMemberQuerySpec']:
        return pulumi.get(self, "spec")


@pulumi.output_type
class GroupMemberQuerySpec(dict):
    def __init__(__self__, *,
                 match: Optional[str] = None,
                 terms: Optional[Sequence['outputs.GroupMemberQuerySpecTerm']] = None):
        GroupMemberQuerySpec._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            match=match,
            terms=terms,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             match: Optional[str] = None,
             terms: Optional[Sequence['outputs.GroupMemberQuerySpecTerm']] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if match is not None:
            _setter("match", match)
        if terms is not None:
            _setter("terms", terms)

    @property
    @pulumi.getter
    def match(self) -> Optional[str]:
        return pulumi.get(self, "match")

    @property
    @pulumi.getter
    def terms(self) -> Optional[Sequence['outputs.GroupMemberQuerySpecTerm']]:
        return pulumi.get(self, "terms")


@pulumi.output_type
class GroupMemberQuerySpecTerm(dict):
    def __init__(__self__, *,
                 op: Optional[str] = None,
                 property: Optional[str] = None,
                 tag: Optional[str] = None,
                 value: Optional[str] = None):
        GroupMemberQuerySpecTerm._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            op=op,
            property=property,
            tag=tag,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             op: Optional[str] = None,
             property: Optional[str] = None,
             tag: Optional[str] = None,
             value: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if op is not None:
            _setter("op", op)
        if property is not None:
            _setter("property", property)
        if tag is not None:
            _setter("tag", tag)
        if value is not None:
            _setter("value", value)

    @property
    @pulumi.getter
    def op(self) -> Optional[str]:
        return pulumi.get(self, "op")

    @property
    @pulumi.getter
    def tag(self) -> Optional[str]:
        return pulumi.get(self, "tag")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def property(self) -> Optional[str]:
        return pulumi.get(self, "property")


@pulumi.output_type
class GvcControlplaneTracing(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customTags":
            suggest = "custom_tags"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GvcControlplaneTracing. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GvcControlplaneTracing.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GvcControlplaneTracing.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 sampling: int,
                 custom_tags: Optional[Mapping[str, str]] = None):
        GvcControlplaneTracing._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            sampling=sampling,
            custom_tags=custom_tags,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             sampling: int,
             custom_tags: Optional[Mapping[str, str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'customTags' in kwargs:
            custom_tags = kwargs['customTags']

        _setter("sampling", sampling)
        if custom_tags is not None:
            _setter("custom_tags", custom_tags)

    @property
    @pulumi.getter
    def sampling(self) -> int:
        return pulumi.get(self, "sampling")

    @property
    @pulumi.getter(name="customTags")
    def custom_tags(self) -> Optional[Mapping[str, str]]:
        return pulumi.get(self, "custom_tags")


@pulumi.output_type
class GvcLightstepTracing(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customTags":
            suggest = "custom_tags"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GvcLightstepTracing. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GvcLightstepTracing.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GvcLightstepTracing.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 endpoint: str,
                 sampling: int,
                 credentials: Optional[str] = None,
                 custom_tags: Optional[Mapping[str, str]] = None):
        GvcLightstepTracing._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            endpoint=endpoint,
            sampling=sampling,
            credentials=credentials,
            custom_tags=custom_tags,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             endpoint: str,
             sampling: int,
             credentials: Optional[str] = None,
             custom_tags: Optional[Mapping[str, str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'customTags' in kwargs:
            custom_tags = kwargs['customTags']

        _setter("endpoint", endpoint)
        _setter("sampling", sampling)
        if credentials is not None:
            _setter("credentials", credentials)
        if custom_tags is not None:
            _setter("custom_tags", custom_tags)

    @property
    @pulumi.getter
    def endpoint(self) -> str:
        return pulumi.get(self, "endpoint")

    @property
    @pulumi.getter
    def sampling(self) -> int:
        return pulumi.get(self, "sampling")

    @property
    @pulumi.getter
    def credentials(self) -> Optional[str]:
        return pulumi.get(self, "credentials")

    @property
    @pulumi.getter(name="customTags")
    def custom_tags(self) -> Optional[Mapping[str, str]]:
        return pulumi.get(self, "custom_tags")


@pulumi.output_type
class GvcLoadBalancer(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "trustedProxies":
            suggest = "trusted_proxies"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GvcLoadBalancer. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GvcLoadBalancer.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GvcLoadBalancer.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dedicated: bool,
                 trusted_proxies: Optional[int] = None):
        GvcLoadBalancer._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            dedicated=dedicated,
            trusted_proxies=trusted_proxies,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             dedicated: bool,
             trusted_proxies: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'trustedProxies' in kwargs:
            trusted_proxies = kwargs['trustedProxies']

        _setter("dedicated", dedicated)
        if trusted_proxies is not None:
            _setter("trusted_proxies", trusted_proxies)

    @property
    @pulumi.getter
    def dedicated(self) -> bool:
        return pulumi.get(self, "dedicated")

    @property
    @pulumi.getter(name="trustedProxies")
    def trusted_proxies(self) -> Optional[int]:
        return pulumi.get(self, "trusted_proxies")


@pulumi.output_type
class GvcOtelTracing(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customTags":
            suggest = "custom_tags"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GvcOtelTracing. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GvcOtelTracing.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GvcOtelTracing.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 endpoint: str,
                 sampling: int,
                 custom_tags: Optional[Mapping[str, str]] = None):
        GvcOtelTracing._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            endpoint=endpoint,
            sampling=sampling,
            custom_tags=custom_tags,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             endpoint: str,
             sampling: int,
             custom_tags: Optional[Mapping[str, str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'customTags' in kwargs:
            custom_tags = kwargs['customTags']

        _setter("endpoint", endpoint)
        _setter("sampling", sampling)
        if custom_tags is not None:
            _setter("custom_tags", custom_tags)

    @property
    @pulumi.getter
    def endpoint(self) -> str:
        return pulumi.get(self, "endpoint")

    @property
    @pulumi.getter
    def sampling(self) -> int:
        return pulumi.get(self, "sampling")

    @property
    @pulumi.getter(name="customTags")
    def custom_tags(self) -> Optional[Mapping[str, str]]:
        return pulumi.get(self, "custom_tags")


@pulumi.output_type
class GvcSidecar(dict):
    def __init__(__self__, *,
                 envoy: str):
        GvcSidecar._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            envoy=envoy,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             envoy: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("envoy", envoy)

    @property
    @pulumi.getter
    def envoy(self) -> str:
        return pulumi.get(self, "envoy")


@pulumi.output_type
class IdentityAwsAccessPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cloudAccountLink":
            suggest = "cloud_account_link"
        elif key == "policyRefs":
            suggest = "policy_refs"
        elif key == "roleName":
            suggest = "role_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IdentityAwsAccessPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IdentityAwsAccessPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IdentityAwsAccessPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cloud_account_link: str,
                 policy_refs: Optional[Sequence[str]] = None,
                 role_name: Optional[str] = None):
        IdentityAwsAccessPolicy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cloud_account_link=cloud_account_link,
            policy_refs=policy_refs,
            role_name=role_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cloud_account_link: str,
             policy_refs: Optional[Sequence[str]] = None,
             role_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'cloudAccountLink' in kwargs:
            cloud_account_link = kwargs['cloudAccountLink']
        if 'policyRefs' in kwargs:
            policy_refs = kwargs['policyRefs']
        if 'roleName' in kwargs:
            role_name = kwargs['roleName']

        _setter("cloud_account_link", cloud_account_link)
        if policy_refs is not None:
            _setter("policy_refs", policy_refs)
        if role_name is not None:
            _setter("role_name", role_name)

    @property
    @pulumi.getter(name="cloudAccountLink")
    def cloud_account_link(self) -> str:
        return pulumi.get(self, "cloud_account_link")

    @property
    @pulumi.getter(name="policyRefs")
    def policy_refs(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "policy_refs")

    @property
    @pulumi.getter(name="roleName")
    def role_name(self) -> Optional[str]:
        return pulumi.get(self, "role_name")


@pulumi.output_type
class IdentityAzureAccessPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cloudAccountLink":
            suggest = "cloud_account_link"
        elif key == "roleAssignments":
            suggest = "role_assignments"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IdentityAzureAccessPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IdentityAzureAccessPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IdentityAzureAccessPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cloud_account_link: str,
                 role_assignments: Optional[Sequence['outputs.IdentityAzureAccessPolicyRoleAssignment']] = None):
        IdentityAzureAccessPolicy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cloud_account_link=cloud_account_link,
            role_assignments=role_assignments,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cloud_account_link: str,
             role_assignments: Optional[Sequence['outputs.IdentityAzureAccessPolicyRoleAssignment']] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'cloudAccountLink' in kwargs:
            cloud_account_link = kwargs['cloudAccountLink']
        if 'roleAssignments' in kwargs:
            role_assignments = kwargs['roleAssignments']

        _setter("cloud_account_link", cloud_account_link)
        if role_assignments is not None:
            _setter("role_assignments", role_assignments)

    @property
    @pulumi.getter(name="cloudAccountLink")
    def cloud_account_link(self) -> str:
        return pulumi.get(self, "cloud_account_link")

    @property
    @pulumi.getter(name="roleAssignments")
    def role_assignments(self) -> Optional[Sequence['outputs.IdentityAzureAccessPolicyRoleAssignment']]:
        return pulumi.get(self, "role_assignments")


@pulumi.output_type
class IdentityAzureAccessPolicyRoleAssignment(dict):
    def __init__(__self__, *,
                 roles: Optional[Sequence[str]] = None,
                 scope: Optional[str] = None):
        IdentityAzureAccessPolicyRoleAssignment._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            roles=roles,
            scope=scope,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             roles: Optional[Sequence[str]] = None,
             scope: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if roles is not None:
            _setter("roles", roles)
        if scope is not None:
            _setter("scope", scope)

    @property
    @pulumi.getter
    def roles(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "roles")

    @property
    @pulumi.getter
    def scope(self) -> Optional[str]:
        return pulumi.get(self, "scope")


@pulumi.output_type
class IdentityGcpAccessPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cloudAccountLink":
            suggest = "cloud_account_link"
        elif key == "serviceAccount":
            suggest = "service_account"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IdentityGcpAccessPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IdentityGcpAccessPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IdentityGcpAccessPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cloud_account_link: str,
                 bindings: Optional[Sequence['outputs.IdentityGcpAccessPolicyBinding']] = None,
                 scopes: Optional[str] = None,
                 service_account: Optional[str] = None):
        IdentityGcpAccessPolicy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cloud_account_link=cloud_account_link,
            bindings=bindings,
            scopes=scopes,
            service_account=service_account,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cloud_account_link: str,
             bindings: Optional[Sequence['outputs.IdentityGcpAccessPolicyBinding']] = None,
             scopes: Optional[str] = None,
             service_account: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'cloudAccountLink' in kwargs:
            cloud_account_link = kwargs['cloudAccountLink']
        if 'serviceAccount' in kwargs:
            service_account = kwargs['serviceAccount']

        _setter("cloud_account_link", cloud_account_link)
        if bindings is not None:
            _setter("bindings", bindings)
        if scopes is not None:
            _setter("scopes", scopes)
        if service_account is not None:
            _setter("service_account", service_account)

    @property
    @pulumi.getter(name="cloudAccountLink")
    def cloud_account_link(self) -> str:
        return pulumi.get(self, "cloud_account_link")

    @property
    @pulumi.getter
    def bindings(self) -> Optional[Sequence['outputs.IdentityGcpAccessPolicyBinding']]:
        return pulumi.get(self, "bindings")

    @property
    @pulumi.getter
    def scopes(self) -> Optional[str]:
        return pulumi.get(self, "scopes")

    @property
    @pulumi.getter(name="serviceAccount")
    def service_account(self) -> Optional[str]:
        return pulumi.get(self, "service_account")


@pulumi.output_type
class IdentityGcpAccessPolicyBinding(dict):
    def __init__(__self__, *,
                 resource: Optional[str] = None,
                 roles: Optional[Sequence[str]] = None):
        IdentityGcpAccessPolicyBinding._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            resource=resource,
            roles=roles,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             resource: Optional[str] = None,
             roles: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if resource is not None:
            _setter("resource", resource)
        if roles is not None:
            _setter("roles", roles)

    @property
    @pulumi.getter
    def resource(self) -> Optional[str]:
        return pulumi.get(self, "resource")

    @property
    @pulumi.getter
    def roles(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "roles")


@pulumi.output_type
class IdentityNativeNetworkResource(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "awsPrivateLink":
            suggest = "aws_private_link"
        elif key == "gcpServiceConnect":
            suggest = "gcp_service_connect"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IdentityNativeNetworkResource. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IdentityNativeNetworkResource.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IdentityNativeNetworkResource.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fqdn: str,
                 name: str,
                 ports: Sequence[int],
                 aws_private_link: Optional['outputs.IdentityNativeNetworkResourceAwsPrivateLink'] = None,
                 gcp_service_connect: Optional['outputs.IdentityNativeNetworkResourceGcpServiceConnect'] = None):
        IdentityNativeNetworkResource._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            fqdn=fqdn,
            name=name,
            ports=ports,
            aws_private_link=aws_private_link,
            gcp_service_connect=gcp_service_connect,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             fqdn: str,
             name: str,
             ports: Sequence[int],
             aws_private_link: Optional['outputs.IdentityNativeNetworkResourceAwsPrivateLink'] = None,
             gcp_service_connect: Optional['outputs.IdentityNativeNetworkResourceGcpServiceConnect'] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'awsPrivateLink' in kwargs:
            aws_private_link = kwargs['awsPrivateLink']
        if 'gcpServiceConnect' in kwargs:
            gcp_service_connect = kwargs['gcpServiceConnect']

        _setter("fqdn", fqdn)
        _setter("name", name)
        _setter("ports", ports)
        if aws_private_link is not None:
            _setter("aws_private_link", aws_private_link)
        if gcp_service_connect is not None:
            _setter("gcp_service_connect", gcp_service_connect)

    @property
    @pulumi.getter
    def fqdn(self) -> str:
        return pulumi.get(self, "fqdn")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def ports(self) -> Sequence[int]:
        return pulumi.get(self, "ports")

    @property
    @pulumi.getter(name="awsPrivateLink")
    def aws_private_link(self) -> Optional['outputs.IdentityNativeNetworkResourceAwsPrivateLink']:
        return pulumi.get(self, "aws_private_link")

    @property
    @pulumi.getter(name="gcpServiceConnect")
    def gcp_service_connect(self) -> Optional['outputs.IdentityNativeNetworkResourceGcpServiceConnect']:
        return pulumi.get(self, "gcp_service_connect")


@pulumi.output_type
class IdentityNativeNetworkResourceAwsPrivateLink(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endpointServiceName":
            suggest = "endpoint_service_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IdentityNativeNetworkResourceAwsPrivateLink. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IdentityNativeNetworkResourceAwsPrivateLink.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IdentityNativeNetworkResourceAwsPrivateLink.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 endpoint_service_name: str):
        IdentityNativeNetworkResourceAwsPrivateLink._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            endpoint_service_name=endpoint_service_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             endpoint_service_name: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'endpointServiceName' in kwargs:
            endpoint_service_name = kwargs['endpointServiceName']

        _setter("endpoint_service_name", endpoint_service_name)

    @property
    @pulumi.getter(name="endpointServiceName")
    def endpoint_service_name(self) -> str:
        return pulumi.get(self, "endpoint_service_name")


@pulumi.output_type
class IdentityNativeNetworkResourceGcpServiceConnect(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "targetService":
            suggest = "target_service"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IdentityNativeNetworkResourceGcpServiceConnect. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IdentityNativeNetworkResourceGcpServiceConnect.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IdentityNativeNetworkResourceGcpServiceConnect.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 target_service: str):
        IdentityNativeNetworkResourceGcpServiceConnect._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            target_service=target_service,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             target_service: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'targetService' in kwargs:
            target_service = kwargs['targetService']

        _setter("target_service", target_service)

    @property
    @pulumi.getter(name="targetService")
    def target_service(self) -> str:
        return pulumi.get(self, "target_service")


@pulumi.output_type
class IdentityNetworkResource(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "agentLink":
            suggest = "agent_link"
        elif key == "resolverIp":
            suggest = "resolver_ip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IdentityNetworkResource. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IdentityNetworkResource.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IdentityNetworkResource.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 agent_link: str,
                 name: str,
                 fqdn: Optional[str] = None,
                 ips: Optional[Sequence[str]] = None,
                 ports: Optional[Sequence[int]] = None,
                 resolver_ip: Optional[str] = None):
        IdentityNetworkResource._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            agent_link=agent_link,
            name=name,
            fqdn=fqdn,
            ips=ips,
            ports=ports,
            resolver_ip=resolver_ip,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             agent_link: str,
             name: str,
             fqdn: Optional[str] = None,
             ips: Optional[Sequence[str]] = None,
             ports: Optional[Sequence[int]] = None,
             resolver_ip: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'agentLink' in kwargs:
            agent_link = kwargs['agentLink']
        if 'resolverIp' in kwargs:
            resolver_ip = kwargs['resolverIp']

        _setter("agent_link", agent_link)
        _setter("name", name)
        if fqdn is not None:
            _setter("fqdn", fqdn)
        if ips is not None:
            _setter("ips", ips)
        if ports is not None:
            _setter("ports", ports)
        if resolver_ip is not None:
            _setter("resolver_ip", resolver_ip)

    @property
    @pulumi.getter(name="agentLink")
    def agent_link(self) -> str:
        return pulumi.get(self, "agent_link")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def fqdn(self) -> Optional[str]:
        return pulumi.get(self, "fqdn")

    @property
    @pulumi.getter
    def ips(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "ips")

    @property
    @pulumi.getter
    def ports(self) -> Optional[Sequence[int]]:
        return pulumi.get(self, "ports")

    @property
    @pulumi.getter(name="resolverIp")
    def resolver_ip(self) -> Optional[str]:
        return pulumi.get(self, "resolver_ip")


@pulumi.output_type
class IdentityNgsAccessPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cloudAccountLink":
            suggest = "cloud_account_link"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IdentityNgsAccessPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IdentityNgsAccessPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IdentityNgsAccessPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cloud_account_link: str,
                 data: Optional[int] = None,
                 payload: Optional[int] = None,
                 pub: Optional['outputs.IdentityNgsAccessPolicyPub'] = None,
                 resp: Optional['outputs.IdentityNgsAccessPolicyResp'] = None,
                 sub: Optional['outputs.IdentityNgsAccessPolicySub'] = None,
                 subs: Optional[int] = None):
        IdentityNgsAccessPolicy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cloud_account_link=cloud_account_link,
            data=data,
            payload=payload,
            pub=pub,
            resp=resp,
            sub=sub,
            subs=subs,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cloud_account_link: str,
             data: Optional[int] = None,
             payload: Optional[int] = None,
             pub: Optional['outputs.IdentityNgsAccessPolicyPub'] = None,
             resp: Optional['outputs.IdentityNgsAccessPolicyResp'] = None,
             sub: Optional['outputs.IdentityNgsAccessPolicySub'] = None,
             subs: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'cloudAccountLink' in kwargs:
            cloud_account_link = kwargs['cloudAccountLink']

        _setter("cloud_account_link", cloud_account_link)
        if data is not None:
            _setter("data", data)
        if payload is not None:
            _setter("payload", payload)
        if pub is not None:
            _setter("pub", pub)
        if resp is not None:
            _setter("resp", resp)
        if sub is not None:
            _setter("sub", sub)
        if subs is not None:
            _setter("subs", subs)

    @property
    @pulumi.getter(name="cloudAccountLink")
    def cloud_account_link(self) -> str:
        return pulumi.get(self, "cloud_account_link")

    @property
    @pulumi.getter
    def data(self) -> Optional[int]:
        return pulumi.get(self, "data")

    @property
    @pulumi.getter
    def payload(self) -> Optional[int]:
        return pulumi.get(self, "payload")

    @property
    @pulumi.getter
    def pub(self) -> Optional['outputs.IdentityNgsAccessPolicyPub']:
        return pulumi.get(self, "pub")

    @property
    @pulumi.getter
    def resp(self) -> Optional['outputs.IdentityNgsAccessPolicyResp']:
        return pulumi.get(self, "resp")

    @property
    @pulumi.getter
    def sub(self) -> Optional['outputs.IdentityNgsAccessPolicySub']:
        return pulumi.get(self, "sub")

    @property
    @pulumi.getter
    def subs(self) -> Optional[int]:
        return pulumi.get(self, "subs")


@pulumi.output_type
class IdentityNgsAccessPolicyPub(dict):
    def __init__(__self__, *,
                 allows: Optional[Sequence[str]] = None,
                 denies: Optional[Sequence[str]] = None):
        IdentityNgsAccessPolicyPub._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            allows=allows,
            denies=denies,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             allows: Optional[Sequence[str]] = None,
             denies: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if allows is not None:
            _setter("allows", allows)
        if denies is not None:
            _setter("denies", denies)

    @property
    @pulumi.getter
    def allows(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "allows")

    @property
    @pulumi.getter
    def denies(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "denies")


@pulumi.output_type
class IdentityNgsAccessPolicyResp(dict):
    def __init__(__self__, *,
                 max: Optional[int] = None,
                 ttl: Optional[str] = None):
        IdentityNgsAccessPolicyResp._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            max=max,
            ttl=ttl,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             max: Optional[int] = None,
             ttl: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if max is not None:
            _setter("max", max)
        if ttl is not None:
            _setter("ttl", ttl)

    @property
    @pulumi.getter
    def max(self) -> Optional[int]:
        return pulumi.get(self, "max")

    @property
    @pulumi.getter
    def ttl(self) -> Optional[str]:
        return pulumi.get(self, "ttl")


@pulumi.output_type
class IdentityNgsAccessPolicySub(dict):
    def __init__(__self__, *,
                 allows: Optional[Sequence[str]] = None,
                 denies: Optional[Sequence[str]] = None):
        IdentityNgsAccessPolicySub._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            allows=allows,
            denies=denies,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             allows: Optional[Sequence[str]] = None,
             denies: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if allows is not None:
            _setter("allows", allows)
        if denies is not None:
            _setter("denies", denies)

    @property
    @pulumi.getter
    def allows(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "allows")

    @property
    @pulumi.getter
    def denies(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "denies")


@pulumi.output_type
class OrgAuthConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "domainAutoMembers":
            suggest = "domain_auto_members"
        elif key == "samlOnly":
            suggest = "saml_only"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OrgAuthConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OrgAuthConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OrgAuthConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 domain_auto_members: Sequence[str],
                 saml_only: Optional[bool] = None):
        OrgAuthConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            domain_auto_members=domain_auto_members,
            saml_only=saml_only,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             domain_auto_members: Sequence[str],
             saml_only: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'domainAutoMembers' in kwargs:
            domain_auto_members = kwargs['domainAutoMembers']
        if 'samlOnly' in kwargs:
            saml_only = kwargs['samlOnly']

        _setter("domain_auto_members", domain_auto_members)
        if saml_only is not None:
            _setter("saml_only", saml_only)

    @property
    @pulumi.getter(name="domainAutoMembers")
    def domain_auto_members(self) -> Sequence[str]:
        return pulumi.get(self, "domain_auto_members")

    @property
    @pulumi.getter(name="samlOnly")
    def saml_only(self) -> Optional[bool]:
        return pulumi.get(self, "saml_only")


@pulumi.output_type
class OrgLoggingCoralogixLogging(dict):
    def __init__(__self__, *,
                 app: str,
                 cluster: str,
                 credentials: str,
                 subsystem: str):
        OrgLoggingCoralogixLogging._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            app=app,
            cluster=cluster,
            credentials=credentials,
            subsystem=subsystem,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             app: str,
             cluster: str,
             credentials: str,
             subsystem: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("app", app)
        _setter("cluster", cluster)
        _setter("credentials", credentials)
        _setter("subsystem", subsystem)

    @property
    @pulumi.getter
    def app(self) -> str:
        return pulumi.get(self, "app")

    @property
    @pulumi.getter
    def cluster(self) -> str:
        return pulumi.get(self, "cluster")

    @property
    @pulumi.getter
    def credentials(self) -> str:
        return pulumi.get(self, "credentials")

    @property
    @pulumi.getter
    def subsystem(self) -> str:
        return pulumi.get(self, "subsystem")


@pulumi.output_type
class OrgLoggingDatadogLogging(dict):
    def __init__(__self__, *,
                 credentials: str,
                 host: str):
        OrgLoggingDatadogLogging._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            credentials=credentials,
            host=host,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             credentials: str,
             host: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("credentials", credentials)
        _setter("host", host)

    @property
    @pulumi.getter
    def credentials(self) -> str:
        return pulumi.get(self, "credentials")

    @property
    @pulumi.getter
    def host(self) -> str:
        return pulumi.get(self, "host")


@pulumi.output_type
class OrgLoggingElasticLogging(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "elasticCloud":
            suggest = "elastic_cloud"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OrgLoggingElasticLogging. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OrgLoggingElasticLogging.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OrgLoggingElasticLogging.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 aws: Optional['outputs.OrgLoggingElasticLoggingAws'] = None,
                 elastic_cloud: Optional['outputs.OrgLoggingElasticLoggingElasticCloud'] = None,
                 generic: Optional['outputs.OrgLoggingElasticLoggingGeneric'] = None):
        OrgLoggingElasticLogging._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aws=aws,
            elastic_cloud=elastic_cloud,
            generic=generic,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aws: Optional['outputs.OrgLoggingElasticLoggingAws'] = None,
             elastic_cloud: Optional['outputs.OrgLoggingElasticLoggingElasticCloud'] = None,
             generic: Optional['outputs.OrgLoggingElasticLoggingGeneric'] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'elasticCloud' in kwargs:
            elastic_cloud = kwargs['elasticCloud']

        if aws is not None:
            _setter("aws", aws)
        if elastic_cloud is not None:
            _setter("elastic_cloud", elastic_cloud)
        if generic is not None:
            _setter("generic", generic)

    @property
    @pulumi.getter
    def aws(self) -> Optional['outputs.OrgLoggingElasticLoggingAws']:
        return pulumi.get(self, "aws")

    @property
    @pulumi.getter(name="elasticCloud")
    def elastic_cloud(self) -> Optional['outputs.OrgLoggingElasticLoggingElasticCloud']:
        return pulumi.get(self, "elastic_cloud")

    @property
    @pulumi.getter
    def generic(self) -> Optional['outputs.OrgLoggingElasticLoggingGeneric']:
        return pulumi.get(self, "generic")


@pulumi.output_type
class OrgLoggingElasticLoggingAws(dict):
    def __init__(__self__, *,
                 credentials: str,
                 host: str,
                 index: str,
                 port: int,
                 region: str,
                 type: str):
        OrgLoggingElasticLoggingAws._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            credentials=credentials,
            host=host,
            index=index,
            port=port,
            region=region,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             credentials: str,
             host: str,
             index: str,
             port: int,
             region: str,
             type: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("credentials", credentials)
        _setter("host", host)
        _setter("index", index)
        _setter("port", port)
        _setter("region", region)
        _setter("type", type)

    @property
    @pulumi.getter
    def credentials(self) -> str:
        return pulumi.get(self, "credentials")

    @property
    @pulumi.getter
    def host(self) -> str:
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def index(self) -> str:
        return pulumi.get(self, "index")

    @property
    @pulumi.getter
    def port(self) -> int:
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def region(self) -> str:
        return pulumi.get(self, "region")

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")


@pulumi.output_type
class OrgLoggingElasticLoggingElasticCloud(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cloudId":
            suggest = "cloud_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OrgLoggingElasticLoggingElasticCloud. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OrgLoggingElasticLoggingElasticCloud.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OrgLoggingElasticLoggingElasticCloud.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cloud_id: str,
                 credentials: str,
                 index: str,
                 type: str):
        OrgLoggingElasticLoggingElasticCloud._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cloud_id=cloud_id,
            credentials=credentials,
            index=index,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cloud_id: str,
             credentials: str,
             index: str,
             type: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'cloudId' in kwargs:
            cloud_id = kwargs['cloudId']

        _setter("cloud_id", cloud_id)
        _setter("credentials", credentials)
        _setter("index", index)
        _setter("type", type)

    @property
    @pulumi.getter(name="cloudId")
    def cloud_id(self) -> str:
        return pulumi.get(self, "cloud_id")

    @property
    @pulumi.getter
    def credentials(self) -> str:
        return pulumi.get(self, "credentials")

    @property
    @pulumi.getter
    def index(self) -> str:
        return pulumi.get(self, "index")

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")


@pulumi.output_type
class OrgLoggingElasticLoggingGeneric(dict):
    def __init__(__self__, *,
                 credentials: str,
                 host: str,
                 index: str,
                 path: str,
                 port: int,
                 type: str):
        OrgLoggingElasticLoggingGeneric._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            credentials=credentials,
            host=host,
            index=index,
            path=path,
            port=port,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             credentials: str,
             host: str,
             index: str,
             path: str,
             port: int,
             type: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("credentials", credentials)
        _setter("host", host)
        _setter("index", index)
        _setter("path", path)
        _setter("port", port)
        _setter("type", type)

    @property
    @pulumi.getter
    def credentials(self) -> str:
        return pulumi.get(self, "credentials")

    @property
    @pulumi.getter
    def host(self) -> str:
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def index(self) -> str:
        return pulumi.get(self, "index")

    @property
    @pulumi.getter
    def path(self) -> str:
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def port(self) -> int:
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")


@pulumi.output_type
class OrgLoggingLogzioLogging(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "listenerHost":
            suggest = "listener_host"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OrgLoggingLogzioLogging. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OrgLoggingLogzioLogging.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OrgLoggingLogzioLogging.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 credentials: str,
                 listener_host: str):
        OrgLoggingLogzioLogging._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            credentials=credentials,
            listener_host=listener_host,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             credentials: str,
             listener_host: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'listenerHost' in kwargs:
            listener_host = kwargs['listenerHost']

        _setter("credentials", credentials)
        _setter("listener_host", listener_host)

    @property
    @pulumi.getter
    def credentials(self) -> str:
        return pulumi.get(self, "credentials")

    @property
    @pulumi.getter(name="listenerHost")
    def listener_host(self) -> str:
        return pulumi.get(self, "listener_host")


@pulumi.output_type
class OrgLoggingS3Logging(dict):
    def __init__(__self__, *,
                 bucket: str,
                 credentials: str,
                 region: str,
                 prefix: Optional[str] = None):
        OrgLoggingS3Logging._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            bucket=bucket,
            credentials=credentials,
            region=region,
            prefix=prefix,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             bucket: str,
             credentials: str,
             region: str,
             prefix: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("bucket", bucket)
        _setter("credentials", credentials)
        _setter("region", region)
        if prefix is not None:
            _setter("prefix", prefix)

    @property
    @pulumi.getter
    def bucket(self) -> str:
        return pulumi.get(self, "bucket")

    @property
    @pulumi.getter
    def credentials(self) -> str:
        return pulumi.get(self, "credentials")

    @property
    @pulumi.getter
    def region(self) -> str:
        return pulumi.get(self, "region")

    @property
    @pulumi.getter
    def prefix(self) -> Optional[str]:
        return pulumi.get(self, "prefix")


@pulumi.output_type
class OrgObservability(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "logsRetentionDays":
            suggest = "logs_retention_days"
        elif key == "metricsRetentionDays":
            suggest = "metrics_retention_days"
        elif key == "tracesRetentionDays":
            suggest = "traces_retention_days"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OrgObservability. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OrgObservability.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OrgObservability.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 logs_retention_days: Optional[int] = None,
                 metrics_retention_days: Optional[int] = None,
                 traces_retention_days: Optional[int] = None):
        OrgObservability._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            logs_retention_days=logs_retention_days,
            metrics_retention_days=metrics_retention_days,
            traces_retention_days=traces_retention_days,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             logs_retention_days: Optional[int] = None,
             metrics_retention_days: Optional[int] = None,
             traces_retention_days: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'logsRetentionDays' in kwargs:
            logs_retention_days = kwargs['logsRetentionDays']
        if 'metricsRetentionDays' in kwargs:
            metrics_retention_days = kwargs['metricsRetentionDays']
        if 'tracesRetentionDays' in kwargs:
            traces_retention_days = kwargs['tracesRetentionDays']

        if logs_retention_days is not None:
            _setter("logs_retention_days", logs_retention_days)
        if metrics_retention_days is not None:
            _setter("metrics_retention_days", metrics_retention_days)
        if traces_retention_days is not None:
            _setter("traces_retention_days", traces_retention_days)

    @property
    @pulumi.getter(name="logsRetentionDays")
    def logs_retention_days(self) -> Optional[int]:
        return pulumi.get(self, "logs_retention_days")

    @property
    @pulumi.getter(name="metricsRetentionDays")
    def metrics_retention_days(self) -> Optional[int]:
        return pulumi.get(self, "metrics_retention_days")

    @property
    @pulumi.getter(name="tracesRetentionDays")
    def traces_retention_days(self) -> Optional[int]:
        return pulumi.get(self, "traces_retention_days")


@pulumi.output_type
class OrgStatus(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accountLink":
            suggest = "account_link"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OrgStatus. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OrgStatus.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OrgStatus.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 account_link: Optional[str] = None,
                 active: Optional[bool] = None):
        OrgStatus._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            account_link=account_link,
            active=active,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             account_link: Optional[str] = None,
             active: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'accountLink' in kwargs:
            account_link = kwargs['accountLink']

        if account_link is not None:
            _setter("account_link", account_link)
        if active is not None:
            _setter("active", active)

    @property
    @pulumi.getter(name="accountLink")
    def account_link(self) -> Optional[str]:
        return pulumi.get(self, "account_link")

    @property
    @pulumi.getter
    def active(self) -> Optional[bool]:
        return pulumi.get(self, "active")


@pulumi.output_type
class OrgTracingControlplaneTracing(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customTags":
            suggest = "custom_tags"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OrgTracingControlplaneTracing. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OrgTracingControlplaneTracing.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OrgTracingControlplaneTracing.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 sampling: int,
                 custom_tags: Optional[Mapping[str, str]] = None):
        OrgTracingControlplaneTracing._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            sampling=sampling,
            custom_tags=custom_tags,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             sampling: int,
             custom_tags: Optional[Mapping[str, str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'customTags' in kwargs:
            custom_tags = kwargs['customTags']

        _setter("sampling", sampling)
        if custom_tags is not None:
            _setter("custom_tags", custom_tags)

    @property
    @pulumi.getter
    def sampling(self) -> int:
        return pulumi.get(self, "sampling")

    @property
    @pulumi.getter(name="customTags")
    def custom_tags(self) -> Optional[Mapping[str, str]]:
        return pulumi.get(self, "custom_tags")


@pulumi.output_type
class OrgTracingLightstepTracing(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customTags":
            suggest = "custom_tags"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OrgTracingLightstepTracing. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OrgTracingLightstepTracing.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OrgTracingLightstepTracing.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 endpoint: str,
                 sampling: int,
                 credentials: Optional[str] = None,
                 custom_tags: Optional[Mapping[str, str]] = None):
        OrgTracingLightstepTracing._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            endpoint=endpoint,
            sampling=sampling,
            credentials=credentials,
            custom_tags=custom_tags,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             endpoint: str,
             sampling: int,
             credentials: Optional[str] = None,
             custom_tags: Optional[Mapping[str, str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'customTags' in kwargs:
            custom_tags = kwargs['customTags']

        _setter("endpoint", endpoint)
        _setter("sampling", sampling)
        if credentials is not None:
            _setter("credentials", credentials)
        if custom_tags is not None:
            _setter("custom_tags", custom_tags)

    @property
    @pulumi.getter
    def endpoint(self) -> str:
        return pulumi.get(self, "endpoint")

    @property
    @pulumi.getter
    def sampling(self) -> int:
        return pulumi.get(self, "sampling")

    @property
    @pulumi.getter
    def credentials(self) -> Optional[str]:
        return pulumi.get(self, "credentials")

    @property
    @pulumi.getter(name="customTags")
    def custom_tags(self) -> Optional[Mapping[str, str]]:
        return pulumi.get(self, "custom_tags")


@pulumi.output_type
class OrgTracingOtelTracing(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customTags":
            suggest = "custom_tags"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OrgTracingOtelTracing. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OrgTracingOtelTracing.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OrgTracingOtelTracing.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 endpoint: str,
                 sampling: int,
                 custom_tags: Optional[Mapping[str, str]] = None):
        OrgTracingOtelTracing._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            endpoint=endpoint,
            sampling=sampling,
            custom_tags=custom_tags,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             endpoint: str,
             sampling: int,
             custom_tags: Optional[Mapping[str, str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'customTags' in kwargs:
            custom_tags = kwargs['customTags']

        _setter("endpoint", endpoint)
        _setter("sampling", sampling)
        if custom_tags is not None:
            _setter("custom_tags", custom_tags)

    @property
    @pulumi.getter
    def endpoint(self) -> str:
        return pulumi.get(self, "endpoint")

    @property
    @pulumi.getter
    def sampling(self) -> int:
        return pulumi.get(self, "sampling")

    @property
    @pulumi.getter(name="customTags")
    def custom_tags(self) -> Optional[Mapping[str, str]]:
        return pulumi.get(self, "custom_tags")


@pulumi.output_type
class PolicyBinding(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "principalLinks":
            suggest = "principal_links"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PolicyBinding. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PolicyBinding.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PolicyBinding.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 permissions: Sequence[str],
                 principal_links: Sequence[str]):
        PolicyBinding._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            permissions=permissions,
            principal_links=principal_links,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             permissions: Sequence[str],
             principal_links: Sequence[str],
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'principalLinks' in kwargs:
            principal_links = kwargs['principalLinks']

        _setter("permissions", permissions)
        _setter("principal_links", principal_links)

    @property
    @pulumi.getter
    def permissions(self) -> Sequence[str]:
        return pulumi.get(self, "permissions")

    @property
    @pulumi.getter(name="principalLinks")
    def principal_links(self) -> Sequence[str]:
        return pulumi.get(self, "principal_links")


@pulumi.output_type
class PolicyTargetQuery(dict):
    def __init__(__self__, *,
                 fetch: Optional[str] = None,
                 spec: Optional['outputs.PolicyTargetQuerySpec'] = None):
        PolicyTargetQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            fetch=fetch,
            spec=spec,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             fetch: Optional[str] = None,
             spec: Optional['outputs.PolicyTargetQuerySpec'] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if fetch is not None:
            _setter("fetch", fetch)
        if spec is not None:
            _setter("spec", spec)

    @property
    @pulumi.getter
    def fetch(self) -> Optional[str]:
        return pulumi.get(self, "fetch")

    @property
    @pulumi.getter
    def spec(self) -> Optional['outputs.PolicyTargetQuerySpec']:
        return pulumi.get(self, "spec")


@pulumi.output_type
class PolicyTargetQuerySpec(dict):
    def __init__(__self__, *,
                 match: Optional[str] = None,
                 terms: Optional[Sequence['outputs.PolicyTargetQuerySpecTerm']] = None):
        PolicyTargetQuerySpec._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            match=match,
            terms=terms,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             match: Optional[str] = None,
             terms: Optional[Sequence['outputs.PolicyTargetQuerySpecTerm']] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if match is not None:
            _setter("match", match)
        if terms is not None:
            _setter("terms", terms)

    @property
    @pulumi.getter
    def match(self) -> Optional[str]:
        return pulumi.get(self, "match")

    @property
    @pulumi.getter
    def terms(self) -> Optional[Sequence['outputs.PolicyTargetQuerySpecTerm']]:
        return pulumi.get(self, "terms")


@pulumi.output_type
class PolicyTargetQuerySpecTerm(dict):
    def __init__(__self__, *,
                 op: Optional[str] = None,
                 property: Optional[str] = None,
                 tag: Optional[str] = None,
                 value: Optional[str] = None):
        PolicyTargetQuerySpecTerm._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            op=op,
            property=property,
            tag=tag,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             op: Optional[str] = None,
             property: Optional[str] = None,
             tag: Optional[str] = None,
             value: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if op is not None:
            _setter("op", op)
        if property is not None:
            _setter("property", property)
        if tag is not None:
            _setter("tag", tag)
        if value is not None:
            _setter("value", value)

    @property
    @pulumi.getter
    def op(self) -> Optional[str]:
        return pulumi.get(self, "op")

    @property
    @pulumi.getter
    def tag(self) -> Optional[str]:
        return pulumi.get(self, "tag")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def property(self) -> Optional[str]:
        return pulumi.get(self, "property")


@pulumi.output_type
class SecretAws(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessKey":
            suggest = "access_key"
        elif key == "secretKey":
            suggest = "secret_key"
        elif key == "externalId":
            suggest = "external_id"
        elif key == "roleArn":
            suggest = "role_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SecretAws. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SecretAws.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SecretAws.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_key: str,
                 secret_key: str,
                 external_id: Optional[str] = None,
                 role_arn: Optional[str] = None):
        SecretAws._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            access_key=access_key,
            secret_key=secret_key,
            external_id=external_id,
            role_arn=role_arn,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             access_key: str,
             secret_key: str,
             external_id: Optional[str] = None,
             role_arn: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'accessKey' in kwargs:
            access_key = kwargs['accessKey']
        if 'secretKey' in kwargs:
            secret_key = kwargs['secretKey']
        if 'externalId' in kwargs:
            external_id = kwargs['externalId']
        if 'roleArn' in kwargs:
            role_arn = kwargs['roleArn']

        _setter("access_key", access_key)
        _setter("secret_key", secret_key)
        if external_id is not None:
            _setter("external_id", external_id)
        if role_arn is not None:
            _setter("role_arn", role_arn)

    @property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> str:
        return pulumi.get(self, "access_key")

    @property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> str:
        return pulumi.get(self, "secret_key")

    @property
    @pulumi.getter(name="externalId")
    def external_id(self) -> Optional[str]:
        return pulumi.get(self, "external_id")

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[str]:
        return pulumi.get(self, "role_arn")


@pulumi.output_type
class SecretAzureConnector(dict):
    def __init__(__self__, *,
                 code: str,
                 url: str):
        SecretAzureConnector._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            code=code,
            url=url,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             code: str,
             url: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("code", code)
        _setter("url", url)

    @property
    @pulumi.getter
    def code(self) -> str:
        return pulumi.get(self, "code")

    @property
    @pulumi.getter
    def url(self) -> str:
        return pulumi.get(self, "url")


@pulumi.output_type
class SecretEcr(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessKey":
            suggest = "access_key"
        elif key == "secretKey":
            suggest = "secret_key"
        elif key == "externalId":
            suggest = "external_id"
        elif key == "roleArn":
            suggest = "role_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SecretEcr. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SecretEcr.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SecretEcr.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_key: str,
                 repos: Sequence[str],
                 secret_key: str,
                 external_id: Optional[str] = None,
                 role_arn: Optional[str] = None):
        SecretEcr._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            access_key=access_key,
            repos=repos,
            secret_key=secret_key,
            external_id=external_id,
            role_arn=role_arn,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             access_key: str,
             repos: Sequence[str],
             secret_key: str,
             external_id: Optional[str] = None,
             role_arn: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'accessKey' in kwargs:
            access_key = kwargs['accessKey']
        if 'secretKey' in kwargs:
            secret_key = kwargs['secretKey']
        if 'externalId' in kwargs:
            external_id = kwargs['externalId']
        if 'roleArn' in kwargs:
            role_arn = kwargs['roleArn']

        _setter("access_key", access_key)
        _setter("repos", repos)
        _setter("secret_key", secret_key)
        if external_id is not None:
            _setter("external_id", external_id)
        if role_arn is not None:
            _setter("role_arn", role_arn)

    @property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> str:
        return pulumi.get(self, "access_key")

    @property
    @pulumi.getter
    def repos(self) -> Sequence[str]:
        return pulumi.get(self, "repos")

    @property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> str:
        return pulumi.get(self, "secret_key")

    @property
    @pulumi.getter(name="externalId")
    def external_id(self) -> Optional[str]:
        return pulumi.get(self, "external_id")

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[str]:
        return pulumi.get(self, "role_arn")


@pulumi.output_type
class SecretKeypair(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secretKey":
            suggest = "secret_key"
        elif key == "publicKey":
            suggest = "public_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SecretKeypair. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SecretKeypair.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SecretKeypair.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 secret_key: str,
                 passphrase: Optional[str] = None,
                 public_key: Optional[str] = None):
        SecretKeypair._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            secret_key=secret_key,
            passphrase=passphrase,
            public_key=public_key,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             secret_key: str,
             passphrase: Optional[str] = None,
             public_key: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'secretKey' in kwargs:
            secret_key = kwargs['secretKey']
        if 'publicKey' in kwargs:
            public_key = kwargs['publicKey']

        _setter("secret_key", secret_key)
        if passphrase is not None:
            _setter("passphrase", passphrase)
        if public_key is not None:
            _setter("public_key", public_key)

    @property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> str:
        return pulumi.get(self, "secret_key")

    @property
    @pulumi.getter
    def passphrase(self) -> Optional[str]:
        return pulumi.get(self, "passphrase")

    @property
    @pulumi.getter(name="publicKey")
    def public_key(self) -> Optional[str]:
        return pulumi.get(self, "public_key")


@pulumi.output_type
class SecretNatsAccount(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accountId":
            suggest = "account_id"
        elif key == "privateKey":
            suggest = "private_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SecretNatsAccount. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SecretNatsAccount.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SecretNatsAccount.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 account_id: str,
                 private_key: str):
        SecretNatsAccount._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            account_id=account_id,
            private_key=private_key,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             account_id: str,
             private_key: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'accountId' in kwargs:
            account_id = kwargs['accountId']
        if 'privateKey' in kwargs:
            private_key = kwargs['privateKey']

        _setter("account_id", account_id)
        _setter("private_key", private_key)

    @property
    @pulumi.getter(name="accountId")
    def account_id(self) -> str:
        return pulumi.get(self, "account_id")

    @property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> str:
        return pulumi.get(self, "private_key")


@pulumi.output_type
class SecretOpaque(dict):
    def __init__(__self__, *,
                 payload: str,
                 encoding: Optional[str] = None):
        SecretOpaque._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            payload=payload,
            encoding=encoding,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             payload: str,
             encoding: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("payload", payload)
        if encoding is not None:
            _setter("encoding", encoding)

    @property
    @pulumi.getter
    def payload(self) -> str:
        return pulumi.get(self, "payload")

    @property
    @pulumi.getter
    def encoding(self) -> Optional[str]:
        return pulumi.get(self, "encoding")


@pulumi.output_type
class SecretTls(dict):
    def __init__(__self__, *,
                 cert: str,
                 key: str,
                 chain: Optional[str] = None):
        SecretTls._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cert=cert,
            key=key,
            chain=chain,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cert: str,
             key: str,
             chain: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("cert", cert)
        _setter("key", key)
        if chain is not None:
            _setter("chain", chain)

    @property
    @pulumi.getter
    def cert(self) -> str:
        return pulumi.get(self, "cert")

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def chain(self) -> Optional[str]:
        return pulumi.get(self, "chain")


@pulumi.output_type
class SecretUserpass(dict):
    def __init__(__self__, *,
                 password: str,
                 username: str,
                 encoding: Optional[str] = None):
        SecretUserpass._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            password=password,
            username=username,
            encoding=encoding,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             password: str,
             username: str,
             encoding: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("password", password)
        _setter("username", username)
        if encoding is not None:
            _setter("encoding", encoding)

    @property
    @pulumi.getter
    def password(self) -> str:
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def username(self) -> str:
        return pulumi.get(self, "username")

    @property
    @pulumi.getter
    def encoding(self) -> Optional[str]:
        return pulumi.get(self, "encoding")


@pulumi.output_type
class VolumeSetAutoscaling(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxCapacity":
            suggest = "max_capacity"
        elif key == "minFreePercentage":
            suggest = "min_free_percentage"
        elif key == "scalingFactor":
            suggest = "scaling_factor"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VolumeSetAutoscaling. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VolumeSetAutoscaling.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VolumeSetAutoscaling.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_capacity: int,
                 min_free_percentage: int,
                 scaling_factor: float):
        VolumeSetAutoscaling._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            max_capacity=max_capacity,
            min_free_percentage=min_free_percentage,
            scaling_factor=scaling_factor,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             max_capacity: int,
             min_free_percentage: int,
             scaling_factor: float,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'maxCapacity' in kwargs:
            max_capacity = kwargs['maxCapacity']
        if 'minFreePercentage' in kwargs:
            min_free_percentage = kwargs['minFreePercentage']
        if 'scalingFactor' in kwargs:
            scaling_factor = kwargs['scalingFactor']

        _setter("max_capacity", max_capacity)
        _setter("min_free_percentage", min_free_percentage)
        _setter("scaling_factor", scaling_factor)

    @property
    @pulumi.getter(name="maxCapacity")
    def max_capacity(self) -> int:
        return pulumi.get(self, "max_capacity")

    @property
    @pulumi.getter(name="minFreePercentage")
    def min_free_percentage(self) -> int:
        return pulumi.get(self, "min_free_percentage")

    @property
    @pulumi.getter(name="scalingFactor")
    def scaling_factor(self) -> float:
        return pulumi.get(self, "scaling_factor")


@pulumi.output_type
class VolumeSetSnapshots(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "createFinalSnapshot":
            suggest = "create_final_snapshot"
        elif key == "retentionDuration":
            suggest = "retention_duration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VolumeSetSnapshots. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VolumeSetSnapshots.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VolumeSetSnapshots.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 create_final_snapshot: Optional[bool] = None,
                 retention_duration: Optional[str] = None,
                 schedule: Optional[str] = None):
        VolumeSetSnapshots._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            create_final_snapshot=create_final_snapshot,
            retention_duration=retention_duration,
            schedule=schedule,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             create_final_snapshot: Optional[bool] = None,
             retention_duration: Optional[str] = None,
             schedule: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'createFinalSnapshot' in kwargs:
            create_final_snapshot = kwargs['createFinalSnapshot']
        if 'retentionDuration' in kwargs:
            retention_duration = kwargs['retentionDuration']

        if create_final_snapshot is not None:
            _setter("create_final_snapshot", create_final_snapshot)
        if retention_duration is not None:
            _setter("retention_duration", retention_duration)
        if schedule is not None:
            _setter("schedule", schedule)

    @property
    @pulumi.getter(name="createFinalSnapshot")
    def create_final_snapshot(self) -> Optional[bool]:
        return pulumi.get(self, "create_final_snapshot")

    @property
    @pulumi.getter(name="retentionDuration")
    def retention_duration(self) -> Optional[str]:
        return pulumi.get(self, "retention_duration")

    @property
    @pulumi.getter
    def schedule(self) -> Optional[str]:
        return pulumi.get(self, "schedule")


@pulumi.output_type
class VolumeSetStatus(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bindingId":
            suggest = "binding_id"
        elif key == "parentId":
            suggest = "parent_id"
        elif key == "usedByWorkload":
            suggest = "used_by_workload"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VolumeSetStatus. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VolumeSetStatus.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VolumeSetStatus.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 binding_id: Optional[str] = None,
                 locations: Optional[Sequence[str]] = None,
                 parent_id: Optional[str] = None,
                 used_by_workload: Optional[str] = None):
        VolumeSetStatus._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            binding_id=binding_id,
            locations=locations,
            parent_id=parent_id,
            used_by_workload=used_by_workload,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             binding_id: Optional[str] = None,
             locations: Optional[Sequence[str]] = None,
             parent_id: Optional[str] = None,
             used_by_workload: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'bindingId' in kwargs:
            binding_id = kwargs['bindingId']
        if 'parentId' in kwargs:
            parent_id = kwargs['parentId']
        if 'usedByWorkload' in kwargs:
            used_by_workload = kwargs['usedByWorkload']

        if binding_id is not None:
            _setter("binding_id", binding_id)
        if locations is not None:
            _setter("locations", locations)
        if parent_id is not None:
            _setter("parent_id", parent_id)
        if used_by_workload is not None:
            _setter("used_by_workload", used_by_workload)

    @property
    @pulumi.getter(name="bindingId")
    def binding_id(self) -> Optional[str]:
        return pulumi.get(self, "binding_id")

    @property
    @pulumi.getter
    def locations(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "locations")

    @property
    @pulumi.getter(name="parentId")
    def parent_id(self) -> Optional[str]:
        return pulumi.get(self, "parent_id")

    @property
    @pulumi.getter(name="usedByWorkload")
    def used_by_workload(self) -> Optional[str]:
        return pulumi.get(self, "used_by_workload")


@pulumi.output_type
class WorkloadContainer(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "gpuNvidia":
            suggest = "gpu_nvidia"
        elif key == "inheritEnv":
            suggest = "inherit_env"
        elif key == "livenessProbe":
            suggest = "liveness_probe"
        elif key == "minCpu":
            suggest = "min_cpu"
        elif key == "minMemory":
            suggest = "min_memory"
        elif key == "readinessProbe":
            suggest = "readiness_probe"
        elif key == "workingDirectory":
            suggest = "working_directory"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkloadContainer. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkloadContainer.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkloadContainer.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 image: str,
                 name: str,
                 args: Optional[Sequence[str]] = None,
                 command: Optional[str] = None,
                 cpu: Optional[str] = None,
                 env: Optional[Mapping[str, str]] = None,
                 gpu_nvidia: Optional['outputs.WorkloadContainerGpuNvidia'] = None,
                 inherit_env: Optional[bool] = None,
                 lifecycle: Optional['outputs.WorkloadContainerLifecycle'] = None,
                 liveness_probe: Optional['outputs.WorkloadContainerLivenessProbe'] = None,
                 memory: Optional[str] = None,
                 metrics: Optional['outputs.WorkloadContainerMetrics'] = None,
                 min_cpu: Optional[str] = None,
                 min_memory: Optional[str] = None,
                 port: Optional[int] = None,
                 ports: Optional[Sequence['outputs.WorkloadContainerPort']] = None,
                 readiness_probe: Optional['outputs.WorkloadContainerReadinessProbe'] = None,
                 volumes: Optional[Sequence['outputs.WorkloadContainerVolume']] = None,
                 working_directory: Optional[str] = None):
        WorkloadContainer._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            image=image,
            name=name,
            args=args,
            command=command,
            cpu=cpu,
            env=env,
            gpu_nvidia=gpu_nvidia,
            inherit_env=inherit_env,
            lifecycle=lifecycle,
            liveness_probe=liveness_probe,
            memory=memory,
            metrics=metrics,
            min_cpu=min_cpu,
            min_memory=min_memory,
            port=port,
            ports=ports,
            readiness_probe=readiness_probe,
            volumes=volumes,
            working_directory=working_directory,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             image: str,
             name: str,
             args: Optional[Sequence[str]] = None,
             command: Optional[str] = None,
             cpu: Optional[str] = None,
             env: Optional[Mapping[str, str]] = None,
             gpu_nvidia: Optional['outputs.WorkloadContainerGpuNvidia'] = None,
             inherit_env: Optional[bool] = None,
             lifecycle: Optional['outputs.WorkloadContainerLifecycle'] = None,
             liveness_probe: Optional['outputs.WorkloadContainerLivenessProbe'] = None,
             memory: Optional[str] = None,
             metrics: Optional['outputs.WorkloadContainerMetrics'] = None,
             min_cpu: Optional[str] = None,
             min_memory: Optional[str] = None,
             port: Optional[int] = None,
             ports: Optional[Sequence['outputs.WorkloadContainerPort']] = None,
             readiness_probe: Optional['outputs.WorkloadContainerReadinessProbe'] = None,
             volumes: Optional[Sequence['outputs.WorkloadContainerVolume']] = None,
             working_directory: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'gpuNvidia' in kwargs:
            gpu_nvidia = kwargs['gpuNvidia']
        if 'inheritEnv' in kwargs:
            inherit_env = kwargs['inheritEnv']
        if 'livenessProbe' in kwargs:
            liveness_probe = kwargs['livenessProbe']
        if 'minCpu' in kwargs:
            min_cpu = kwargs['minCpu']
        if 'minMemory' in kwargs:
            min_memory = kwargs['minMemory']
        if 'readinessProbe' in kwargs:
            readiness_probe = kwargs['readinessProbe']
        if 'workingDirectory' in kwargs:
            working_directory = kwargs['workingDirectory']

        _setter("image", image)
        _setter("name", name)
        if args is not None:
            _setter("args", args)
        if command is not None:
            _setter("command", command)
        if cpu is not None:
            _setter("cpu", cpu)
        if env is not None:
            _setter("env", env)
        if gpu_nvidia is not None:
            _setter("gpu_nvidia", gpu_nvidia)
        if inherit_env is not None:
            _setter("inherit_env", inherit_env)
        if lifecycle is not None:
            _setter("lifecycle", lifecycle)
        if liveness_probe is not None:
            _setter("liveness_probe", liveness_probe)
        if memory is not None:
            _setter("memory", memory)
        if metrics is not None:
            _setter("metrics", metrics)
        if min_cpu is not None:
            _setter("min_cpu", min_cpu)
        if min_memory is not None:
            _setter("min_memory", min_memory)
        if port is not None:
            _setter("port", port)
        if ports is not None:
            _setter("ports", ports)
        if readiness_probe is not None:
            _setter("readiness_probe", readiness_probe)
        if volumes is not None:
            _setter("volumes", volumes)
        if working_directory is not None:
            _setter("working_directory", working_directory)

    @property
    @pulumi.getter
    def image(self) -> str:
        return pulumi.get(self, "image")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def args(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "args")

    @property
    @pulumi.getter
    def command(self) -> Optional[str]:
        return pulumi.get(self, "command")

    @property
    @pulumi.getter
    def cpu(self) -> Optional[str]:
        return pulumi.get(self, "cpu")

    @property
    @pulumi.getter
    def env(self) -> Optional[Mapping[str, str]]:
        return pulumi.get(self, "env")

    @property
    @pulumi.getter(name="gpuNvidia")
    def gpu_nvidia(self) -> Optional['outputs.WorkloadContainerGpuNvidia']:
        return pulumi.get(self, "gpu_nvidia")

    @property
    @pulumi.getter(name="inheritEnv")
    def inherit_env(self) -> Optional[bool]:
        return pulumi.get(self, "inherit_env")

    @property
    @pulumi.getter
    def lifecycle(self) -> Optional['outputs.WorkloadContainerLifecycle']:
        return pulumi.get(self, "lifecycle")

    @property
    @pulumi.getter(name="livenessProbe")
    def liveness_probe(self) -> Optional['outputs.WorkloadContainerLivenessProbe']:
        return pulumi.get(self, "liveness_probe")

    @property
    @pulumi.getter
    def memory(self) -> Optional[str]:
        return pulumi.get(self, "memory")

    @property
    @pulumi.getter
    def metrics(self) -> Optional['outputs.WorkloadContainerMetrics']:
        return pulumi.get(self, "metrics")

    @property
    @pulumi.getter(name="minCpu")
    def min_cpu(self) -> Optional[str]:
        return pulumi.get(self, "min_cpu")

    @property
    @pulumi.getter(name="minMemory")
    def min_memory(self) -> Optional[str]:
        return pulumi.get(self, "min_memory")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        warnings.warn("""The 'port' attribute will be deprecated in the next major version. Use the 'ports' attribute instead.""", DeprecationWarning)
        pulumi.log.warn("""port is deprecated: The 'port' attribute will be deprecated in the next major version. Use the 'ports' attribute instead.""")

        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def ports(self) -> Optional[Sequence['outputs.WorkloadContainerPort']]:
        return pulumi.get(self, "ports")

    @property
    @pulumi.getter(name="readinessProbe")
    def readiness_probe(self) -> Optional['outputs.WorkloadContainerReadinessProbe']:
        return pulumi.get(self, "readiness_probe")

    @property
    @pulumi.getter
    def volumes(self) -> Optional[Sequence['outputs.WorkloadContainerVolume']]:
        return pulumi.get(self, "volumes")

    @property
    @pulumi.getter(name="workingDirectory")
    def working_directory(self) -> Optional[str]:
        return pulumi.get(self, "working_directory")


@pulumi.output_type
class WorkloadContainerGpuNvidia(dict):
    def __init__(__self__, *,
                 model: str,
                 quantity: int):
        WorkloadContainerGpuNvidia._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            model=model,
            quantity=quantity,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             model: str,
             quantity: int,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("model", model)
        _setter("quantity", quantity)

    @property
    @pulumi.getter
    def model(self) -> str:
        return pulumi.get(self, "model")

    @property
    @pulumi.getter
    def quantity(self) -> int:
        return pulumi.get(self, "quantity")


@pulumi.output_type
class WorkloadContainerLifecycle(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "postStart":
            suggest = "post_start"
        elif key == "preStop":
            suggest = "pre_stop"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkloadContainerLifecycle. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkloadContainerLifecycle.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkloadContainerLifecycle.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 post_start: Optional['outputs.WorkloadContainerLifecyclePostStart'] = None,
                 pre_stop: Optional['outputs.WorkloadContainerLifecyclePreStop'] = None):
        WorkloadContainerLifecycle._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            post_start=post_start,
            pre_stop=pre_stop,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             post_start: Optional['outputs.WorkloadContainerLifecyclePostStart'] = None,
             pre_stop: Optional['outputs.WorkloadContainerLifecyclePreStop'] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'postStart' in kwargs:
            post_start = kwargs['postStart']
        if 'preStop' in kwargs:
            pre_stop = kwargs['preStop']

        if post_start is not None:
            _setter("post_start", post_start)
        if pre_stop is not None:
            _setter("pre_stop", pre_stop)

    @property
    @pulumi.getter(name="postStart")
    def post_start(self) -> Optional['outputs.WorkloadContainerLifecyclePostStart']:
        return pulumi.get(self, "post_start")

    @property
    @pulumi.getter(name="preStop")
    def pre_stop(self) -> Optional['outputs.WorkloadContainerLifecyclePreStop']:
        return pulumi.get(self, "pre_stop")


@pulumi.output_type
class WorkloadContainerLifecyclePostStart(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "exec":
            suggest = "exec_"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkloadContainerLifecyclePostStart. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkloadContainerLifecyclePostStart.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkloadContainerLifecyclePostStart.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 exec_: 'outputs.WorkloadContainerLifecyclePostStartExec'):
        WorkloadContainerLifecyclePostStart._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            exec_=exec_,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             exec_: 'outputs.WorkloadContainerLifecyclePostStartExec',
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'exec' in kwargs:
            exec_ = kwargs['exec']

        _setter("exec_", exec_)

    @property
    @pulumi.getter(name="exec")
    def exec_(self) -> 'outputs.WorkloadContainerLifecyclePostStartExec':
        return pulumi.get(self, "exec_")


@pulumi.output_type
class WorkloadContainerLifecyclePostStartExec(dict):
    def __init__(__self__, *,
                 commands: Sequence[str]):
        WorkloadContainerLifecyclePostStartExec._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            commands=commands,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             commands: Sequence[str],
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("commands", commands)

    @property
    @pulumi.getter
    def commands(self) -> Sequence[str]:
        return pulumi.get(self, "commands")


@pulumi.output_type
class WorkloadContainerLifecyclePreStop(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "exec":
            suggest = "exec_"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkloadContainerLifecyclePreStop. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkloadContainerLifecyclePreStop.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkloadContainerLifecyclePreStop.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 exec_: 'outputs.WorkloadContainerLifecyclePreStopExec'):
        WorkloadContainerLifecyclePreStop._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            exec_=exec_,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             exec_: 'outputs.WorkloadContainerLifecyclePreStopExec',
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'exec' in kwargs:
            exec_ = kwargs['exec']

        _setter("exec_", exec_)

    @property
    @pulumi.getter(name="exec")
    def exec_(self) -> 'outputs.WorkloadContainerLifecyclePreStopExec':
        return pulumi.get(self, "exec_")


@pulumi.output_type
class WorkloadContainerLifecyclePreStopExec(dict):
    def __init__(__self__, *,
                 commands: Sequence[str]):
        WorkloadContainerLifecyclePreStopExec._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            commands=commands,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             commands: Sequence[str],
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("commands", commands)

    @property
    @pulumi.getter
    def commands(self) -> Sequence[str]:
        return pulumi.get(self, "commands")


@pulumi.output_type
class WorkloadContainerLivenessProbe(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "exec":
            suggest = "exec_"
        elif key == "failureThreshold":
            suggest = "failure_threshold"
        elif key == "httpGet":
            suggest = "http_get"
        elif key == "initialDelaySeconds":
            suggest = "initial_delay_seconds"
        elif key == "periodSeconds":
            suggest = "period_seconds"
        elif key == "successThreshold":
            suggest = "success_threshold"
        elif key == "tcpSocket":
            suggest = "tcp_socket"
        elif key == "timeoutSeconds":
            suggest = "timeout_seconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkloadContainerLivenessProbe. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkloadContainerLivenessProbe.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkloadContainerLivenessProbe.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 exec_: Optional['outputs.WorkloadContainerLivenessProbeExec'] = None,
                 failure_threshold: Optional[int] = None,
                 grpc: Optional['outputs.WorkloadContainerLivenessProbeGrpc'] = None,
                 http_get: Optional['outputs.WorkloadContainerLivenessProbeHttpGet'] = None,
                 initial_delay_seconds: Optional[int] = None,
                 period_seconds: Optional[int] = None,
                 success_threshold: Optional[int] = None,
                 tcp_socket: Optional['outputs.WorkloadContainerLivenessProbeTcpSocket'] = None,
                 timeout_seconds: Optional[int] = None):
        WorkloadContainerLivenessProbe._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            exec_=exec_,
            failure_threshold=failure_threshold,
            grpc=grpc,
            http_get=http_get,
            initial_delay_seconds=initial_delay_seconds,
            period_seconds=period_seconds,
            success_threshold=success_threshold,
            tcp_socket=tcp_socket,
            timeout_seconds=timeout_seconds,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             exec_: Optional['outputs.WorkloadContainerLivenessProbeExec'] = None,
             failure_threshold: Optional[int] = None,
             grpc: Optional['outputs.WorkloadContainerLivenessProbeGrpc'] = None,
             http_get: Optional['outputs.WorkloadContainerLivenessProbeHttpGet'] = None,
             initial_delay_seconds: Optional[int] = None,
             period_seconds: Optional[int] = None,
             success_threshold: Optional[int] = None,
             tcp_socket: Optional['outputs.WorkloadContainerLivenessProbeTcpSocket'] = None,
             timeout_seconds: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'exec' in kwargs:
            exec_ = kwargs['exec']
        if 'failureThreshold' in kwargs:
            failure_threshold = kwargs['failureThreshold']
        if 'httpGet' in kwargs:
            http_get = kwargs['httpGet']
        if 'initialDelaySeconds' in kwargs:
            initial_delay_seconds = kwargs['initialDelaySeconds']
        if 'periodSeconds' in kwargs:
            period_seconds = kwargs['periodSeconds']
        if 'successThreshold' in kwargs:
            success_threshold = kwargs['successThreshold']
        if 'tcpSocket' in kwargs:
            tcp_socket = kwargs['tcpSocket']
        if 'timeoutSeconds' in kwargs:
            timeout_seconds = kwargs['timeoutSeconds']

        if exec_ is not None:
            _setter("exec_", exec_)
        if failure_threshold is not None:
            _setter("failure_threshold", failure_threshold)
        if grpc is not None:
            _setter("grpc", grpc)
        if http_get is not None:
            _setter("http_get", http_get)
        if initial_delay_seconds is not None:
            _setter("initial_delay_seconds", initial_delay_seconds)
        if period_seconds is not None:
            _setter("period_seconds", period_seconds)
        if success_threshold is not None:
            _setter("success_threshold", success_threshold)
        if tcp_socket is not None:
            _setter("tcp_socket", tcp_socket)
        if timeout_seconds is not None:
            _setter("timeout_seconds", timeout_seconds)

    @property
    @pulumi.getter(name="exec")
    def exec_(self) -> Optional['outputs.WorkloadContainerLivenessProbeExec']:
        return pulumi.get(self, "exec_")

    @property
    @pulumi.getter(name="failureThreshold")
    def failure_threshold(self) -> Optional[int]:
        return pulumi.get(self, "failure_threshold")

    @property
    @pulumi.getter
    def grpc(self) -> Optional['outputs.WorkloadContainerLivenessProbeGrpc']:
        return pulumi.get(self, "grpc")

    @property
    @pulumi.getter(name="httpGet")
    def http_get(self) -> Optional['outputs.WorkloadContainerLivenessProbeHttpGet']:
        return pulumi.get(self, "http_get")

    @property
    @pulumi.getter(name="initialDelaySeconds")
    def initial_delay_seconds(self) -> Optional[int]:
        return pulumi.get(self, "initial_delay_seconds")

    @property
    @pulumi.getter(name="periodSeconds")
    def period_seconds(self) -> Optional[int]:
        return pulumi.get(self, "period_seconds")

    @property
    @pulumi.getter(name="successThreshold")
    def success_threshold(self) -> Optional[int]:
        return pulumi.get(self, "success_threshold")

    @property
    @pulumi.getter(name="tcpSocket")
    def tcp_socket(self) -> Optional['outputs.WorkloadContainerLivenessProbeTcpSocket']:
        return pulumi.get(self, "tcp_socket")

    @property
    @pulumi.getter(name="timeoutSeconds")
    def timeout_seconds(self) -> Optional[int]:
        return pulumi.get(self, "timeout_seconds")


@pulumi.output_type
class WorkloadContainerLivenessProbeExec(dict):
    def __init__(__self__, *,
                 commands: Sequence[str]):
        WorkloadContainerLivenessProbeExec._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            commands=commands,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             commands: Sequence[str],
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("commands", commands)

    @property
    @pulumi.getter
    def commands(self) -> Sequence[str]:
        return pulumi.get(self, "commands")


@pulumi.output_type
class WorkloadContainerLivenessProbeGrpc(dict):
    def __init__(__self__, *,
                 port: Optional[int] = None):
        WorkloadContainerLivenessProbeGrpc._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            port=port,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             port: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if port is not None:
            _setter("port", port)

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        return pulumi.get(self, "port")


@pulumi.output_type
class WorkloadContainerLivenessProbeHttpGet(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "httpHeaders":
            suggest = "http_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkloadContainerLivenessProbeHttpGet. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkloadContainerLivenessProbeHttpGet.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkloadContainerLivenessProbeHttpGet.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 http_headers: Optional[Mapping[str, str]] = None,
                 path: Optional[str] = None,
                 port: Optional[int] = None,
                 scheme: Optional[str] = None):
        WorkloadContainerLivenessProbeHttpGet._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            http_headers=http_headers,
            path=path,
            port=port,
            scheme=scheme,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             http_headers: Optional[Mapping[str, str]] = None,
             path: Optional[str] = None,
             port: Optional[int] = None,
             scheme: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'httpHeaders' in kwargs:
            http_headers = kwargs['httpHeaders']

        if http_headers is not None:
            _setter("http_headers", http_headers)
        if path is not None:
            _setter("path", path)
        if port is not None:
            _setter("port", port)
        if scheme is not None:
            _setter("scheme", scheme)

    @property
    @pulumi.getter(name="httpHeaders")
    def http_headers(self) -> Optional[Mapping[str, str]]:
        return pulumi.get(self, "http_headers")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def scheme(self) -> Optional[str]:
        return pulumi.get(self, "scheme")


@pulumi.output_type
class WorkloadContainerLivenessProbeTcpSocket(dict):
    def __init__(__self__, *,
                 port: Optional[int] = None):
        WorkloadContainerLivenessProbeTcpSocket._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            port=port,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             port: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if port is not None:
            _setter("port", port)

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        return pulumi.get(self, "port")


@pulumi.output_type
class WorkloadContainerMetrics(dict):
    def __init__(__self__, *,
                 path: str,
                 port: int):
        WorkloadContainerMetrics._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            path=path,
            port=port,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             path: str,
             port: int,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("path", path)
        _setter("port", port)

    @property
    @pulumi.getter
    def path(self) -> str:
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def port(self) -> int:
        return pulumi.get(self, "port")


@pulumi.output_type
class WorkloadContainerPort(dict):
    def __init__(__self__, *,
                 number: int,
                 protocol: Optional[str] = None):
        WorkloadContainerPort._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            number=number,
            protocol=protocol,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             number: int,
             protocol: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("number", number)
        if protocol is not None:
            _setter("protocol", protocol)

    @property
    @pulumi.getter
    def number(self) -> int:
        return pulumi.get(self, "number")

    @property
    @pulumi.getter
    def protocol(self) -> Optional[str]:
        return pulumi.get(self, "protocol")


@pulumi.output_type
class WorkloadContainerReadinessProbe(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "exec":
            suggest = "exec_"
        elif key == "failureThreshold":
            suggest = "failure_threshold"
        elif key == "httpGet":
            suggest = "http_get"
        elif key == "initialDelaySeconds":
            suggest = "initial_delay_seconds"
        elif key == "periodSeconds":
            suggest = "period_seconds"
        elif key == "successThreshold":
            suggest = "success_threshold"
        elif key == "tcpSocket":
            suggest = "tcp_socket"
        elif key == "timeoutSeconds":
            suggest = "timeout_seconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkloadContainerReadinessProbe. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkloadContainerReadinessProbe.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkloadContainerReadinessProbe.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 exec_: Optional['outputs.WorkloadContainerReadinessProbeExec'] = None,
                 failure_threshold: Optional[int] = None,
                 grpc: Optional['outputs.WorkloadContainerReadinessProbeGrpc'] = None,
                 http_get: Optional['outputs.WorkloadContainerReadinessProbeHttpGet'] = None,
                 initial_delay_seconds: Optional[int] = None,
                 period_seconds: Optional[int] = None,
                 success_threshold: Optional[int] = None,
                 tcp_socket: Optional['outputs.WorkloadContainerReadinessProbeTcpSocket'] = None,
                 timeout_seconds: Optional[int] = None):
        WorkloadContainerReadinessProbe._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            exec_=exec_,
            failure_threshold=failure_threshold,
            grpc=grpc,
            http_get=http_get,
            initial_delay_seconds=initial_delay_seconds,
            period_seconds=period_seconds,
            success_threshold=success_threshold,
            tcp_socket=tcp_socket,
            timeout_seconds=timeout_seconds,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             exec_: Optional['outputs.WorkloadContainerReadinessProbeExec'] = None,
             failure_threshold: Optional[int] = None,
             grpc: Optional['outputs.WorkloadContainerReadinessProbeGrpc'] = None,
             http_get: Optional['outputs.WorkloadContainerReadinessProbeHttpGet'] = None,
             initial_delay_seconds: Optional[int] = None,
             period_seconds: Optional[int] = None,
             success_threshold: Optional[int] = None,
             tcp_socket: Optional['outputs.WorkloadContainerReadinessProbeTcpSocket'] = None,
             timeout_seconds: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'exec' in kwargs:
            exec_ = kwargs['exec']
        if 'failureThreshold' in kwargs:
            failure_threshold = kwargs['failureThreshold']
        if 'httpGet' in kwargs:
            http_get = kwargs['httpGet']
        if 'initialDelaySeconds' in kwargs:
            initial_delay_seconds = kwargs['initialDelaySeconds']
        if 'periodSeconds' in kwargs:
            period_seconds = kwargs['periodSeconds']
        if 'successThreshold' in kwargs:
            success_threshold = kwargs['successThreshold']
        if 'tcpSocket' in kwargs:
            tcp_socket = kwargs['tcpSocket']
        if 'timeoutSeconds' in kwargs:
            timeout_seconds = kwargs['timeoutSeconds']

        if exec_ is not None:
            _setter("exec_", exec_)
        if failure_threshold is not None:
            _setter("failure_threshold", failure_threshold)
        if grpc is not None:
            _setter("grpc", grpc)
        if http_get is not None:
            _setter("http_get", http_get)
        if initial_delay_seconds is not None:
            _setter("initial_delay_seconds", initial_delay_seconds)
        if period_seconds is not None:
            _setter("period_seconds", period_seconds)
        if success_threshold is not None:
            _setter("success_threshold", success_threshold)
        if tcp_socket is not None:
            _setter("tcp_socket", tcp_socket)
        if timeout_seconds is not None:
            _setter("timeout_seconds", timeout_seconds)

    @property
    @pulumi.getter(name="exec")
    def exec_(self) -> Optional['outputs.WorkloadContainerReadinessProbeExec']:
        return pulumi.get(self, "exec_")

    @property
    @pulumi.getter(name="failureThreshold")
    def failure_threshold(self) -> Optional[int]:
        return pulumi.get(self, "failure_threshold")

    @property
    @pulumi.getter
    def grpc(self) -> Optional['outputs.WorkloadContainerReadinessProbeGrpc']:
        return pulumi.get(self, "grpc")

    @property
    @pulumi.getter(name="httpGet")
    def http_get(self) -> Optional['outputs.WorkloadContainerReadinessProbeHttpGet']:
        return pulumi.get(self, "http_get")

    @property
    @pulumi.getter(name="initialDelaySeconds")
    def initial_delay_seconds(self) -> Optional[int]:
        return pulumi.get(self, "initial_delay_seconds")

    @property
    @pulumi.getter(name="periodSeconds")
    def period_seconds(self) -> Optional[int]:
        return pulumi.get(self, "period_seconds")

    @property
    @pulumi.getter(name="successThreshold")
    def success_threshold(self) -> Optional[int]:
        return pulumi.get(self, "success_threshold")

    @property
    @pulumi.getter(name="tcpSocket")
    def tcp_socket(self) -> Optional['outputs.WorkloadContainerReadinessProbeTcpSocket']:
        return pulumi.get(self, "tcp_socket")

    @property
    @pulumi.getter(name="timeoutSeconds")
    def timeout_seconds(self) -> Optional[int]:
        return pulumi.get(self, "timeout_seconds")


@pulumi.output_type
class WorkloadContainerReadinessProbeExec(dict):
    def __init__(__self__, *,
                 commands: Sequence[str]):
        WorkloadContainerReadinessProbeExec._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            commands=commands,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             commands: Sequence[str],
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("commands", commands)

    @property
    @pulumi.getter
    def commands(self) -> Sequence[str]:
        return pulumi.get(self, "commands")


@pulumi.output_type
class WorkloadContainerReadinessProbeGrpc(dict):
    def __init__(__self__, *,
                 port: Optional[int] = None):
        WorkloadContainerReadinessProbeGrpc._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            port=port,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             port: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if port is not None:
            _setter("port", port)

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        return pulumi.get(self, "port")


@pulumi.output_type
class WorkloadContainerReadinessProbeHttpGet(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "httpHeaders":
            suggest = "http_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkloadContainerReadinessProbeHttpGet. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkloadContainerReadinessProbeHttpGet.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkloadContainerReadinessProbeHttpGet.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 http_headers: Optional[Mapping[str, str]] = None,
                 path: Optional[str] = None,
                 port: Optional[int] = None,
                 scheme: Optional[str] = None):
        WorkloadContainerReadinessProbeHttpGet._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            http_headers=http_headers,
            path=path,
            port=port,
            scheme=scheme,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             http_headers: Optional[Mapping[str, str]] = None,
             path: Optional[str] = None,
             port: Optional[int] = None,
             scheme: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'httpHeaders' in kwargs:
            http_headers = kwargs['httpHeaders']

        if http_headers is not None:
            _setter("http_headers", http_headers)
        if path is not None:
            _setter("path", path)
        if port is not None:
            _setter("port", port)
        if scheme is not None:
            _setter("scheme", scheme)

    @property
    @pulumi.getter(name="httpHeaders")
    def http_headers(self) -> Optional[Mapping[str, str]]:
        return pulumi.get(self, "http_headers")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def scheme(self) -> Optional[str]:
        return pulumi.get(self, "scheme")


@pulumi.output_type
class WorkloadContainerReadinessProbeTcpSocket(dict):
    def __init__(__self__, *,
                 port: Optional[int] = None):
        WorkloadContainerReadinessProbeTcpSocket._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            port=port,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             port: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if port is not None:
            _setter("port", port)

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        return pulumi.get(self, "port")


@pulumi.output_type
class WorkloadContainerVolume(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "recoveryPolicy":
            suggest = "recovery_policy"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkloadContainerVolume. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkloadContainerVolume.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkloadContainerVolume.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 path: str,
                 uri: str,
                 recovery_policy: Optional[str] = None):
        WorkloadContainerVolume._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            path=path,
            uri=uri,
            recovery_policy=recovery_policy,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             path: str,
             uri: str,
             recovery_policy: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'recoveryPolicy' in kwargs:
            recovery_policy = kwargs['recoveryPolicy']

        _setter("path", path)
        _setter("uri", uri)
        if recovery_policy is not None:
            _setter("recovery_policy", recovery_policy)

    @property
    @pulumi.getter
    def path(self) -> str:
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def uri(self) -> str:
        return pulumi.get(self, "uri")

    @property
    @pulumi.getter(name="recoveryPolicy")
    def recovery_policy(self) -> Optional[str]:
        return pulumi.get(self, "recovery_policy")


@pulumi.output_type
class WorkloadFirewallSpec(dict):
    def __init__(__self__, *,
                 external: Optional['outputs.WorkloadFirewallSpecExternal'] = None,
                 internal: Optional['outputs.WorkloadFirewallSpecInternal'] = None):
        WorkloadFirewallSpec._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            external=external,
            internal=internal,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             external: Optional['outputs.WorkloadFirewallSpecExternal'] = None,
             internal: Optional['outputs.WorkloadFirewallSpecInternal'] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if external is not None:
            _setter("external", external)
        if internal is not None:
            _setter("internal", internal)

    @property
    @pulumi.getter
    def external(self) -> Optional['outputs.WorkloadFirewallSpecExternal']:
        return pulumi.get(self, "external")

    @property
    @pulumi.getter
    def internal(self) -> Optional['outputs.WorkloadFirewallSpecInternal']:
        return pulumi.get(self, "internal")


@pulumi.output_type
class WorkloadFirewallSpecExternal(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "inboundAllowCidrs":
            suggest = "inbound_allow_cidrs"
        elif key == "outboundAllowCidrs":
            suggest = "outbound_allow_cidrs"
        elif key == "outboundAllowHostnames":
            suggest = "outbound_allow_hostnames"
        elif key == "outboundAllowPorts":
            suggest = "outbound_allow_ports"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkloadFirewallSpecExternal. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkloadFirewallSpecExternal.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkloadFirewallSpecExternal.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 inbound_allow_cidrs: Optional[Sequence[str]] = None,
                 outbound_allow_cidrs: Optional[Sequence[str]] = None,
                 outbound_allow_hostnames: Optional[Sequence[str]] = None,
                 outbound_allow_ports: Optional[Sequence['outputs.WorkloadFirewallSpecExternalOutboundAllowPort']] = None):
        WorkloadFirewallSpecExternal._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            inbound_allow_cidrs=inbound_allow_cidrs,
            outbound_allow_cidrs=outbound_allow_cidrs,
            outbound_allow_hostnames=outbound_allow_hostnames,
            outbound_allow_ports=outbound_allow_ports,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             inbound_allow_cidrs: Optional[Sequence[str]] = None,
             outbound_allow_cidrs: Optional[Sequence[str]] = None,
             outbound_allow_hostnames: Optional[Sequence[str]] = None,
             outbound_allow_ports: Optional[Sequence['outputs.WorkloadFirewallSpecExternalOutboundAllowPort']] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'inboundAllowCidrs' in kwargs:
            inbound_allow_cidrs = kwargs['inboundAllowCidrs']
        if 'outboundAllowCidrs' in kwargs:
            outbound_allow_cidrs = kwargs['outboundAllowCidrs']
        if 'outboundAllowHostnames' in kwargs:
            outbound_allow_hostnames = kwargs['outboundAllowHostnames']
        if 'outboundAllowPorts' in kwargs:
            outbound_allow_ports = kwargs['outboundAllowPorts']

        if inbound_allow_cidrs is not None:
            _setter("inbound_allow_cidrs", inbound_allow_cidrs)
        if outbound_allow_cidrs is not None:
            _setter("outbound_allow_cidrs", outbound_allow_cidrs)
        if outbound_allow_hostnames is not None:
            _setter("outbound_allow_hostnames", outbound_allow_hostnames)
        if outbound_allow_ports is not None:
            _setter("outbound_allow_ports", outbound_allow_ports)

    @property
    @pulumi.getter(name="inboundAllowCidrs")
    def inbound_allow_cidrs(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "inbound_allow_cidrs")

    @property
    @pulumi.getter(name="outboundAllowCidrs")
    def outbound_allow_cidrs(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "outbound_allow_cidrs")

    @property
    @pulumi.getter(name="outboundAllowHostnames")
    def outbound_allow_hostnames(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "outbound_allow_hostnames")

    @property
    @pulumi.getter(name="outboundAllowPorts")
    def outbound_allow_ports(self) -> Optional[Sequence['outputs.WorkloadFirewallSpecExternalOutboundAllowPort']]:
        return pulumi.get(self, "outbound_allow_ports")


@pulumi.output_type
class WorkloadFirewallSpecExternalOutboundAllowPort(dict):
    def __init__(__self__, *,
                 number: int,
                 protocol: str):
        WorkloadFirewallSpecExternalOutboundAllowPort._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            number=number,
            protocol=protocol,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             number: int,
             protocol: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("number", number)
        _setter("protocol", protocol)

    @property
    @pulumi.getter
    def number(self) -> int:
        return pulumi.get(self, "number")

    @property
    @pulumi.getter
    def protocol(self) -> str:
        return pulumi.get(self, "protocol")


@pulumi.output_type
class WorkloadFirewallSpecInternal(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "inboundAllowType":
            suggest = "inbound_allow_type"
        elif key == "inboundAllowWorkloads":
            suggest = "inbound_allow_workloads"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkloadFirewallSpecInternal. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkloadFirewallSpecInternal.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkloadFirewallSpecInternal.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 inbound_allow_type: Optional[str] = None,
                 inbound_allow_workloads: Optional[Sequence[str]] = None):
        WorkloadFirewallSpecInternal._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            inbound_allow_type=inbound_allow_type,
            inbound_allow_workloads=inbound_allow_workloads,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             inbound_allow_type: Optional[str] = None,
             inbound_allow_workloads: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'inboundAllowType' in kwargs:
            inbound_allow_type = kwargs['inboundAllowType']
        if 'inboundAllowWorkloads' in kwargs:
            inbound_allow_workloads = kwargs['inboundAllowWorkloads']

        if inbound_allow_type is not None:
            _setter("inbound_allow_type", inbound_allow_type)
        if inbound_allow_workloads is not None:
            _setter("inbound_allow_workloads", inbound_allow_workloads)

    @property
    @pulumi.getter(name="inboundAllowType")
    def inbound_allow_type(self) -> Optional[str]:
        return pulumi.get(self, "inbound_allow_type")

    @property
    @pulumi.getter(name="inboundAllowWorkloads")
    def inbound_allow_workloads(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "inbound_allow_workloads")


@pulumi.output_type
class WorkloadJob(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "activeDeadlineSeconds":
            suggest = "active_deadline_seconds"
        elif key == "concurrencyPolicy":
            suggest = "concurrency_policy"
        elif key == "historyLimit":
            suggest = "history_limit"
        elif key == "restartPolicy":
            suggest = "restart_policy"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkloadJob. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkloadJob.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkloadJob.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 schedule: str,
                 active_deadline_seconds: Optional[int] = None,
                 concurrency_policy: Optional[str] = None,
                 history_limit: Optional[int] = None,
                 restart_policy: Optional[str] = None):
        WorkloadJob._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            schedule=schedule,
            active_deadline_seconds=active_deadline_seconds,
            concurrency_policy=concurrency_policy,
            history_limit=history_limit,
            restart_policy=restart_policy,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             schedule: str,
             active_deadline_seconds: Optional[int] = None,
             concurrency_policy: Optional[str] = None,
             history_limit: Optional[int] = None,
             restart_policy: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'activeDeadlineSeconds' in kwargs:
            active_deadline_seconds = kwargs['activeDeadlineSeconds']
        if 'concurrencyPolicy' in kwargs:
            concurrency_policy = kwargs['concurrencyPolicy']
        if 'historyLimit' in kwargs:
            history_limit = kwargs['historyLimit']
        if 'restartPolicy' in kwargs:
            restart_policy = kwargs['restartPolicy']

        _setter("schedule", schedule)
        if active_deadline_seconds is not None:
            _setter("active_deadline_seconds", active_deadline_seconds)
        if concurrency_policy is not None:
            _setter("concurrency_policy", concurrency_policy)
        if history_limit is not None:
            _setter("history_limit", history_limit)
        if restart_policy is not None:
            _setter("restart_policy", restart_policy)

    @property
    @pulumi.getter
    def schedule(self) -> str:
        return pulumi.get(self, "schedule")

    @property
    @pulumi.getter(name="activeDeadlineSeconds")
    def active_deadline_seconds(self) -> Optional[int]:
        return pulumi.get(self, "active_deadline_seconds")

    @property
    @pulumi.getter(name="concurrencyPolicy")
    def concurrency_policy(self) -> Optional[str]:
        return pulumi.get(self, "concurrency_policy")

    @property
    @pulumi.getter(name="historyLimit")
    def history_limit(self) -> Optional[int]:
        return pulumi.get(self, "history_limit")

    @property
    @pulumi.getter(name="restartPolicy")
    def restart_policy(self) -> Optional[str]:
        return pulumi.get(self, "restart_policy")


@pulumi.output_type
class WorkloadLocalOption(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "capacityAi":
            suggest = "capacity_ai"
        elif key == "timeoutSeconds":
            suggest = "timeout_seconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkloadLocalOption. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkloadLocalOption.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkloadLocalOption.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 autoscaling: 'outputs.WorkloadLocalOptionAutoscaling',
                 location: str,
                 capacity_ai: Optional[bool] = None,
                 debug: Optional[bool] = None,
                 suspend: Optional[bool] = None,
                 timeout_seconds: Optional[int] = None):
        WorkloadLocalOption._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            autoscaling=autoscaling,
            location=location,
            capacity_ai=capacity_ai,
            debug=debug,
            suspend=suspend,
            timeout_seconds=timeout_seconds,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             autoscaling: 'outputs.WorkloadLocalOptionAutoscaling',
             location: str,
             capacity_ai: Optional[bool] = None,
             debug: Optional[bool] = None,
             suspend: Optional[bool] = None,
             timeout_seconds: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'capacityAi' in kwargs:
            capacity_ai = kwargs['capacityAi']
        if 'timeoutSeconds' in kwargs:
            timeout_seconds = kwargs['timeoutSeconds']

        _setter("autoscaling", autoscaling)
        _setter("location", location)
        if capacity_ai is not None:
            _setter("capacity_ai", capacity_ai)
        if debug is not None:
            _setter("debug", debug)
        if suspend is not None:
            _setter("suspend", suspend)
        if timeout_seconds is not None:
            _setter("timeout_seconds", timeout_seconds)

    @property
    @pulumi.getter
    def autoscaling(self) -> 'outputs.WorkloadLocalOptionAutoscaling':
        return pulumi.get(self, "autoscaling")

    @property
    @pulumi.getter
    def location(self) -> str:
        return pulumi.get(self, "location")

    @property
    @pulumi.getter(name="capacityAi")
    def capacity_ai(self) -> Optional[bool]:
        return pulumi.get(self, "capacity_ai")

    @property
    @pulumi.getter
    def debug(self) -> Optional[bool]:
        return pulumi.get(self, "debug")

    @property
    @pulumi.getter
    def suspend(self) -> Optional[bool]:
        return pulumi.get(self, "suspend")

    @property
    @pulumi.getter(name="timeoutSeconds")
    def timeout_seconds(self) -> Optional[int]:
        return pulumi.get(self, "timeout_seconds")


@pulumi.output_type
class WorkloadLocalOptionAutoscaling(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxConcurrency":
            suggest = "max_concurrency"
        elif key == "maxScale":
            suggest = "max_scale"
        elif key == "metricPercentile":
            suggest = "metric_percentile"
        elif key == "minScale":
            suggest = "min_scale"
        elif key == "scaleToZeroDelay":
            suggest = "scale_to_zero_delay"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkloadLocalOptionAutoscaling. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkloadLocalOptionAutoscaling.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkloadLocalOptionAutoscaling.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_concurrency: Optional[int] = None,
                 max_scale: Optional[int] = None,
                 metric: Optional[str] = None,
                 metric_percentile: Optional[str] = None,
                 min_scale: Optional[int] = None,
                 scale_to_zero_delay: Optional[int] = None,
                 target: Optional[int] = None):
        WorkloadLocalOptionAutoscaling._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            max_concurrency=max_concurrency,
            max_scale=max_scale,
            metric=metric,
            metric_percentile=metric_percentile,
            min_scale=min_scale,
            scale_to_zero_delay=scale_to_zero_delay,
            target=target,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             max_concurrency: Optional[int] = None,
             max_scale: Optional[int] = None,
             metric: Optional[str] = None,
             metric_percentile: Optional[str] = None,
             min_scale: Optional[int] = None,
             scale_to_zero_delay: Optional[int] = None,
             target: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'maxConcurrency' in kwargs:
            max_concurrency = kwargs['maxConcurrency']
        if 'maxScale' in kwargs:
            max_scale = kwargs['maxScale']
        if 'metricPercentile' in kwargs:
            metric_percentile = kwargs['metricPercentile']
        if 'minScale' in kwargs:
            min_scale = kwargs['minScale']
        if 'scaleToZeroDelay' in kwargs:
            scale_to_zero_delay = kwargs['scaleToZeroDelay']

        if max_concurrency is not None:
            _setter("max_concurrency", max_concurrency)
        if max_scale is not None:
            _setter("max_scale", max_scale)
        if metric is not None:
            _setter("metric", metric)
        if metric_percentile is not None:
            _setter("metric_percentile", metric_percentile)
        if min_scale is not None:
            _setter("min_scale", min_scale)
        if scale_to_zero_delay is not None:
            _setter("scale_to_zero_delay", scale_to_zero_delay)
        if target is not None:
            _setter("target", target)

    @property
    @pulumi.getter(name="maxConcurrency")
    def max_concurrency(self) -> Optional[int]:
        return pulumi.get(self, "max_concurrency")

    @property
    @pulumi.getter(name="maxScale")
    def max_scale(self) -> Optional[int]:
        return pulumi.get(self, "max_scale")

    @property
    @pulumi.getter
    def metric(self) -> Optional[str]:
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter(name="metricPercentile")
    def metric_percentile(self) -> Optional[str]:
        return pulumi.get(self, "metric_percentile")

    @property
    @pulumi.getter(name="minScale")
    def min_scale(self) -> Optional[int]:
        return pulumi.get(self, "min_scale")

    @property
    @pulumi.getter(name="scaleToZeroDelay")
    def scale_to_zero_delay(self) -> Optional[int]:
        return pulumi.get(self, "scale_to_zero_delay")

    @property
    @pulumi.getter
    def target(self) -> Optional[int]:
        return pulumi.get(self, "target")


@pulumi.output_type
class WorkloadOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "capacityAi":
            suggest = "capacity_ai"
        elif key == "timeoutSeconds":
            suggest = "timeout_seconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkloadOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkloadOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkloadOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 autoscaling: 'outputs.WorkloadOptionsAutoscaling',
                 capacity_ai: Optional[bool] = None,
                 debug: Optional[bool] = None,
                 suspend: Optional[bool] = None,
                 timeout_seconds: Optional[int] = None):
        WorkloadOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            autoscaling=autoscaling,
            capacity_ai=capacity_ai,
            debug=debug,
            suspend=suspend,
            timeout_seconds=timeout_seconds,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             autoscaling: 'outputs.WorkloadOptionsAutoscaling',
             capacity_ai: Optional[bool] = None,
             debug: Optional[bool] = None,
             suspend: Optional[bool] = None,
             timeout_seconds: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'capacityAi' in kwargs:
            capacity_ai = kwargs['capacityAi']
        if 'timeoutSeconds' in kwargs:
            timeout_seconds = kwargs['timeoutSeconds']

        _setter("autoscaling", autoscaling)
        if capacity_ai is not None:
            _setter("capacity_ai", capacity_ai)
        if debug is not None:
            _setter("debug", debug)
        if suspend is not None:
            _setter("suspend", suspend)
        if timeout_seconds is not None:
            _setter("timeout_seconds", timeout_seconds)

    @property
    @pulumi.getter
    def autoscaling(self) -> 'outputs.WorkloadOptionsAutoscaling':
        return pulumi.get(self, "autoscaling")

    @property
    @pulumi.getter(name="capacityAi")
    def capacity_ai(self) -> Optional[bool]:
        return pulumi.get(self, "capacity_ai")

    @property
    @pulumi.getter
    def debug(self) -> Optional[bool]:
        return pulumi.get(self, "debug")

    @property
    @pulumi.getter
    def suspend(self) -> Optional[bool]:
        return pulumi.get(self, "suspend")

    @property
    @pulumi.getter(name="timeoutSeconds")
    def timeout_seconds(self) -> Optional[int]:
        return pulumi.get(self, "timeout_seconds")


@pulumi.output_type
class WorkloadOptionsAutoscaling(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxConcurrency":
            suggest = "max_concurrency"
        elif key == "maxScale":
            suggest = "max_scale"
        elif key == "metricPercentile":
            suggest = "metric_percentile"
        elif key == "minScale":
            suggest = "min_scale"
        elif key == "scaleToZeroDelay":
            suggest = "scale_to_zero_delay"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkloadOptionsAutoscaling. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkloadOptionsAutoscaling.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkloadOptionsAutoscaling.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_concurrency: Optional[int] = None,
                 max_scale: Optional[int] = None,
                 metric: Optional[str] = None,
                 metric_percentile: Optional[str] = None,
                 min_scale: Optional[int] = None,
                 scale_to_zero_delay: Optional[int] = None,
                 target: Optional[int] = None):
        WorkloadOptionsAutoscaling._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            max_concurrency=max_concurrency,
            max_scale=max_scale,
            metric=metric,
            metric_percentile=metric_percentile,
            min_scale=min_scale,
            scale_to_zero_delay=scale_to_zero_delay,
            target=target,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             max_concurrency: Optional[int] = None,
             max_scale: Optional[int] = None,
             metric: Optional[str] = None,
             metric_percentile: Optional[str] = None,
             min_scale: Optional[int] = None,
             scale_to_zero_delay: Optional[int] = None,
             target: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'maxConcurrency' in kwargs:
            max_concurrency = kwargs['maxConcurrency']
        if 'maxScale' in kwargs:
            max_scale = kwargs['maxScale']
        if 'metricPercentile' in kwargs:
            metric_percentile = kwargs['metricPercentile']
        if 'minScale' in kwargs:
            min_scale = kwargs['minScale']
        if 'scaleToZeroDelay' in kwargs:
            scale_to_zero_delay = kwargs['scaleToZeroDelay']

        if max_concurrency is not None:
            _setter("max_concurrency", max_concurrency)
        if max_scale is not None:
            _setter("max_scale", max_scale)
        if metric is not None:
            _setter("metric", metric)
        if metric_percentile is not None:
            _setter("metric_percentile", metric_percentile)
        if min_scale is not None:
            _setter("min_scale", min_scale)
        if scale_to_zero_delay is not None:
            _setter("scale_to_zero_delay", scale_to_zero_delay)
        if target is not None:
            _setter("target", target)

    @property
    @pulumi.getter(name="maxConcurrency")
    def max_concurrency(self) -> Optional[int]:
        return pulumi.get(self, "max_concurrency")

    @property
    @pulumi.getter(name="maxScale")
    def max_scale(self) -> Optional[int]:
        return pulumi.get(self, "max_scale")

    @property
    @pulumi.getter
    def metric(self) -> Optional[str]:
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter(name="metricPercentile")
    def metric_percentile(self) -> Optional[str]:
        return pulumi.get(self, "metric_percentile")

    @property
    @pulumi.getter(name="minScale")
    def min_scale(self) -> Optional[int]:
        return pulumi.get(self, "min_scale")

    @property
    @pulumi.getter(name="scaleToZeroDelay")
    def scale_to_zero_delay(self) -> Optional[int]:
        return pulumi.get(self, "scale_to_zero_delay")

    @property
    @pulumi.getter
    def target(self) -> Optional[int]:
        return pulumi.get(self, "target")


@pulumi.output_type
class WorkloadRolloutOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxSurgeReplicas":
            suggest = "max_surge_replicas"
        elif key == "maxUnavailableReplicas":
            suggest = "max_unavailable_replicas"
        elif key == "minReadySeconds":
            suggest = "min_ready_seconds"
        elif key == "scalingPolicy":
            suggest = "scaling_policy"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkloadRolloutOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkloadRolloutOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkloadRolloutOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_surge_replicas: Optional[str] = None,
                 max_unavailable_replicas: Optional[str] = None,
                 min_ready_seconds: Optional[int] = None,
                 scaling_policy: Optional[str] = None):
        WorkloadRolloutOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            max_surge_replicas=max_surge_replicas,
            max_unavailable_replicas=max_unavailable_replicas,
            min_ready_seconds=min_ready_seconds,
            scaling_policy=scaling_policy,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             max_surge_replicas: Optional[str] = None,
             max_unavailable_replicas: Optional[str] = None,
             min_ready_seconds: Optional[int] = None,
             scaling_policy: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'maxSurgeReplicas' in kwargs:
            max_surge_replicas = kwargs['maxSurgeReplicas']
        if 'maxUnavailableReplicas' in kwargs:
            max_unavailable_replicas = kwargs['maxUnavailableReplicas']
        if 'minReadySeconds' in kwargs:
            min_ready_seconds = kwargs['minReadySeconds']
        if 'scalingPolicy' in kwargs:
            scaling_policy = kwargs['scalingPolicy']

        if max_surge_replicas is not None:
            _setter("max_surge_replicas", max_surge_replicas)
        if max_unavailable_replicas is not None:
            _setter("max_unavailable_replicas", max_unavailable_replicas)
        if min_ready_seconds is not None:
            _setter("min_ready_seconds", min_ready_seconds)
        if scaling_policy is not None:
            _setter("scaling_policy", scaling_policy)

    @property
    @pulumi.getter(name="maxSurgeReplicas")
    def max_surge_replicas(self) -> Optional[str]:
        return pulumi.get(self, "max_surge_replicas")

    @property
    @pulumi.getter(name="maxUnavailableReplicas")
    def max_unavailable_replicas(self) -> Optional[str]:
        return pulumi.get(self, "max_unavailable_replicas")

    @property
    @pulumi.getter(name="minReadySeconds")
    def min_ready_seconds(self) -> Optional[int]:
        return pulumi.get(self, "min_ready_seconds")

    @property
    @pulumi.getter(name="scalingPolicy")
    def scaling_policy(self) -> Optional[str]:
        return pulumi.get(self, "scaling_policy")


@pulumi.output_type
class WorkloadSecurityOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fileSystemGroupId":
            suggest = "file_system_group_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkloadSecurityOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkloadSecurityOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkloadSecurityOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 file_system_group_id: int):
        WorkloadSecurityOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            file_system_group_id=file_system_group_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             file_system_group_id: int,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'fileSystemGroupId' in kwargs:
            file_system_group_id = kwargs['fileSystemGroupId']

        _setter("file_system_group_id", file_system_group_id)

    @property
    @pulumi.getter(name="fileSystemGroupId")
    def file_system_group_id(self) -> int:
        return pulumi.get(self, "file_system_group_id")


@pulumi.output_type
class WorkloadSidecar(dict):
    def __init__(__self__, *,
                 envoy: str):
        WorkloadSidecar._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            envoy=envoy,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             envoy: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("envoy", envoy)

    @property
    @pulumi.getter
    def envoy(self) -> str:
        return pulumi.get(self, "envoy")


@pulumi.output_type
class WorkloadStatus(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "canonicalEndpoint":
            suggest = "canonical_endpoint"
        elif key == "currentReplicaCount":
            suggest = "current_replica_count"
        elif key == "healthChecks":
            suggest = "health_checks"
        elif key == "internalName":
            suggest = "internal_name"
        elif key == "parentId":
            suggest = "parent_id"
        elif key == "resolvedImages":
            suggest = "resolved_images"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkloadStatus. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkloadStatus.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkloadStatus.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 canonical_endpoint: Optional[str] = None,
                 current_replica_count: Optional[int] = None,
                 endpoint: Optional[str] = None,
                 health_checks: Optional[Sequence['outputs.WorkloadStatusHealthCheck']] = None,
                 internal_name: Optional[str] = None,
                 parent_id: Optional[str] = None,
                 resolved_images: Optional[Sequence['outputs.WorkloadStatusResolvedImage']] = None):
        WorkloadStatus._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            canonical_endpoint=canonical_endpoint,
            current_replica_count=current_replica_count,
            endpoint=endpoint,
            health_checks=health_checks,
            internal_name=internal_name,
            parent_id=parent_id,
            resolved_images=resolved_images,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             canonical_endpoint: Optional[str] = None,
             current_replica_count: Optional[int] = None,
             endpoint: Optional[str] = None,
             health_checks: Optional[Sequence['outputs.WorkloadStatusHealthCheck']] = None,
             internal_name: Optional[str] = None,
             parent_id: Optional[str] = None,
             resolved_images: Optional[Sequence['outputs.WorkloadStatusResolvedImage']] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'canonicalEndpoint' in kwargs:
            canonical_endpoint = kwargs['canonicalEndpoint']
        if 'currentReplicaCount' in kwargs:
            current_replica_count = kwargs['currentReplicaCount']
        if 'healthChecks' in kwargs:
            health_checks = kwargs['healthChecks']
        if 'internalName' in kwargs:
            internal_name = kwargs['internalName']
        if 'parentId' in kwargs:
            parent_id = kwargs['parentId']
        if 'resolvedImages' in kwargs:
            resolved_images = kwargs['resolvedImages']

        if canonical_endpoint is not None:
            _setter("canonical_endpoint", canonical_endpoint)
        if current_replica_count is not None:
            _setter("current_replica_count", current_replica_count)
        if endpoint is not None:
            _setter("endpoint", endpoint)
        if health_checks is not None:
            _setter("health_checks", health_checks)
        if internal_name is not None:
            _setter("internal_name", internal_name)
        if parent_id is not None:
            _setter("parent_id", parent_id)
        if resolved_images is not None:
            _setter("resolved_images", resolved_images)

    @property
    @pulumi.getter(name="canonicalEndpoint")
    def canonical_endpoint(self) -> Optional[str]:
        return pulumi.get(self, "canonical_endpoint")

    @property
    @pulumi.getter(name="currentReplicaCount")
    def current_replica_count(self) -> Optional[int]:
        return pulumi.get(self, "current_replica_count")

    @property
    @pulumi.getter
    def endpoint(self) -> Optional[str]:
        return pulumi.get(self, "endpoint")

    @property
    @pulumi.getter(name="healthChecks")
    def health_checks(self) -> Optional[Sequence['outputs.WorkloadStatusHealthCheck']]:
        return pulumi.get(self, "health_checks")

    @property
    @pulumi.getter(name="internalName")
    def internal_name(self) -> Optional[str]:
        return pulumi.get(self, "internal_name")

    @property
    @pulumi.getter(name="parentId")
    def parent_id(self) -> Optional[str]:
        return pulumi.get(self, "parent_id")

    @property
    @pulumi.getter(name="resolvedImages")
    def resolved_images(self) -> Optional[Sequence['outputs.WorkloadStatusResolvedImage']]:
        return pulumi.get(self, "resolved_images")


@pulumi.output_type
class WorkloadStatusHealthCheck(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "lastChecked":
            suggest = "last_checked"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkloadStatusHealthCheck. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkloadStatusHealthCheck.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkloadStatusHealthCheck.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 active: bool,
                 code: Optional[int] = None,
                 failures: Optional[int] = None,
                 last_checked: Optional[str] = None,
                 message: Optional[str] = None,
                 success: Optional[bool] = None,
                 successes: Optional[int] = None):
        WorkloadStatusHealthCheck._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            active=active,
            code=code,
            failures=failures,
            last_checked=last_checked,
            message=message,
            success=success,
            successes=successes,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             active: bool,
             code: Optional[int] = None,
             failures: Optional[int] = None,
             last_checked: Optional[str] = None,
             message: Optional[str] = None,
             success: Optional[bool] = None,
             successes: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'lastChecked' in kwargs:
            last_checked = kwargs['lastChecked']

        _setter("active", active)
        if code is not None:
            _setter("code", code)
        if failures is not None:
            _setter("failures", failures)
        if last_checked is not None:
            _setter("last_checked", last_checked)
        if message is not None:
            _setter("message", message)
        if success is not None:
            _setter("success", success)
        if successes is not None:
            _setter("successes", successes)

    @property
    @pulumi.getter
    def active(self) -> bool:
        return pulumi.get(self, "active")

    @property
    @pulumi.getter
    def code(self) -> Optional[int]:
        return pulumi.get(self, "code")

    @property
    @pulumi.getter
    def failures(self) -> Optional[int]:
        return pulumi.get(self, "failures")

    @property
    @pulumi.getter(name="lastChecked")
    def last_checked(self) -> Optional[str]:
        return pulumi.get(self, "last_checked")

    @property
    @pulumi.getter
    def message(self) -> Optional[str]:
        return pulumi.get(self, "message")

    @property
    @pulumi.getter
    def success(self) -> Optional[bool]:
        return pulumi.get(self, "success")

    @property
    @pulumi.getter
    def successes(self) -> Optional[int]:
        return pulumi.get(self, "successes")


@pulumi.output_type
class WorkloadStatusResolvedImage(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "resolvedAt":
            suggest = "resolved_at"
        elif key == "resolvedForVersion":
            suggest = "resolved_for_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkloadStatusResolvedImage. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkloadStatusResolvedImage.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkloadStatusResolvedImage.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 images: Optional[Sequence['outputs.WorkloadStatusResolvedImageImage']] = None,
                 resolved_at: Optional[str] = None,
                 resolved_for_version: Optional[int] = None):
        WorkloadStatusResolvedImage._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            images=images,
            resolved_at=resolved_at,
            resolved_for_version=resolved_for_version,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             images: Optional[Sequence['outputs.WorkloadStatusResolvedImageImage']] = None,
             resolved_at: Optional[str] = None,
             resolved_for_version: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'resolvedAt' in kwargs:
            resolved_at = kwargs['resolvedAt']
        if 'resolvedForVersion' in kwargs:
            resolved_for_version = kwargs['resolvedForVersion']

        if images is not None:
            _setter("images", images)
        if resolved_at is not None:
            _setter("resolved_at", resolved_at)
        if resolved_for_version is not None:
            _setter("resolved_for_version", resolved_for_version)

    @property
    @pulumi.getter
    def images(self) -> Optional[Sequence['outputs.WorkloadStatusResolvedImageImage']]:
        return pulumi.get(self, "images")

    @property
    @pulumi.getter(name="resolvedAt")
    def resolved_at(self) -> Optional[str]:
        return pulumi.get(self, "resolved_at")

    @property
    @pulumi.getter(name="resolvedForVersion")
    def resolved_for_version(self) -> Optional[int]:
        return pulumi.get(self, "resolved_for_version")


@pulumi.output_type
class WorkloadStatusResolvedImageImage(dict):
    def __init__(__self__, *,
                 digest: Optional[str] = None,
                 manifests: Optional[Sequence['outputs.WorkloadStatusResolvedImageImageManifest']] = None):
        WorkloadStatusResolvedImageImage._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            digest=digest,
            manifests=manifests,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             digest: Optional[str] = None,
             manifests: Optional[Sequence['outputs.WorkloadStatusResolvedImageImageManifest']] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if digest is not None:
            _setter("digest", digest)
        if manifests is not None:
            _setter("manifests", manifests)

    @property
    @pulumi.getter
    def digest(self) -> Optional[str]:
        return pulumi.get(self, "digest")

    @property
    @pulumi.getter
    def manifests(self) -> Optional[Sequence['outputs.WorkloadStatusResolvedImageImageManifest']]:
        return pulumi.get(self, "manifests")


@pulumi.output_type
class WorkloadStatusResolvedImageImageManifest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "mediaType":
            suggest = "media_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkloadStatusResolvedImageImageManifest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkloadStatusResolvedImageImageManifest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkloadStatusResolvedImageImageManifest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 digest: Optional[str] = None,
                 image: Optional[str] = None,
                 media_type: Optional[str] = None,
                 platform: Optional[Mapping[str, str]] = None):
        WorkloadStatusResolvedImageImageManifest._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            digest=digest,
            image=image,
            media_type=media_type,
            platform=platform,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             digest: Optional[str] = None,
             image: Optional[str] = None,
             media_type: Optional[str] = None,
             platform: Optional[Mapping[str, str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'mediaType' in kwargs:
            media_type = kwargs['mediaType']

        if digest is not None:
            _setter("digest", digest)
        if image is not None:
            _setter("image", image)
        if media_type is not None:
            _setter("media_type", media_type)
        if platform is not None:
            _setter("platform", platform)

    @property
    @pulumi.getter
    def digest(self) -> Optional[str]:
        return pulumi.get(self, "digest")

    @property
    @pulumi.getter
    def image(self) -> Optional[str]:
        return pulumi.get(self, "image")

    @property
    @pulumi.getter(name="mediaType")
    def media_type(self) -> Optional[str]:
        return pulumi.get(self, "media_type")

    @property
    @pulumi.getter
    def platform(self) -> Optional[Mapping[str, str]]:
        return pulumi.get(self, "platform")


@pulumi.output_type
class GetGvcControlplaneTracingResult(dict):
    def __init__(__self__, *,
                 sampling: int,
                 custom_tags: Optional[Mapping[str, str]] = None):
        GetGvcControlplaneTracingResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            sampling=sampling,
            custom_tags=custom_tags,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             sampling: int,
             custom_tags: Optional[Mapping[str, str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'customTags' in kwargs:
            custom_tags = kwargs['customTags']

        _setter("sampling", sampling)
        if custom_tags is not None:
            _setter("custom_tags", custom_tags)

    @property
    @pulumi.getter
    def sampling(self) -> int:
        return pulumi.get(self, "sampling")

    @property
    @pulumi.getter(name="customTags")
    def custom_tags(self) -> Optional[Mapping[str, str]]:
        return pulumi.get(self, "custom_tags")


@pulumi.output_type
class GetGvcLightstepTracingResult(dict):
    def __init__(__self__, *,
                 endpoint: str,
                 sampling: int,
                 credentials: Optional[str] = None,
                 custom_tags: Optional[Mapping[str, str]] = None):
        GetGvcLightstepTracingResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            endpoint=endpoint,
            sampling=sampling,
            credentials=credentials,
            custom_tags=custom_tags,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             endpoint: str,
             sampling: int,
             credentials: Optional[str] = None,
             custom_tags: Optional[Mapping[str, str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'customTags' in kwargs:
            custom_tags = kwargs['customTags']

        _setter("endpoint", endpoint)
        _setter("sampling", sampling)
        if credentials is not None:
            _setter("credentials", credentials)
        if custom_tags is not None:
            _setter("custom_tags", custom_tags)

    @property
    @pulumi.getter
    def endpoint(self) -> str:
        return pulumi.get(self, "endpoint")

    @property
    @pulumi.getter
    def sampling(self) -> int:
        return pulumi.get(self, "sampling")

    @property
    @pulumi.getter
    def credentials(self) -> Optional[str]:
        return pulumi.get(self, "credentials")

    @property
    @pulumi.getter(name="customTags")
    def custom_tags(self) -> Optional[Mapping[str, str]]:
        return pulumi.get(self, "custom_tags")


@pulumi.output_type
class GetGvcLoadBalancerResult(dict):
    def __init__(__self__, *,
                 dedicated: bool,
                 trusted_proxies: Optional[int] = None):
        GetGvcLoadBalancerResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            dedicated=dedicated,
            trusted_proxies=trusted_proxies,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             dedicated: bool,
             trusted_proxies: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'trustedProxies' in kwargs:
            trusted_proxies = kwargs['trustedProxies']

        _setter("dedicated", dedicated)
        if trusted_proxies is not None:
            _setter("trusted_proxies", trusted_proxies)

    @property
    @pulumi.getter
    def dedicated(self) -> bool:
        return pulumi.get(self, "dedicated")

    @property
    @pulumi.getter(name="trustedProxies")
    def trusted_proxies(self) -> Optional[int]:
        return pulumi.get(self, "trusted_proxies")


@pulumi.output_type
class GetGvcOtelTracingResult(dict):
    def __init__(__self__, *,
                 endpoint: str,
                 sampling: int,
                 custom_tags: Optional[Mapping[str, str]] = None):
        GetGvcOtelTracingResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            endpoint=endpoint,
            sampling=sampling,
            custom_tags=custom_tags,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             endpoint: str,
             sampling: int,
             custom_tags: Optional[Mapping[str, str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'customTags' in kwargs:
            custom_tags = kwargs['customTags']

        _setter("endpoint", endpoint)
        _setter("sampling", sampling)
        if custom_tags is not None:
            _setter("custom_tags", custom_tags)

    @property
    @pulumi.getter
    def endpoint(self) -> str:
        return pulumi.get(self, "endpoint")

    @property
    @pulumi.getter
    def sampling(self) -> int:
        return pulumi.get(self, "sampling")

    @property
    @pulumi.getter(name="customTags")
    def custom_tags(self) -> Optional[Mapping[str, str]]:
        return pulumi.get(self, "custom_tags")


@pulumi.output_type
class GetGvcSidecarResult(dict):
    def __init__(__self__, *,
                 envoy: str):
        GetGvcSidecarResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            envoy=envoy,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             envoy: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("envoy", envoy)

    @property
    @pulumi.getter
    def envoy(self) -> str:
        return pulumi.get(self, "envoy")


@pulumi.output_type
class GetLocationGeoResult(dict):
    def __init__(__self__, *,
                 city: Optional[str] = None,
                 continent: Optional[str] = None,
                 country: Optional[str] = None,
                 lat: Optional[float] = None,
                 lon: Optional[float] = None,
                 state: Optional[str] = None):
        GetLocationGeoResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            city=city,
            continent=continent,
            country=country,
            lat=lat,
            lon=lon,
            state=state,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             city: Optional[str] = None,
             continent: Optional[str] = None,
             country: Optional[str] = None,
             lat: Optional[float] = None,
             lon: Optional[float] = None,
             state: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if city is not None:
            _setter("city", city)
        if continent is not None:
            _setter("continent", continent)
        if country is not None:
            _setter("country", country)
        if lat is not None:
            _setter("lat", lat)
        if lon is not None:
            _setter("lon", lon)
        if state is not None:
            _setter("state", state)

    @property
    @pulumi.getter
    def city(self) -> Optional[str]:
        return pulumi.get(self, "city")

    @property
    @pulumi.getter
    def continent(self) -> Optional[str]:
        return pulumi.get(self, "continent")

    @property
    @pulumi.getter
    def country(self) -> Optional[str]:
        return pulumi.get(self, "country")

    @property
    @pulumi.getter
    def lat(self) -> Optional[float]:
        return pulumi.get(self, "lat")

    @property
    @pulumi.getter
    def lon(self) -> Optional[float]:
        return pulumi.get(self, "lon")

    @property
    @pulumi.getter
    def state(self) -> Optional[str]:
        return pulumi.get(self, "state")


@pulumi.output_type
class GetLocationsLocationResult(dict):
    def __init__(__self__, *,
                 cloud_provider: str,
                 cpln_id: str,
                 description: str,
                 enabled: bool,
                 geos: Sequence['outputs.GetLocationsLocationGeoResult'],
                 ip_ranges: Sequence[str],
                 name: str,
                 region: str,
                 self_link: str,
                 tags: Mapping[str, str]):
        GetLocationsLocationResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cloud_provider=cloud_provider,
            cpln_id=cpln_id,
            description=description,
            enabled=enabled,
            geos=geos,
            ip_ranges=ip_ranges,
            name=name,
            region=region,
            self_link=self_link,
            tags=tags,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cloud_provider: str,
             cpln_id: str,
             description: str,
             enabled: bool,
             geos: Sequence['outputs.GetLocationsLocationGeoResult'],
             ip_ranges: Sequence[str],
             name: str,
             region: str,
             self_link: str,
             tags: Mapping[str, str],
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'cloudProvider' in kwargs:
            cloud_provider = kwargs['cloudProvider']
        if 'cplnId' in kwargs:
            cpln_id = kwargs['cplnId']
        if 'ipRanges' in kwargs:
            ip_ranges = kwargs['ipRanges']
        if 'selfLink' in kwargs:
            self_link = kwargs['selfLink']

        _setter("cloud_provider", cloud_provider)
        _setter("cpln_id", cpln_id)
        _setter("description", description)
        _setter("enabled", enabled)
        _setter("geos", geos)
        _setter("ip_ranges", ip_ranges)
        _setter("name", name)
        _setter("region", region)
        _setter("self_link", self_link)
        _setter("tags", tags)

    @property
    @pulumi.getter(name="cloudProvider")
    def cloud_provider(self) -> str:
        return pulumi.get(self, "cloud_provider")

    @property
    @pulumi.getter(name="cplnId")
    def cpln_id(self) -> str:
        return pulumi.get(self, "cpln_id")

    @property
    @pulumi.getter
    def description(self) -> str:
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def geos(self) -> Sequence['outputs.GetLocationsLocationGeoResult']:
        return pulumi.get(self, "geos")

    @property
    @pulumi.getter(name="ipRanges")
    def ip_ranges(self) -> Sequence[str]:
        return pulumi.get(self, "ip_ranges")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def region(self) -> str:
        return pulumi.get(self, "region")

    @property
    @pulumi.getter(name="selfLink")
    def self_link(self) -> str:
        return pulumi.get(self, "self_link")

    @property
    @pulumi.getter
    def tags(self) -> Mapping[str, str]:
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetLocationsLocationGeoResult(dict):
    def __init__(__self__, *,
                 city: Optional[str] = None,
                 continent: Optional[str] = None,
                 country: Optional[str] = None,
                 lat: Optional[float] = None,
                 lon: Optional[float] = None,
                 state: Optional[str] = None):
        GetLocationsLocationGeoResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            city=city,
            continent=continent,
            country=country,
            lat=lat,
            lon=lon,
            state=state,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             city: Optional[str] = None,
             continent: Optional[str] = None,
             country: Optional[str] = None,
             lat: Optional[float] = None,
             lon: Optional[float] = None,
             state: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if city is not None:
            _setter("city", city)
        if continent is not None:
            _setter("continent", continent)
        if country is not None:
            _setter("country", country)
        if lat is not None:
            _setter("lat", lat)
        if lon is not None:
            _setter("lon", lon)
        if state is not None:
            _setter("state", state)

    @property
    @pulumi.getter
    def city(self) -> Optional[str]:
        return pulumi.get(self, "city")

    @property
    @pulumi.getter
    def continent(self) -> Optional[str]:
        return pulumi.get(self, "continent")

    @property
    @pulumi.getter
    def country(self) -> Optional[str]:
        return pulumi.get(self, "country")

    @property
    @pulumi.getter
    def lat(self) -> Optional[float]:
        return pulumi.get(self, "lat")

    @property
    @pulumi.getter
    def lon(self) -> Optional[float]:
        return pulumi.get(self, "lon")

    @property
    @pulumi.getter
    def state(self) -> Optional[str]:
        return pulumi.get(self, "state")


