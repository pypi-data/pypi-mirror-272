from typing import TypeVar, Generic, Mapping, Union, Literal, TypeAlias
import os
from prettyprinter import pformat
from dslog import Logger
import fs
from . import codegen

A = TypeVar('A')
B = TypeVar('B')
S = TypeVar('S')
Id = TypeVar('Id', bound=str)
OutId: TypeAlias = Id | Literal['output']

class Task(Generic[A, Id]):
  def __init__(self, Input: type[A], *outputs: OutId[Id]):
    self.Input = Input
    self.outputs = outputs

  def __repr__(self) -> str:
    return f'Task({self.Input.__name__} -> {" | ".join(self.outputs)})'
  
class Tasks(Generic[A, B, Id]):
  def __init__(
    self, input_task: Id, Output: type[B],
    tasks: Mapping[Id, Task[A, OutId[Id]]],
  ):
    outkeys = set(x for out in tasks.values() for x in out.outputs) - { 'output' } # type: ignore
    task_keys = set(tasks.keys())
    assert outkeys <= task_keys, f'Invalid output keys: {outkeys - task_keys}'
    if outkeys | { input_task } != task_keys:
      import warnings
      warnings.warn(f'Detected unnreachable tasks: {task_keys - outkeys}')

    self.input_task = input_task
    self.Input: type[A] = tasks[input_task].Input
    self.Output = Output
    self.tasks = tasks

  def __repr__(self):
    return f'Tasks({pformat(self.__dict__, indent=2)})' # type: ignore
  
  def InType(self, id: OutId[Id]) -> type[A|B]:
    return self.Output if id == 'output' else self.tasks[id].Input
  
  def OutType(self, id: Id) -> type[tuple[Id, A]]:
    return Union[*(tuple[Literal[id], self.InType(id)] for id in self.tasks[id].outputs)] # type: ignore
  
  def codegen_pipelines(
    self, __file__: str,
    base: str = 'pipelines', gen_base: str = 'generated',
    *, logger = Logger.rich().prefix('[CODEGEN PIPELINES]')
  ):
    sources = codegen.pipelines(self, f'..{gen_base}')
    folder = os.path.dirname(__file__)
    base = os.path.join(folder, base)
    os.makedirs(base, exist_ok=True)

    for task, source in sources.items():
      path = os.path.join(base, f'_{task}.py')
      r = fs.write(path, source, replace=False)
      if r.tag == 'left':
        logger(f'Skipping {task}: {r.value}', level='WARNING')
      else:
        logger(f'Generated {task} pipelines', level='DEBUG')

    path = os.path.join(base, '__init__.py')
    source = codegen.pipelines_init(list(self.tasks.keys()), f'..{gen_base}')
    r = fs.write(path, source, replace=False)
    if r.tag == 'left':
      logger(f'Skipping __init__.py: {r.value}', level='WARNING')
    else:
      logger(f'Generated __init__.py', level='DEBUG')

  def codegen(
    self, __file__: str, variable: str, base: str = 'generated',
    *, logger = Logger.rich().prefix('[CODEGEN]')
  ):
    folder, file = os.path.split(__file__)
    module, py = os.path.splitext(file)
    base = os.path.join(folder, base)
    os.makedirs(base, exist_ok=True)

    rel_module = f'..{module}'
    head = heading(self, __file__) + '\n'

    path = os.path.join(base, 'types.py')
    r = fs.write(path, head + codegen.types(self, rel_module))
    if r.tag == 'left':
      logger(f'Error writing types.py: {r.value}', level='ERROR')
    else:
      logger(f'Generated types.py', level='DEBUG')


    path = os.path.join(base, 'local.py')
    r = fs.write(path, head + codegen.local(self, rel_module, '.types', variable))
    if r.tag == 'left':
      logger(f'Error writing local.py: {r.value}', level='ERROR')
    else:
      logger(f'Generated local.py', level='DEBUG')

    INIT = 'from .types import *\nfrom .local import *\n'
    fs.write(os.path.join(base, '__init__.py'), head + INIT)

def heading(tasks: Tasks, file):
  import os
  from datetime import datetime
  return '\n'.join([
    '"""',
    'Code generated by `q.pipelines`',
    f'- Timestamp: {datetime.now()}',
    f'- Input file: "{os.path.relpath(file)}"',
    f'- Input spec: {tasks}',
    '"""',
  ])