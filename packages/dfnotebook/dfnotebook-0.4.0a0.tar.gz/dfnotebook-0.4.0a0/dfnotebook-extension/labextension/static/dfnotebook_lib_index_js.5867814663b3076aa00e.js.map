{"version":3,"file":"dfnotebook_lib_index_js.5867814663b3076aa00e.js","mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACiF;AACxB;AACG;AACd;AACH;AACQ;AACI;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gGAAgG;AAChG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4FAA4F;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,qCAAqC;AACrD;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,8BAA8B;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,6BAA6B;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0DAA0D;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,qDAAM,GAAG;AACpC;AACA;AACA;AACA,qCAAqC,qDAAM,GAAG;AAC9C;AACA;AACA;AACA,oCAAoC,qDAAM,GAAG;AAC7C;AACA;AACA;AACA;AACA,YAAY,gEAAU;AACtB;;AAEA;AACA,0BAA0B,iEAAe,GAAG,uBAAuB;AACnE,aAAa;AACb;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,mBAAmB;AACnC;AACA;AACA;AACA;AACA,YAAY,+EAAiC;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,mEAAc;AACjD;AACA;AACA;AACA;AACA;AACA,wCAAwC,+BAA+B;AACvE;AACA;AACA;AACA;AACA,6BAA6B,gEAAU;AACvC;AACA;AACA,sCAAsC,iEAAe,GAAG,uBAAuB;AAC/E,yBAAyB;AACzB;AACA;AACA;AACA,6BAA6B,gEAAU;AACvC;AACA;AACA,sCAAsC,iEAAe,GAAG,uBAAuB;AAC/E,yBAAyB;AACzB;AACA;AACA;AACA,6BAA6B,oFAAkC;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,uDAAI;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,mCAAmC;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C,+CAA+C,0CAA0C;AACzF;AACA,sDAAsD,gBAAgB;AACtE,2BAA2B,yEAAwB;AACnD;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,6DAAW;AACjD;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,gDAAgD,+CAA+C;AAC/F;AACA,qBAAqB;AACrB;AACA;AACA,oDAAoD,+BAA+B;AACnF;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uEAAuE;AACvE;AACA,sBAAsB,oEAAqB,CAAC,0DAAO;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,CAAC,0BAA0B;AAC3B;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACviBA;AACA;AACA;AACA;AACA;AACA;AAC0B;AACF;AACO;AACP;AACC;AACA;AACO;AAChC;;;;;;;;;;;;;;;;;;;;ACbA;AACA;AACqD;AACZ;AACoE;AACtG,oCAAoC,+DAAa;AACxD,4BAA4B;AAC5B,8BAA8B,6DAA6D;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,qFAAmC;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,8EAA4B;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,yDAAU;AAC3C;AACA;AACA;AACA,uBAAuB,sEAAqB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,yDAAU;AAC3C;AACA;AACA;AACA,uBAAuB,0EAAyB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,yDAAU;AAC3C;AACA;AACA;AACA,uBAAuB,qEAAoB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,uEAAuE;AACvE,CAAC,sDAAsD;AACvD;;;;;;;;;;;;;;;;;ACjHA;AACA;AACgD;AACY;AAC5D;AACA;AACA;AACO,2CAA2C,sEAAoB;AACtE;AACA;AACA;AACA;AACA,8BAA8B,oBAAoB,wEAAoC;AACtF;AACA,aAAa,GAAG;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,yDAAqB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACzCA;AACA;AAC4C;AAC5C;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,iCAAiC,oEAA+B;AAChE;AACA;AACA;AACA;AACA,uBAAuB,qDAAgB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,sDAAsD;AACvD;;;;;;;;;;;;;;;;;;ACzB0C;AAC1C;AACA;AACA;AACA;AACO,0CAA0C,oDAAK;AACtD;AACA;AACA;AACA;AACA;AACO,2CAA2C,oDAAK;AACvD;AACA;AACA;AACA;AACA;AACO,4CAA4C,oDAAK;AACxD;AACA;;;;;;;;;;;;;;;;;;;;;ACnBA;AACA;AACqE;AACL;AACoH;AACpL;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,iCAAiC,4EAA2B;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,sEAAqB;AAChE,yCAAyC,sFAAoC;AAC7E,2BAA2B,uDAAQ;AACnC;AACA;AACA;AACA;AACA,uBAAuB,iEAAgB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,0EAAyB;AACpE,yCAAyC,sFAAoC;AAC7E,2BAA2B,2DAAY;AACvC;AACA;AACA;AACA;AACA,uBAAuB,qEAAoB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,qEAAoB;AAC/D,yCAAyC,sFAAoC;AAC7E,2BAA2B,sDAAO;AAClC;AACA;AACA;AACA;AACA,uBAAuB,gEAAe;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,wDAAwD;AAClD,+BAA+B,0DAAQ;AAC9C;AACA,8BAA8B,wDAAwD;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,4CAA4C;AAC7C;;;;;;;;;;;;;;;;AC1FA;AACA;AAC6D;AAC7D;AACA;AACA;AACO,4CAA4C,uEAAqB;AACxE;AACA","sources":["webpack://@dfnotebook/dfnotebook-extension/../dfnotebook/lib/actions.js","webpack://@dfnotebook/dfnotebook-extension/../dfnotebook/lib/index.js","webpack://@dfnotebook/dfnotebook-extension/../dfnotebook/lib/model.js","webpack://@dfnotebook/dfnotebook-extension/../dfnotebook/lib/modelfactory.js","webpack://@dfnotebook/dfnotebook-extension/../dfnotebook/lib/panel.js","webpack://@dfnotebook/dfnotebook-extension/../dfnotebook/lib/tokens.js","webpack://@dfnotebook/dfnotebook-extension/../dfnotebook/lib/widget.js","webpack://@dfnotebook/dfnotebook-extension/../dfnotebook/lib/widgetfactory.js"],"sourcesContent":["// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { Dialog, sessionContextDialogs, showDialog } from '@jupyterlab/apputils';\nimport { nullTranslator } from '@jupyterlab/translation';\nimport { ArrayExt, each, toArray } from '@lumino/algorithm';\nimport { ElementExt } from '@lumino/domutils';\nimport { Signal } from '@lumino/signaling';\nimport { KernelError } from '@jupyterlab/notebook';\nimport { DataflowCodeCell } from '@dfnotebook/dfcells';\n/**\n * A collection of actions that run against notebooks.\n *\n * #### Notes\n * All of the actions are a no-op if there is no model on the notebook.\n * The actions set the widget `mode` to `'command'` unless otherwise specified.\n * The actions will preserve the selection on the notebook widget unless\n * otherwise specified.\n */\nexport class DataflowNotebookActions {\n    /**\n     * A signal that emits whenever a cell completes execution.\n     */\n    static get executed() {\n        return Private.executed;\n    }\n    /**\n     * A signal that emits whenever a cell execution is scheduled.\n     */\n    static get executionScheduled() {\n        return Private.executionScheduled;\n    }\n    /**\n     * A signal that emits whenever a cell execution is scheduled.\n     */\n    static get selectionExecuted() {\n        return Private.selectionExecuted;\n    }\n    /**\n     * A private constructor for the `NotebookActions` class.\n     *\n     * #### Notes\n     * This class can never be instantiated. Its static member `executed` will be\n     * merged with the `NotebookActions` namespace. The reason it exists as a\n     * standalone class is because at run time, the `Private.executed` variable\n     * does not yet exist, so it needs to be referenced via a getter.\n     */\n    constructor() {\n        // Intentionally empty.\n    }\n}\n/**\n * A namespace for `NotebookActions` static methods.\n */\n(function (DataflowNotebookActions) {\n    /**\n     * Run the selected cell(s).\n     *\n     * @param notebook - The target notebook widget.\n     *\n     * @param sessionContext - The optional client session object.\n     *\n     * #### Notes\n     * The last selected cell will be activated, but not scrolled into view.\n     * The existing selection will be cleared.\n     * An execution error will prevent the remaining code cells from executing.\n     * All markdown cells will be rendered.\n     */\n    function run(notebook, sessionContext) {\n        if (!notebook.model || !notebook.activeCell) {\n            return Promise.resolve(false);\n        }\n        const state = Private.getState(notebook);\n        const promise = Private.runSelected(notebook, sessionContext);\n        Private.handleRunState(notebook, state, false);\n        return promise;\n    }\n    DataflowNotebookActions.run = run;\n    /**\n     * Run the selected cell(s) and advance to the next cell.\n     *\n     * @param notebook - The target notebook widget.\n     *\n     * @param sessionContext - The optional client session object.\n     *\n     * #### Notes\n     * The existing selection will be cleared.\n     * The cell after the last selected cell will be activated and scrolled into view.\n     * An execution error will prevent the remaining code cells from executing.\n     * All markdown cells will be rendered.\n     * If the last selected cell is the last cell, a new code cell\n     * will be created in `'edit'` mode.  The new cell creation can be undone.\n     */\n    function runAndAdvance(notebook, sessionContext) {\n        if (!notebook.model || !notebook.activeCell) {\n            return Promise.resolve(false);\n        }\n        const state = Private.getState(notebook);\n        const promise = Private.runSelected(notebook, sessionContext);\n        const model = notebook.model;\n        if (notebook.activeCellIndex === notebook.widgets.length - 1) {\n            const cell = model.contentFactory.createCell(notebook.notebookConfig.defaultCell, {});\n            // Do not use push here, as we want an widget insertion\n            // to make sure no placeholder widget is rendered.\n            model.cells.insert(notebook.widgets.length, cell);\n            notebook.activeCellIndex++;\n            notebook.mode = 'edit';\n        }\n        else {\n            notebook.activeCellIndex++;\n        }\n        Private.handleRunState(notebook, state, true);\n        return promise;\n    }\n    DataflowNotebookActions.runAndAdvance = runAndAdvance;\n    /**\n     * Run the selected cell(s) and insert a new code cell.\n     *\n     * @param notebook - The target notebook widget.\n     *\n     * @param sessionContext - The optional client session object.\n     *\n     * #### Notes\n     * An execution error will prevent the remaining code cells from executing.\n     * All markdown cells will be rendered.\n     * The widget mode will be set to `'edit'` after running.\n     * The existing selection will be cleared.\n     * The cell insert can be undone.\n     * The new cell will be scrolled into view.\n     */\n    function runAndInsert(notebook, sessionContext) {\n        if (!notebook.model || !notebook.activeCell) {\n            return Promise.resolve(false);\n        }\n        if (!Private.isNotebookRendered(notebook)) {\n            return Promise.resolve(false);\n        }\n        const state = Private.getState(notebook);\n        const promise = Private.runSelected(notebook, sessionContext);\n        const model = notebook.model;\n        const cell = model.contentFactory.createCell(notebook.notebookConfig.defaultCell, {});\n        model.cells.insert(notebook.activeCellIndex + 1, cell);\n        notebook.activeCellIndex++;\n        notebook.mode = 'edit';\n        Private.handleRunState(notebook, state, true);\n        return promise;\n    }\n    DataflowNotebookActions.runAndInsert = runAndInsert;\n    /**\n     * Run all of the cells in the notebook.\n     *\n     * @param notebook - The target notebook widget.\n     *\n     * @param sessionContext - The optional client session object.\n     *\n     * #### Notes\n     * The existing selection will be cleared.\n     * An execution error will prevent the remaining code cells from executing.\n     * All markdown cells will be rendered.\n     * The last cell in the notebook will be activated and scrolled into view.\n     */\n    function runAll(notebook, sessionContext) {\n        if (!notebook.model || !notebook.activeCell) {\n            return Promise.resolve(false);\n        }\n        const state = Private.getState(notebook);\n        notebook.widgets.forEach(child => {\n            notebook.select(child);\n        });\n        const promise = Private.runSelected(notebook, sessionContext);\n        Private.handleRunState(notebook, state, true);\n        return promise;\n    }\n    DataflowNotebookActions.runAll = runAll;\n    function renderAllMarkdown(notebook, sessionContext) {\n        if (!notebook.model || !notebook.activeCell) {\n            return Promise.resolve(false);\n        }\n        const previousIndex = notebook.activeCellIndex;\n        const state = Private.getState(notebook);\n        notebook.widgets.forEach((child, index) => {\n            if (child.model.type === 'markdown') {\n                notebook.select(child);\n                // This is to make sure that the activeCell\n                // does not get executed\n                notebook.activeCellIndex = index;\n            }\n        });\n        if (notebook.activeCell.model.type !== 'markdown') {\n            return Promise.resolve(true);\n        }\n        const promise = Private.runSelected(notebook, sessionContext);\n        notebook.activeCellIndex = previousIndex;\n        Private.handleRunState(notebook, state, true);\n        return promise;\n    }\n    DataflowNotebookActions.renderAllMarkdown = renderAllMarkdown;\n    /**\n     * Run all of the cells before the currently active cell (exclusive).\n     *\n     * @param notebook - The target notebook widget.\n     *\n     * @param sessionContext - The optional client session object.\n     *\n     * #### Notes\n     * The existing selection will be cleared.\n     * An execution error will prevent the remaining code cells from executing.\n     * All markdown cells will be rendered.\n     * The currently active cell will remain selected.\n     */\n    function runAllAbove(notebook, sessionContext) {\n        const { activeCell, activeCellIndex, model } = notebook;\n        if (!model || !activeCell || activeCellIndex < 1) {\n            return Promise.resolve(false);\n        }\n        const state = Private.getState(notebook);\n        notebook.activeCellIndex--;\n        notebook.deselectAll();\n        for (let i = 0; i < notebook.activeCellIndex; ++i) {\n            notebook.select(notebook.widgets[i]);\n        }\n        const promise = Private.runSelected(notebook, sessionContext);\n        notebook.activeCellIndex++;\n        Private.handleRunState(notebook, state, true);\n        return promise;\n    }\n    DataflowNotebookActions.runAllAbove = runAllAbove;\n    /**\n     * Run all of the cells after the currently active cell (inclusive).\n     *\n     * @param notebook - The target notebook widget.\n     *\n     * @param sessionContext - The optional client session object.\n     *\n     * #### Notes\n     * The existing selection will be cleared.\n     * An execution error will prevent the remaining code cells from executing.\n     * All markdown cells will be rendered.\n     * The last cell in the notebook will be activated and scrolled into view.\n     */\n    function runAllBelow(notebook, sessionContext) {\n        if (!notebook.model || !notebook.activeCell) {\n            return Promise.resolve(false);\n        }\n        const state = Private.getState(notebook);\n        notebook.deselectAll();\n        for (let i = notebook.activeCellIndex; i < notebook.widgets.length; ++i) {\n            notebook.select(notebook.widgets[i]);\n        }\n        const promise = Private.runSelected(notebook, sessionContext);\n        Private.handleRunState(notebook, state, true);\n        return promise;\n    }\n    DataflowNotebookActions.runAllBelow = runAllBelow;\n})(DataflowNotebookActions || (DataflowNotebookActions = {}));\n/**\n * A namespace for private data.\n */\nvar Private;\n(function (Private) {\n    /**\n     * A signal that emits whenever a cell completes execution.\n     */\n    Private.executed = new Signal({});\n    /**\n     * A signal that emits whenever a cell execution is scheduled.\n     */\n    Private.executionScheduled = new Signal({});\n    /**\n     * A signal that emits when one notebook's cells are all executed.\n     */\n    Private.selectionExecuted = new Signal({});\n    function isNotebookRendered(notebook) {\n        const translator = notebook.translator;\n        const trans = translator.load('jupyterlab');\n        if (notebook.remainingCellToRenderCount !== 0) {\n            showDialog({\n                body: trans.__(`Notebook is still rendering and has for now (%1) remaining cells to render.\n\nPlease wait for the complete rendering before invoking that action.`, notebook.remainingCellToRenderCount),\n                buttons: [Dialog.okButton({ label: trans.__('Ok') })]\n            }).catch(reason => {\n                console.error('An error occurred when displaying notebook rendering warning', reason);\n            });\n            return false;\n        }\n        return true;\n    }\n    Private.isNotebookRendered = isNotebookRendered;\n    /**\n     * Get the state of a widget before running an action.\n     */\n    function getState(notebook) {\n        return {\n            wasFocused: notebook.node.contains(document.activeElement),\n            activeCell: notebook.activeCell\n        };\n    }\n    Private.getState = getState;\n    /**\n     * Handle the state of a widget after running an action.\n     */\n    function handleState(notebook, state, scrollIfNeeded = false) {\n        const { activeCell, node } = notebook;\n        if (state.wasFocused || notebook.mode === 'edit') {\n            notebook.activate();\n        }\n        if (scrollIfNeeded && activeCell) {\n            ElementExt.scrollIntoViewIfNeeded(node, activeCell.node);\n        }\n    }\n    Private.handleState = handleState;\n    /**\n     * Handle the state of a widget after running a run action.\n     */\n    function handleRunState(notebook, state, scroll = false) {\n        if (state.wasFocused || notebook.mode === 'edit') {\n            notebook.activate();\n        }\n        if (scroll && state.activeCell) {\n            // Scroll to the top of the previous active cell output.\n            const rect = state.activeCell.inputArea.node.getBoundingClientRect();\n            notebook.scrollToPosition(rect.bottom, 45);\n        }\n    }\n    Private.handleRunState = handleRunState;\n    /**\n     * Run the selected cells.\n     */\n    function runSelected(notebook, sessionContext) {\n        notebook.mode = 'command';\n        let lastIndex = notebook.activeCellIndex;\n        const selected = notebook.widgets.filter((child, index) => {\n            const active = notebook.isSelectedOrActive(child);\n            if (active) {\n                lastIndex = index;\n            }\n            return active;\n        });\n        notebook.activeCellIndex = lastIndex;\n        notebook.deselectAll();\n        return Promise.all(selected.map(child => runCell(notebook, child, sessionContext)))\n            .then(results => {\n            if (notebook.isDisposed) {\n                return false;\n            }\n            Private.selectionExecuted.emit({\n                notebook,\n                lastCell: notebook.widgets[lastIndex]\n            });\n            // Post an update request.\n            notebook.update();\n            return results.every(result => result);\n        })\n            .catch(reason => {\n            if (reason.message.startsWith('KernelReplyNotOK')) {\n                selected.map(cell => {\n                    // Remove '*' prompt from cells that didn't execute\n                    if (cell.model.type === 'code' &&\n                        cell.model.executionCount == null) {\n                        cell.setPrompt('');\n                    }\n                });\n            }\n            else {\n                throw reason;\n            }\n            Private.selectionExecuted.emit({\n                notebook,\n                lastCell: notebook.widgets[lastIndex]\n            });\n            notebook.update();\n            return false;\n        });\n    }\n    Private.runSelected = runSelected;\n    /**\n     * Run a cell.\n     */\n    function runCell(notebook, cell, sessionContext, translator) {\n        var _a, _b, _c;\n        translator = translator || nullTranslator;\n        const trans = translator.load('jupyterlab');\n        switch (cell.model.type) {\n            case 'markdown':\n                cell.rendered = true;\n                cell.inputHidden = false;\n                Private.executed.emit({ notebook, cell, success: true });\n                break;\n            case 'code':\n                if (sessionContext) {\n                    if (sessionContext.isTerminating) {\n                        void showDialog({\n                            title: trans.__('Kernel Terminating'),\n                            body: trans.__('The kernel for %1 appears to be terminating. You can not run any cell for now.', (_a = sessionContext.session) === null || _a === void 0 ? void 0 : _a.path),\n                            buttons: [Dialog.okButton({ label: trans.__('Ok') })]\n                        });\n                        break;\n                    }\n                    if (sessionContext.pendingInput) {\n                        void showDialog({\n                            title: trans.__('Cell not executed due to pending input'),\n                            body: trans.__('The cell has not been executed to avoid kernel deadlock as there is another pending input! Submit your pending input and try again.'),\n                            buttons: [Dialog.okButton({ label: trans.__('Ok') })]\n                        });\n                        return Promise.resolve(false);\n                    }\n                    if (sessionContext.hasNoKernel) {\n                        void sessionContextDialogs.selectKernel(sessionContext);\n                        return Promise.resolve(false);\n                    }\n                    const deletedCells = (_c = (_b = notebook.model) === null || _b === void 0 ? void 0 : _b.deletedCells) !== null && _c !== void 0 ? _c : [];\n                    const codeDict = {};\n                    const cellIdWidgetMap = {};\n                    const outputTags = {};\n                    const inputTags = {};\n                    if (notebook.model) {\n                        each(notebook.model.cells, (c, index) => {\n                            const child = notebook.widgets[index];\n                            if (c.type === 'code') {\n                                // FIXME replace with utility function (see dfcells/widget)\n                                const cId = c.id.replace(/-/g, '').substring(0, 8);\n                                const inputTag = c.metadata.get('tag');\n                                if (inputTag) {\n                                    // FIXME need to check for duplicates!\n                                    inputTags[inputTag] = cId;\n                                }\n                                codeDict[cId] = c.value.text;\n                                cellIdWidgetMap[cId] = child;\n                                let cellOutputTags = [];\n                                for (let i = 0; i < child.outputArea.model.length; ++i) {\n                                    const out = child.outputArea.model.get(i);\n                                    if (out.metadata['output_tag']) {\n                                        cellOutputTags.push(out.metadata['output_tag']);\n                                    }\n                                }\n                                outputTags[cId] = cellOutputTags;\n                            }\n                        });\n                    }\n                    // console.log('codeDict:', codeDict);\n                    // console.log('cellIdWidgetMap:', cellIdWidgetMap);\n                    // console.log('outputTags:', outputTags);\n                    // console.log('inputTags:', inputTags);\n                    const dfData = {\n                        // FIXME replace with utility function (see dfcells/widget)\n                        uuid: cell.model.id.replace(/-/g, '').substring(0, 8) || '',\n                        code_dict: codeDict,\n                        output_tags: outputTags,\n                        input_tags: inputTags,\n                        auto_update_flags: {},\n                        force_cached_flags: {} // this.notebook.get_force_cached_flags()})\n                    };\n                    Private.executionScheduled.emit({ notebook, cell });\n                    return DataflowCodeCell.execute(cell, sessionContext, {\n                        deletedCells,\n                        recordTiming: notebook.notebookConfig.recordTiming,\n                    }, dfData, cellIdWidgetMap)\n                        .then(reply => {\n                        deletedCells.splice(0, deletedCells.length);\n                        if (cell.isDisposed) {\n                            return false;\n                        }\n                        if (!reply) {\n                            return true;\n                        }\n                        if (reply.content.status === 'ok') {\n                            const content = reply.content;\n                            if (content.payload && content.payload.length) {\n                                handlePayload(content, notebook, cell);\n                            }\n                            return true;\n                        }\n                        else {\n                            throw new KernelError(reply.content);\n                        }\n                    })\n                        .catch(reason => {\n                        if (cell.isDisposed || reason.message.startsWith('Canceled')) {\n                            return false;\n                        }\n                        Private.executed.emit({ notebook, cell, success: false, error: reason });\n                        throw reason;\n                    })\n                        .then(ran => {\n                        if (ran) {\n                            Private.executed.emit({ notebook, cell, success: true });\n                        }\n                        return ran;\n                    });\n                }\n                cell.model.clearExecution();\n                break;\n            default:\n                break;\n        }\n        return Promise.resolve(true);\n    }\n    /**\n     * Handle payloads from an execute reply.\n     *\n     * #### Notes\n     * Payloads are deprecated and there are no official interfaces for them in\n     * the kernel type definitions.\n     * See [Payloads (DEPRECATED)](https://jupyter-client.readthedocs.io/en/latest/messaging.html#payloads-deprecated).\n     */\n    function handlePayload(content, notebook, cell) {\n        var _a;\n        const setNextInput = (_a = content.payload) === null || _a === void 0 ? void 0 : _a.filter(i => {\n            return i.source === 'set_next_input';\n        })[0];\n        if (!setNextInput) {\n            return;\n        }\n        const text = setNextInput.text;\n        const replace = setNextInput.replace;\n        if (replace) {\n            cell.model.value.text = text;\n            return;\n        }\n        // Create a new code cell and add as the next cell.\n        const newCell = notebook.model.contentFactory.createCodeCell({});\n        const cells = notebook.model.cells;\n        const index = ArrayExt.firstIndexOf(toArray(cells), cell.model);\n        newCell.value.text = text;\n        if (index === -1) {\n            cells.push(newCell);\n        }\n        else {\n            cells.insert(index + 1, newCell);\n        }\n    }\n    /**\n     * Get the selected cell(s) without affecting the clipboard.\n     *\n     * @param notebook - The target notebook widget.\n     *\n     * @returns A list of 0 or more selected cells\n     */\n    function selectedCells(notebook) {\n        return notebook.widgets\n            .filter(cell => notebook.isSelectedOrActive(cell))\n            .map(cell => cell.model.toJSON())\n            .map(cellJSON => {\n            if (cellJSON.metadata.deletable !== undefined) {\n                delete cellJSON.metadata.deletable;\n            }\n            return cellJSON;\n        });\n    }\n    Private.selectedCells = selectedCells;\n})(Private || (Private = {}));\n//# sourceMappingURL=actions.js.map","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/**\n * @packageDocumentation\n * @module dfnotebook\n */\nexport * from './actions';\nexport * from './model';\nexport * from './modelfactory';\nexport * from './panel';\nexport * from './widget';\nexport * from './tokens';\nexport * from './widgetfactory';\n//# sourceMappingURL=index.js.map","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { NotebookModel } from '@jupyterlab/notebook';\nimport { UUID } from '@lumino/coreutils';\nimport { DataflowCodeCellModel, DataflowRawCellModel, DataflowMarkdownCellModel } from '@dfnotebook/dfcells';\nexport class DataflowNotebookModel extends NotebookModel {\n    constructor(options = {}) {\n        super(Object.assign({ contentFactory: DataflowNotebookModel.defaultContentFactory }, options));\n    }\n    /**\n     * The name of the model.\n     */\n    get name() {\n        return 'dfnotebook';\n    }\n    fromJSON(value) {\n        var _a, _b;\n        let isDataflow = true;\n        if (((_b = (_a = value.metadata) === null || _a === void 0 ? void 0 : _a.kernelspec) === null || _b === void 0 ? void 0 : _b.name) && value.metadata.kernelspec.name != 'dfpython3') {\n            //@ts-expect-error\n            this.contentFactory = NotebookModel.defaultContentFactory;\n            isDataflow = false;\n        }\n        super.fromJSON(value);\n        this.metadata.set('dfnotebook', isDataflow);\n    }\n}\n/**\n * The namespace for the `NotebookModel` class statics.\n */\n(function (DataflowNotebookModel) {\n    /**\n     * The dataflow implementation of an `IContentFactory`.\n     */\n    class ContentFactory extends NotebookModel.ContentFactory {\n        /*\n         * FIXME: Add codeCellContentFactory default to DataflowCodeCellContentFactory??\n         */\n        constructor(options) {\n            super(options);\n        }\n        /**\n         * Create a new code cell.\n         *\n         * @param source - The data to use for the original source data.\n         *\n         * @returns A new code cell. If a source cell is provided, the\n         *   new cell will be initialized with the data from the source.\n         *   If the contentFactory is not provided, the instance\n         *   `codeCellContentFactory` will be used.\n         */\n        createCodeCell(options) {\n            if (options.contentFactory) {\n                options.contentFactory = this.codeCellContentFactory;\n            }\n            if (this.modelDB) {\n                if (!options.id) {\n                    options.id = UUID.uuid4();\n                }\n                options.modelDB = this.modelDB.view(options.id);\n            }\n            return new DataflowCodeCellModel(options);\n        }\n        /**\n         * Create a new markdown cell.\n         *\n         * @param source - The data to use for the original source data.\n         *\n         * @returns A new markdown cell. If a source cell is provided, the\n         *   new cell will be initialized with the data from the source.\n         */\n        createMarkdownCell(options) {\n            if (this.modelDB) {\n                if (!options.id) {\n                    options.id = UUID.uuid4();\n                }\n                options.modelDB = this.modelDB.view(options.id);\n            }\n            return new DataflowMarkdownCellModel(options);\n        }\n        /**\n         * Create a new raw cell.\n         *\n         * @param source - The data to use for the original source data.\n         *\n         * @returns A new raw cell. If a source cell is provided, the\n         *   new cell will be initialized with the data from the source.\n         */\n        createRawCell(options) {\n            if (this.modelDB) {\n                if (!options.id) {\n                    options.id = UUID.uuid4();\n                }\n                options.modelDB = this.modelDB.view(options.id);\n            }\n            return new DataflowRawCellModel(options);\n        }\n        /**\n         * Clone the content factory with a new IModelDB.\n         */\n        clone(modelDB) {\n            return new ContentFactory({\n                modelDB: modelDB,\n                codeCellContentFactory: this.codeCellContentFactory\n            });\n        }\n    }\n    DataflowNotebookModel.ContentFactory = ContentFactory;\n    /**\n     * The default `ContentFactory` instance.\n     */\n    DataflowNotebookModel.defaultContentFactory = new ContentFactory({});\n})(DataflowNotebookModel || (DataflowNotebookModel = {}));\n//# sourceMappingURL=model.js.map","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { DataflowNotebookModel } from './model';\nimport { NotebookModelFactory } from '@jupyterlab/notebook';\n/**\n * A model factory for notebooks.\n */\nexport class DataflowNotebookModelFactory extends NotebookModelFactory {\n    /**\n     * Construct a new notebook model factory.\n     */\n    constructor(options) {\n        super(Object.assign({ contentFactory: new DataflowNotebookModel.ContentFactory({\n                codeCellContentFactory: options.codeCellContentFactory\n            }) }, options));\n    }\n    /**\n     * Create a new model for a given path.\n     *\n     * @param languagePreference - An optional kernel language preference.\n     *\n     * @returns A new document model.\n     */\n    createNew(languagePreference, modelDB, isInitialized) {\n        const contentFactory = this.contentFactory;\n        return new DataflowNotebookModel({\n            languagePreference,\n            contentFactory,\n            modelDB,\n            isInitialized,\n            //@ts-ignore\n            disableDocumentWideUndoRedo: this._disableDocumentWideUndoRedo\n        });\n    }\n    /**\n     * The name of the model.\n     */\n    get name() {\n        return 'dfnotebook';\n    }\n}\n//# sourceMappingURL=modelfactory.js.map","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { DataflowNotebook } from './widget';\n/**\n * A namespace for `DataflowNotebookPanel` statics.\n */\nexport var DataflowNotebookPanel;\n(function (DataflowNotebookPanel) {\n    /**\n     * The default implementation of an `IContentFactory`.\n     */\n    class ContentFactory extends DataflowNotebook.ContentFactory {\n        /**\n         * Create a new content area for the panel.\n         */\n        createNotebook(options) {\n            return new DataflowNotebook(options);\n        }\n    }\n    DataflowNotebookPanel.ContentFactory = ContentFactory;\n    /**\n     * Default content factory for the notebook panel.\n     */\n    DataflowNotebookPanel.defaultContentFactory = new ContentFactory();\n})(DataflowNotebookPanel || (DataflowNotebookPanel = {}));\n//# sourceMappingURL=panel.js.map","import { Token } from '@lumino/coreutils';\n/* tslint:disable */\n/**\n * The dfnotebook model factory token.\n */\nexport const IDataflowNotebookModelFactory = new Token('@dfnotebook/dfnotebook:IDataflowNotebookModelFactory');\n/* tslint:enable */\n/* tslint:disable */\n/**\n * The dfnotebook widget factory token.\n */\nexport const IDataflowNotebookWidgetFactory = new Token('@dfnotebook/dfnotebook:DataflowNotebookWidgetFactory');\n/* tslint:enable */\n/* tslint:disable */\n/**\n * The dfnotebook content factory token.\n */\nexport const IDataflowNotebookContentFactory = new Token('@dfnotebook/dfnotebook:IDataflowNotebookContentFactory');\n/* tslint:enable */ \n//# sourceMappingURL=tokens.js.map","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { CodeCell, MarkdownCell, RawCell, } from '@jupyterlab/cells';\nimport { StaticNotebook, Notebook } from '@jupyterlab/notebook';\nimport { DataflowCell, DataflowCodeCell, DataflowCodeCellModel, DataflowMarkdownCell, DataflowMarkdownCellModel, DataflowRawCell, DataflowRawCellModel } from '@dfnotebook/dfcells';\n/**\n * The namespace for the `StaticNotebook` class statics.\n */\nexport var DataflowStaticNotebook;\n(function (DataflowStaticNotebook) {\n    /**\n     * The default implementation of an `IContentFactory`.\n     */\n    class ContentFactory extends DataflowCell.ContentFactory {\n        /**\n         * Create a new code cell widget.\n         *\n         * #### Notes\n         * If no cell content factory is passed in with the options, the one on the\n         * notebook content factory is used.\n         */\n        createCodeCell(options, parent) {\n            if (!(options.model instanceof DataflowCodeCellModel)) {\n                options.contentFactory = StaticNotebook.defaultContentFactory;\n                return new CodeCell(options).initializeState();\n            }\n            if (!options.contentFactory) {\n                options.contentFactory = this;\n            }\n            return new DataflowCodeCell(options).initializeState();\n        }\n        /**\n         * Create a new markdown cell widget.\n         *\n         * #### Notes\n         * If no cell content factory is passed in with the options, the one on the\n         * notebook content factory is used.\n         */\n        createMarkdownCell(options, parent) {\n            if (!(options.model instanceof DataflowMarkdownCellModel)) {\n                options.contentFactory = StaticNotebook.defaultContentFactory;\n                return new MarkdownCell(options).initializeState();\n            }\n            if (!options.contentFactory) {\n                options.contentFactory = this;\n            }\n            return new DataflowMarkdownCell(options).initializeState();\n        }\n        /**\n         * Create a new raw cell widget.\n         *\n         * #### Notes\n         * If no cell content factory is passed in with the options, the one on the\n         * notebook content factory is used.\n         */\n        createRawCell(options, parent) {\n            if (!(options.model instanceof DataflowRawCellModel)) {\n                options.contentFactory = StaticNotebook.defaultContentFactory;\n                return new RawCell(options).initializeState();\n            }\n            if (!options.contentFactory) {\n                options.contentFactory = this;\n            }\n            return new DataflowRawCell(options).initializeState();\n        }\n    }\n    DataflowStaticNotebook.ContentFactory = ContentFactory;\n    /**\n     * Default content factory for the static notebook widget.\n     */\n    DataflowStaticNotebook.defaultContentFactory = new ContentFactory();\n})(DataflowStaticNotebook || (DataflowStaticNotebook = {}));\nexport class DataflowNotebook extends Notebook {\n    constructor(options) {\n        super(Object.assign({ contentFactory: DataflowNotebook.defaultContentFactory }, options));\n    }\n}\n(function (DataflowNotebook) {\n    /**\n     * The default implementation of a notebook content factory..\n     *\n     * #### Notes\n     * Override methods on this class to customize the default notebook factory\n     * methods that create notebook content.\n     */\n    class ContentFactory extends DataflowStaticNotebook.ContentFactory {\n    }\n    DataflowNotebook.ContentFactory = ContentFactory;\n    DataflowNotebook.defaultContentFactory = new ContentFactory();\n})(DataflowNotebook || (DataflowNotebook = {}));\n//# sourceMappingURL=widget.js.map","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { NotebookWidgetFactory } from \"@jupyterlab/notebook\";\n/**\n * A widget factory for notebook panels.\n */\nexport class DataflowNotebookWidgetFactory extends NotebookWidgetFactory {\n}\n//# sourceMappingURL=widgetfactory.js.map"],"names":[],"sourceRoot":""}