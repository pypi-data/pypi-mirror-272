import os
from skimage import io                                                 # type: ignore
import numpy as np
import matplotlib.pyplot as plt
import pandas as pd
from .utils.rme_parser import rme_parser
from .utils.utils import interp1d, normalize
import uuid
import re

class Processor:
    def __init__(self, path, channel_info, group_number=1, max_value=65535, final_len=3500, _trim_edge = False):
        """
        Processes a directory containing images and a README generated by "con_auto_dir.py".

        :param path: Absolute path to directory containing images and README.txt (can use relative path if in same directory)
        :param channel_info: List of tuples containing channel names and index of  channels as they appear in image, max length 4 \\
        Example: [("channel_name_1", 0), ("channel_name_2", 1)]
        :param group_number: Number of group to be processed if multiple groups appear in README.txt. Not index based, first group is 1.
        :param max_value: Maximum value of pixels in images. Default is 65535. Used to normalize images, can be any value.
        :param final_len: Length of final 1D arrays. Default is 3500. Used to interpolate images, can be any value.
        """

        if path[-1] != "/":
            path += "/"

        self.trim_edge = _trim_edge
        self.channel_info = channel_info
        self.metadata = rme_parser(path + "README.txt")
        self.header = self.metadata.header
        self.dbdata = self.metadata.infos[group_number-1]
        self._max_value = max_value
        self._final_len = final_len
        self.Raw_Arrays = self._gen_raw_arrays(path)
        self.flatdata_ni, self.flatdata, self.raw = self._process(self.Raw_Arrays)

    def _gen_raw_arrays(self, path):
        """
        Loads images from directory specified by path and returns them as a list of 2D arrays. If multi channel, returns a list of lists of 2D arrays.

        :param path: Absolute path to directory containing images and README.txt (can use relative path if in same directory)
        :returns: A list of lists of 2D arrays, nested lists are length 1 if single channel, length 2-4 if multi channel.
        """
        image_names = [i for i in os.listdir(path) if not i.startswith(".") and not i.endswith(".txt")]
        image_names = sorted(image_names, key = lambda x: int(re.findall(r'[\d]+', x)[0]))
        Raw_Images = []


        for _, name in enumerate(image_names):
            img = io.imread(os.path.join(path, name))
            img_shape = img.shape

            min_index = np.argmin(img_shape)

            if len(img_shape) == 2:         # Case of image with a single channel
                Raw_Images.append(img)
            elif min_index == 0:            # If statements to catch cases where image channel is in different dimension than expected
                Raw_Images.append([img[i,:,:] for i in list(map(lambda x: x[1], self.channel_info))]) # type: ignore
            elif min_index == 1:
                Raw_Images.append([img[:,i,:] for i in list(map(lambda x: x[1], self.channel_info))]) # type: ignore
            elif min_index == 2:
                Raw_Images.append([img[:,:,i] for i in list(map(lambda x: x[1], self.channel_info))]) # type: ignore

        return Raw_Images
    
    def _process(self, Raw_data):
        """
        Processes the raw image data, flattens into 1D arrays based on max value of each column of image, normalizes values, and interpolates to uniform length.

        :param Raw_data: List of lists of 2D arrays, nested lists are length 1 if single channel, length 2-4 if multi channel.
        :return flatdata_ni: Arrays are not interpolated.
        :return flatdata: Arrays are interpolated to uniform length. 
        :return flatdata_raw: Arrays are not interpolated and are not normalized, may be floats, 8bit uint, 12bit uint, or 16bit uint.
        """
        flatdata_ni = []                                    # Flat data no interpolation
        flatdata = []
        flatdata_raw = []

        for _, channels in enumerate(Raw_data):
            img_arrs_ni = []
            img_arrs_raw = []
            img_arrs = []

            for image in channels:
                arr = np.array(image).astype(np.uint16)
                if self.trim_edge:
                    arr = arr[1:, 1:]
                arr = np.max(arr, axis=0)                         # Collapse 2d image into vector based on max value in each column
                img_arrs_raw.append(np.copy(arr))                   # Append raw arrays
                arr = normalize(arr, self._max_value)               # Normalize to values between 0 and 1.          
                img_arrs_ni.append(np.copy(arr))                    # Append uninterpolated arrays

                arr_int = interp1d(arr, self._final_len)            # Interpolate the vector into uniform length.
                img_arrs.append(np.copy(arr_int))

            flatdata.append(np.copy(img_arrs))
            flatdata_ni.append(np.copy(img_arrs_ni))   
            flatdata_raw.append(np.copy(img_arrs_raw))
            
        return flatdata_ni, np.asarray(flatdata), flatdata_raw
    

    def generate_db(self):
        """
        Generates a dataframe from metadata in README.txt and processed image data. 
        Generates uuids for each row of data.

        :return: None
        """
        self.df = pd.DataFrame(columns=self.header, data=self.dbdata)
        for i in range(4):
            self.df[f"channel{i}_name"] = np.nan
            self.df[f"channel{i}_arr_vals"] = np.nan
            self.df[f"channel{i}_arr_vals_ni"] = np.nan
            self.df[f"channel{i}_arr_vals_raw"] = np.nan

        for i, tup in enumerate(self.channel_info):
            self.df[f"channel{i}_name"] = tup[0]
            self.df[f"channel{i}_arr_vals"] = list(self.flatdata[:, i])
            self.df[f"channel{i}_arr_vals_ni"] = [channel[i] for channel in self.flatdata_ni] 
            self.df[f"channel{i}_arr_vals_raw"] = [channel[i] for channel in self.raw]




    def update_db(self, path):
        """
        Uptades an existing dataframe with new data from processed images. WARNING: Not recommended
        unless using only default values in dataframe. If you have added other channels merge your data 
        yourself. 

        :param path: Absolute path to existing dataframe stored in pkl format.
        :return: None
        """

        old = pd.read_pickle(path)
        new = pd.concat([old, self.df])
        new.reset_index(drop=True, inplace=True)
        new.to_pickle(path)

    
class BarcodePlotter:
    def __init__(self):
        """
        Contains Custom Colormaps
        """
        self.cmap_black_to_red = plt.cm.colors.LinearSegmentedColormap.from_list("black_red", ["black", "red"])
        self.cmap_black_to_green = plt.cm.colors.LinearSegmentedColormap.from_list("black_green", ["black", "green"])

    def create_barcode(self, arr):
        height = len(arr) // 20 if len(arr) >= 20 else 1    # Adjust height scaling so that barcodes don't look dumb
        return np.vstack([arr for k in range(height)])

    def plot_barcodes_single(self, data, save=None):
        """
        Plots 1D arrays as "barcodes" 

        :param data: Array of len 1 arrays containing 1D arrays to be plotted or array of 1D arrays. 
        :param save: If not None, saves the figure to the path specified by save
        :return: None
        """

        fig, axes = plt.subplots(len(data), 1)


        for i, arr in enumerate(data):
            if isinstance(arr[0], (np.floating, float)):
                bar = self.create_barcode(arr)
            else:
                bar = self.create_barcode(arr[0])

            if len(data) == 1:
                break
            else:
                axes[i].imshow(bar, cmap="Greys_r", vmin = 0, vmax=1.0)
                axes[i].axis("off")

        if len(data) == 1:
            axes.imshow(bar, cmap="Greys_r", vmin = 0, vmax=1.0)
            axes.axis("off")

        fig.tight_layout(pad=0)
        
        
        if save is not None:
            fig.savefig(save, dpi=1200)

    def plot_barcodes_dual(self, data, cmap1 = None, cmap2 = None, save=None):
        """
        Plots pairs of 1D arrays as individual "barcodes" and as a merged form

        :param data: Array of len 2 arrays containing 1D arrays of uniform length to be plotted.
        :param save: If not None, saves the figure to the path specified by save
        :return: None
        """
        if not cmap1:
            cmap1 = self.cmap_black_to_red
        if not cmap2:
            cmap2 = self.cmap_black_to_green

        fig, axes = plt.subplots(len(data), 1)

        for i, bars in enumerate(data):
            bc0 = cmap1(self.create_barcode(bars[0]))
            bc1 = cmap2(self.create_barcode(bars[1]))

            merged = np.maximum(bc0, bc1)

            final = np.vstack([bc0[:int(len(bc0)/2)], merged, bc1[int(len(bc1)/2):]])

            if len(data) == 1:
                break

            else:
                axes[i].imshow(final, vmin = 0, vmax=1.0)
                axes[i].axis("off")

        if len(data) == 1:
            axes.imshow(final, vmin = 0, vmax=1.0)
            axes.axis("off")

        fig.tight_layout(pad=0)
        
        if save is not None:
            fig.savefig(save, dpi=1200)