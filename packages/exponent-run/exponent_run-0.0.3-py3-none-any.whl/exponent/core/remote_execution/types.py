# This file is autogenerated. Do not edit directly.
# Update the file at python_modules/exponent_server/exponent_server/core/remote_execution/types.py
# and run 'make remote_execution_types' to update the file.

from typing import Any, ClassVar, Generic, Literal, TypeGuard, TypeVar

from pydantic import BaseModel


class CreateChatResponse(BaseModel):
    chat_uuid: str


class StartChatRequest(BaseModel):
    chat_uuid: str
    prompt: str


class StartChatResponse(BaseModel):
    chat_uuid: str


class RemoteExecutionMessageData(BaseModel):
    namespace: str
    direction: Literal["request", "response"]
    message_data: str

    def message_type(self) -> str:
        return f"{self.namespace}.{self.direction}"


class RemoteExecutionResponseData(RemoteExecutionMessageData):
    @classmethod
    def deserialize_raw(cls, message_str: str) -> "RemoteExecutionResponse":
        message = cls.model_validate_json(message_str)
        return message.deserialize()

    def deserialize(self) -> "RemoteExecutionResponse":
        if self.direction != "response":
            raise ValueError(f"Expected response, but got {self.direction}")
        elif self.message_type() == CodeExecutionResponse.message_type():
            return CodeExecutionResponse.model_validate_json(self.message_data)
        elif self.message_type() == ListFilesResponse.message_type():
            return ListFilesResponse.model_validate_json(self.message_data)
        elif self.message_type() == GetMatchingFilesResponse.message_type():
            return GetMatchingFilesResponse.model_validate_json(self.message_data)
        elif self.message_type() == GetFileContentsResponse.message_type():
            return GetFileContentsResponse.model_validate_json(self.message_data)
        else:
            raise ValueError(f"Unknown message type: {self.message_type()}")


class RemoteExecutionRequestData(RemoteExecutionMessageData):
    @classmethod
    def deserialize_raw(cls, message_str: str) -> "RemoteExecutionRequest[Any]":
        message = cls.model_validate_json(message_str)
        return message.deserialize()

    def deserialize(self) -> "RemoteExecutionRequest[Any]":
        if self.direction != "request":
            raise ValueError(f"Expected request, but got {self.direction}")
        elif self.message_type() == CodeExecutionRequest.message_type():
            return CodeExecutionRequest.model_validate_json(self.message_data)
        elif self.message_type() == ListFilesRequest.message_type():
            return ListFilesRequest.model_validate_json(self.message_data)
        elif self.message_type() == GetFileContentsRequest.message_type():
            return GetFileContentsRequest.model_validate_json(self.message_data)
        elif self.message_type() == GetMatchingFilesRequest.message_type():
            return GetMatchingFilesRequest.model_validate_json(self.message_data)
        else:
            raise ValueError(f"Unknown message type: {self.message_type()}")


class RemoteExecutionMessage(BaseModel):
    direction: ClassVar[Literal["request", "response"]]
    namespace: ClassVar[str]
    correlation_id: str

    @classmethod
    def message_type(cls) -> str:
        return f"{cls.namespace}.{cls.direction}"

    @property
    def result_key(self) -> str:
        return f"{self.namespace}:{self.correlation_id}"

    def serialize(self) -> str:
        message = RemoteExecutionMessageData(
            namespace=self.namespace,
            direction=self.direction,
            message_data=self.model_dump_json(),
        )
        return message.model_dump_json()


class RemoteExecutionResponse(RemoteExecutionMessage):
    direction: ClassVar[Literal["response"]] = "response"


ResponseT = TypeVar("ResponseT", bound=RemoteExecutionResponse)


class RemoteExecutionRequest(RemoteExecutionMessage, Generic[ResponseT]):
    direction: ClassVar[Literal["request"]] = "request"

    def validate_response_type(
        self, response: RemoteExecutionMessage
    ) -> TypeGuard[ResponseT]:
        if self.namespace != response.namespace or response.direction != "response":
            raise ValueError(
                f"Expected {self.namespace}.response, but got {response.namespace}.{response.direction}"
            )
        return True


class CodeExecutionResponse(RemoteExecutionResponse):
    namespace: ClassVar[str] = "code_execution"

    content: str


class CodeExecutionRequest(RemoteExecutionRequest[CodeExecutionResponse]):
    namespace: ClassVar[str] = "code_execution"

    language: str
    content: str


class ListFilesResponse(RemoteExecutionResponse):
    namespace: ClassVar[str] = "list_files"

    filenames: list[str]


class ListFilesRequest(RemoteExecutionRequest[ListFilesResponse]):
    namespace: ClassVar[str] = "list_files"

    directory: str


class GetFileContentsResponse(RemoteExecutionResponse):
    namespace: ClassVar[str] = "get_file_contents"

    file_path: str
    content: str


class GetFileContentsRequest(RemoteExecutionRequest[GetFileContentsResponse]):
    namespace: ClassVar[str] = "get_file_contents"

    file_path: str


class GetMatchingFilesResponse(RemoteExecutionResponse):
    namespace: ClassVar[str] = "get_matching_files"

    file_paths: list[str]


class GetMatchingFilesRequest(RemoteExecutionRequest[GetMatchingFilesResponse]):
    namespace: ClassVar[str] = "get_matching_files"

    search_term: str
