(self["webpackChunk_datalayer_jupyter_viewer"] = self["webpackChunk_datalayer_jupyter_viewer"] || []).push([[758],{

/***/ 265:
/***/ ((module) => {

function webpackEmptyAsyncContext(req) {
	// Here Promise.resolve().then() is used instead of new Promise() to prevent
	// uncaught exception popping up in devtools
	return Promise.resolve().then(() => {
		var e = new Error("Cannot find module '" + req + "'");
		e.code = 'MODULE_NOT_FOUND';
		throw e;
	});
}
webpackEmptyAsyncContext.keys = () => ([]);
webpackEmptyAsyncContext.resolve = webpackEmptyAsyncContext;
webpackEmptyAsyncContext.id = 265;
module.exports = webpackEmptyAsyncContext;

/***/ }),

/***/ 38865:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "PIPLITE_INDEX_SCHEMA": () => (/* reexport */ schema_piplite_v0_schema_namespaceObject),
  "PyodideKernel": () => (/* reexport */ PyodideKernel),
  "PyodideRemoteKernel": () => (/* reexport */ worker/* PyodideRemoteKernel */.O),
  "allJSONUrl": () => (/* reexport */ all_namespaceObject2),
  "ipykernelWheelUrl": () => (/* reexport */ ipykernel_6_9_2_py3_none_any_namespaceObject2),
  "pipliteWheelUrl": () => (/* reexport */ piplite_0_2_3_py3_none_any_namespaceObject2),
  "pyodide_kernelWheelUrl": () => (/* reexport */ pyodide_kernel_0_2_3_py3_none_any_namespaceObject2),
  "widgetsnbextensionWheelUrl": () => (/* reexport */ widgetsnbextension_3_6_6_py3_none_any_namespaceObject2),
  "widgetsnbextensionWheelUrl1": () => (/* reexport */ widgetsnbextension_4_0_10_py3_none_any_namespaceObject2)
});

;// CONCATENATED MODULE: ./node_modules/@jupyterlite/pyodide-kernel/pypi/all.json
const all_namespaceObject = __webpack_require__.p + "pypi/all.json";
var all_namespaceObject2 = /*#__PURE__*/__webpack_require__.t(all_namespaceObject);
;// CONCATENATED MODULE: ./node_modules/@jupyterlite/pyodide-kernel/pypi/ipykernel-6.9.2-py3-none-any.whl
const ipykernel_6_9_2_py3_none_any_namespaceObject = __webpack_require__.p + "pypi/ipykernel-6.9.2-py3-none-any.whl";
var ipykernel_6_9_2_py3_none_any_namespaceObject2 = /*#__PURE__*/__webpack_require__.t(ipykernel_6_9_2_py3_none_any_namespaceObject);
;// CONCATENATED MODULE: ./node_modules/@jupyterlite/pyodide-kernel/pypi/piplite-0.2.3-py3-none-any.whl
const piplite_0_2_3_py3_none_any_namespaceObject = __webpack_require__.p + "pypi/piplite-0.2.3-py3-none-any.whl";
var piplite_0_2_3_py3_none_any_namespaceObject2 = /*#__PURE__*/__webpack_require__.t(piplite_0_2_3_py3_none_any_namespaceObject);
;// CONCATENATED MODULE: ./node_modules/@jupyterlite/pyodide-kernel/pypi/pyodide_kernel-0.2.3-py3-none-any.whl
const pyodide_kernel_0_2_3_py3_none_any_namespaceObject = __webpack_require__.p + "pypi/pyodide_kernel-0.2.3-py3-none-any.whl";
var pyodide_kernel_0_2_3_py3_none_any_namespaceObject2 = /*#__PURE__*/__webpack_require__.t(pyodide_kernel_0_2_3_py3_none_any_namespaceObject);
;// CONCATENATED MODULE: ./node_modules/@jupyterlite/pyodide-kernel/pypi/widgetsnbextension-3.6.6-py3-none-any.whl
const widgetsnbextension_3_6_6_py3_none_any_namespaceObject = __webpack_require__.p + "pypi/widgetsnbextension-3.6.6-py3-none-any.whl";
var widgetsnbextension_3_6_6_py3_none_any_namespaceObject2 = /*#__PURE__*/__webpack_require__.t(widgetsnbextension_3_6_6_py3_none_any_namespaceObject);
;// CONCATENATED MODULE: ./node_modules/@jupyterlite/pyodide-kernel/pypi/widgetsnbextension-4.0.10-py3-none-any.whl
const widgetsnbextension_4_0_10_py3_none_any_namespaceObject = __webpack_require__.p + "pypi/widgetsnbextension-4.0.10-py3-none-any.whl";
var widgetsnbextension_4_0_10_py3_none_any_namespaceObject2 = /*#__PURE__*/__webpack_require__.t(widgetsnbextension_4_0_10_py3_none_any_namespaceObject);
;// CONCATENATED MODULE: ./node_modules/@jupyterlite/pyodide-kernel/lib/_pypi.js
// this file is autogenerated from the wheels described in ../package.json












// EXTERNAL MODULE: ./node_modules/@lumino/coreutils/dist/index.js
var dist = __webpack_require__(47963);
// EXTERNAL MODULE: ./node_modules/@jupyterlab/coreutils/lib/index.js
var lib = __webpack_require__(48425);
// EXTERNAL MODULE: ./node_modules/@jupyterlab/services/lib/index.js
var services_lib = __webpack_require__(88362);
// EXTERNAL MODULE: ./node_modules/@lumino/signaling/dist/index.es6.js
var index_es6 = __webpack_require__(98209);
;// CONCATENATED MODULE: ./node_modules/@jupyterlite/kernel/lib/kernel.js


/**
 * A base kernel class handling basic kernel messaging.
 */
class BaseKernel {
  /**
   * Construct a new BaseKernel.
   *
   * @param options The instantiation options for a BaseKernel.
   */
  constructor(options) {
    this._history = [];
    this._executionCount = 0;
    this._isDisposed = false;
    this._disposed = new index_es6.Signal(this);
    this._parentHeader = undefined;
    this._parent = undefined;
    const {
      id,
      name,
      location,
      sendMessage
    } = options;
    this._id = id;
    this._name = name;
    this._location = location;
    this._sendMessage = sendMessage;
  }
  /**
   * A promise that is fulfilled when the kernel is ready.
   */
  get ready() {
    return Promise.resolve();
  }
  /**
   * Return whether the kernel is disposed.
   */
  get isDisposed() {
    return this._isDisposed;
  }
  /**
   * A signal emitted when the kernel is disposed.
   */
  get disposed() {
    return this._disposed;
  }
  /**
   * Get the kernel id
   */
  get id() {
    return this._id;
  }
  /**
   * Get the name of the kernel
   */
  get name() {
    return this._name;
  }
  /**
   * The location in the virtual filesystem from which the kernel was started.
   */
  get location() {
    return this._location;
  }
  /**
   * The current execution count
   */
  get executionCount() {
    return this._executionCount;
  }
  /**
   * Get the last parent header
   */
  get parentHeader() {
    return this._parentHeader;
  }
  /**
   * Get the last parent message (mimic ipykernel's get_parent)
   */
  get parent() {
    return this._parent;
  }
  /**
   * Dispose the kernel.
   */
  dispose() {
    if (this.isDisposed) {
      return;
    }
    this._isDisposed = true;
    this._disposed.emit(void 0);
  }
  /**
   * Handle an incoming message from the client.
   *
   * @param msg The message to handle
   */
  async handleMessage(msg) {
    this._busy(msg);
    this._parent = msg;
    const msgType = msg.header.msg_type;
    switch (msgType) {
      case 'kernel_info_request':
        await this._kernelInfo(msg);
        break;
      case 'execute_request':
        await this._execute(msg);
        break;
      case 'input_reply':
        this.inputReply(msg.content);
        break;
      case 'inspect_request':
        await this._inspect(msg);
        break;
      case 'is_complete_request':
        await this._isCompleteRequest(msg);
        break;
      case 'complete_request':
        await this._complete(msg);
        break;
      case 'history_request':
        await this._historyRequest(msg);
        break;
      case 'comm_open':
        await this.commOpen(msg);
        break;
      case 'comm_msg':
        await this.commMsg(msg);
        break;
      case 'comm_close':
        await this.commClose(msg);
        break;
      default:
        break;
    }
    this._idle(msg);
  }
  /**
   * Stream an event from the kernel
   *
   * @param parentHeader The parent header.
   * @param content The stream content.
   */
  stream(content, parentHeader = undefined) {
    var _a;
    const parentHeaderValue = typeof parentHeader !== 'undefined' ? parentHeader : this._parentHeader;
    const message = services_lib.KernelMessage.createMessage({
      channel: 'iopub',
      msgType: 'stream',
      // TODO: better handle this
      session: (_a = parentHeaderValue === null || parentHeaderValue === void 0 ? void 0 : parentHeaderValue.session) !== null && _a !== void 0 ? _a : '',
      parentHeader: parentHeaderValue,
      content
    });
    this._sendMessage(message);
  }
  /**
   * Send a `display_data` message to the client.
   *
   * @param parentHeader The parent header.
   * @param content The display_data content.
   */
  displayData(content, parentHeader = undefined) {
    var _a, _b;
    // Make sure metadata is always set
    const parentHeaderValue = typeof parentHeader !== 'undefined' ? parentHeader : this._parentHeader;
    content.metadata = (_a = content.metadata) !== null && _a !== void 0 ? _a : {};
    const message = services_lib.KernelMessage.createMessage({
      channel: 'iopub',
      msgType: 'display_data',
      // TODO: better handle this
      session: (_b = parentHeaderValue === null || parentHeaderValue === void 0 ? void 0 : parentHeaderValue.session) !== null && _b !== void 0 ? _b : '',
      parentHeader: parentHeaderValue,
      content
    });
    this._sendMessage(message);
  }
  /**
   * Send a `input_request` message to the client.
   *
   * @param parentHeader The parent header.
   * @param content The input_request content.
   */
  inputRequest(content, parentHeader = undefined) {
    var _a;
    const parentHeaderValue = typeof parentHeader !== 'undefined' ? parentHeader : this._parentHeader;
    const message = services_lib.KernelMessage.createMessage({
      channel: 'stdin',
      msgType: 'input_request',
      // TODO: better handle this
      session: (_a = parentHeaderValue === null || parentHeaderValue === void 0 ? void 0 : parentHeaderValue.session) !== null && _a !== void 0 ? _a : '',
      parentHeader: parentHeaderValue,
      content
    });
    this._sendMessage(message);
  }
  /**
   * Send an `execute_result` message.
   *
   * @param parentHeader The parent header.
   * @param content The execute result content.
   */
  publishExecuteResult(content, parentHeader = undefined) {
    var _a;
    const parentHeaderValue = typeof parentHeader !== 'undefined' ? parentHeader : this._parentHeader;
    const message = services_lib.KernelMessage.createMessage({
      channel: 'iopub',
      msgType: 'execute_result',
      // TODO: better handle this
      session: (_a = parentHeaderValue === null || parentHeaderValue === void 0 ? void 0 : parentHeaderValue.session) !== null && _a !== void 0 ? _a : '',
      parentHeader: parentHeaderValue,
      content
    });
    this._sendMessage(message);
  }
  /**
   * Send an `error` message to the client.
   *
   * @param parentHeader The parent header.
   * @param content The error content.
   */
  publishExecuteError(content, parentHeader = undefined) {
    var _a;
    const parentHeaderValue = typeof parentHeader !== 'undefined' ? parentHeader : this._parentHeader;
    const message = services_lib.KernelMessage.createMessage({
      channel: 'iopub',
      msgType: 'error',
      // TODO: better handle this
      session: (_a = parentHeaderValue === null || parentHeaderValue === void 0 ? void 0 : parentHeaderValue.session) !== null && _a !== void 0 ? _a : '',
      parentHeader: parentHeaderValue,
      content
    });
    this._sendMessage(message);
  }
  /**
   * Send a `update_display_data` message to the client.
   *
   * @param parentHeader The parent header.
   * @param content The update_display_data content.
   */
  updateDisplayData(content, parentHeader = undefined) {
    var _a;
    const parentHeaderValue = typeof parentHeader !== 'undefined' ? parentHeader : this._parentHeader;
    const message = services_lib.KernelMessage.createMessage({
      channel: 'iopub',
      msgType: 'update_display_data',
      // TODO: better handle this
      session: (_a = parentHeaderValue === null || parentHeaderValue === void 0 ? void 0 : parentHeaderValue.session) !== null && _a !== void 0 ? _a : '',
      parentHeader: parentHeaderValue,
      content
    });
    this._sendMessage(message);
  }
  /**
   * Send a `clear_output` message to the client.
   *
   * @param parentHeader The parent header.
   * @param content The clear_output content.
   */
  clearOutput(content, parentHeader = undefined) {
    var _a;
    const parentHeaderValue = typeof parentHeader !== 'undefined' ? parentHeader : this._parentHeader;
    const message = services_lib.KernelMessage.createMessage({
      channel: 'iopub',
      msgType: 'clear_output',
      // TODO: better handle this
      session: (_a = parentHeaderValue === null || parentHeaderValue === void 0 ? void 0 : parentHeaderValue.session) !== null && _a !== void 0 ? _a : '',
      parentHeader: parentHeaderValue,
      content
    });
    this._sendMessage(message);
  }
  /**
   * Send a `comm` message to the client.
   *
   * @param .
   */
  handleComm(type, content, metadata, buffers, parentHeader = undefined) {
    var _a;
    const parentHeaderValue = typeof parentHeader !== 'undefined' ? parentHeader : this._parentHeader;
    const message = services_lib.KernelMessage.createMessage({
      channel: 'iopub',
      msgType: type,
      // TODO: better handle this
      session: (_a = parentHeaderValue === null || parentHeaderValue === void 0 ? void 0 : parentHeaderValue.session) !== null && _a !== void 0 ? _a : '',
      parentHeader: parentHeaderValue,
      content,
      metadata,
      buffers
    });
    this._sendMessage(message);
  }
  /**
   * Send an 'idle' status message.
   *
   * @param parent The parent message
   */
  _idle(parent) {
    const message = services_lib.KernelMessage.createMessage({
      msgType: 'status',
      session: parent.header.session,
      parentHeader: parent.header,
      channel: 'iopub',
      content: {
        execution_state: 'idle'
      }
    });
    this._sendMessage(message);
  }
  /**
   * Send a 'busy' status message.
   *
   * @param parent The parent message.
   */
  _busy(parent) {
    const message = services_lib.KernelMessage.createMessage({
      msgType: 'status',
      session: parent.header.session,
      parentHeader: parent.header,
      channel: 'iopub',
      content: {
        execution_state: 'busy'
      }
    });
    this._sendMessage(message);
  }
  /**
   * Handle a kernel_info_request message
   *
   * @param parent The parent message.
   */
  async _kernelInfo(parent) {
    const content = await this.kernelInfoRequest();
    const message = services_lib.KernelMessage.createMessage({
      msgType: 'kernel_info_reply',
      channel: 'shell',
      session: parent.header.session,
      parentHeader: parent.header,
      content
    });
    this._sendMessage(message);
  }
  /**
   * Handle a `history_request` message
   *
   * @param msg The parent message.
   */
  async _historyRequest(msg) {
    const historyMsg = msg;
    const message = services_lib.KernelMessage.createMessage({
      msgType: 'history_reply',
      channel: 'shell',
      parentHeader: historyMsg.header,
      session: msg.header.session,
      content: {
        status: 'ok',
        history: this._history
      }
    });
    this._sendMessage(message);
  }
  /**
   * Send an `execute_input` message.
   *
   * @param msg The parent message.
   */
  _executeInput(msg) {
    const parent = msg;
    const code = parent.content.code;
    const message = services_lib.KernelMessage.createMessage({
      msgType: 'execute_input',
      parentHeader: parent.header,
      channel: 'iopub',
      session: msg.header.session,
      content: {
        code,
        execution_count: this._executionCount
      }
    });
    this._sendMessage(message);
  }
  /**
   * Handle an execute_request message.
   *
   * @param msg The parent message.
   */
  async _execute(msg) {
    const executeMsg = msg;
    const content = executeMsg.content;
    if (content.store_history) {
      this._executionCount++;
    }
    // TODO: handle differently
    this._parentHeader = executeMsg.header;
    this._executeInput(executeMsg);
    if (content.store_history) {
      this._history.push([0, 0, content.code]);
    }
    const reply = await this.executeRequest(executeMsg.content);
    const message = services_lib.KernelMessage.createMessage({
      msgType: 'execute_reply',
      channel: 'shell',
      parentHeader: executeMsg.header,
      session: msg.header.session,
      content: reply
    });
    this._sendMessage(message);
  }
  /**
   * Handle an complete_request message
   *
   * @param msg The parent message.
   */
  async _complete(msg) {
    const completeMsg = msg;
    const content = await this.completeRequest(completeMsg.content);
    const message = services_lib.KernelMessage.createMessage({
      msgType: 'complete_reply',
      parentHeader: completeMsg.header,
      channel: 'shell',
      session: msg.header.session,
      content
    });
    this._sendMessage(message);
  }
  /**
   * Handle an inspect_request message
   *
   * @param msg The parent message.
   */
  async _inspect(msg) {
    const inspectMsg = msg;
    const content = await this.inspectRequest(inspectMsg.content);
    const message = services_lib.KernelMessage.createMessage({
      msgType: 'inspect_reply',
      parentHeader: inspectMsg.header,
      channel: 'shell',
      session: msg.header.session,
      content
    });
    this._sendMessage(message);
  }
  /**
   * Handle an is_complete_request message
   *
   * @param msg The parent message.
   */
  async _isCompleteRequest(msg) {
    const isCompleteMsg = msg;
    const content = await this.isCompleteRequest(isCompleteMsg.content);
    const message = services_lib.KernelMessage.createMessage({
      msgType: 'is_complete_reply',
      parentHeader: isCompleteMsg.header,
      channel: 'shell',
      session: msg.header.session,
      content
    });
    this._sendMessage(message);
  }
}
;// CONCATENATED MODULE: ./node_modules/comlink/dist/esm/comlink.mjs
/**
 * @license
 * Copyright 2019 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const proxyMarker = Symbol("Comlink.proxy");
const createEndpoint = Symbol("Comlink.endpoint");
const releaseProxy = Symbol("Comlink.releaseProxy");
const finalizer = Symbol("Comlink.finalizer");
const throwMarker = Symbol("Comlink.thrown");
const isObject = (val) => (typeof val === "object" && val !== null) || typeof val === "function";
/**
 * Internal transfer handle to handle objects marked to proxy.
 */
const proxyTransferHandler = {
    canHandle: (val) => isObject(val) && val[proxyMarker],
    serialize(obj) {
        const { port1, port2 } = new MessageChannel();
        expose(obj, port1);
        return [port2, [port2]];
    },
    deserialize(port) {
        port.start();
        return wrap(port);
    },
};
/**
 * Internal transfer handler to handle thrown exceptions.
 */
const throwTransferHandler = {
    canHandle: (value) => isObject(value) && throwMarker in value,
    serialize({ value }) {
        let serialized;
        if (value instanceof Error) {
            serialized = {
                isError: true,
                value: {
                    message: value.message,
                    name: value.name,
                    stack: value.stack,
                },
            };
        }
        else {
            serialized = { isError: false, value };
        }
        return [serialized, []];
    },
    deserialize(serialized) {
        if (serialized.isError) {
            throw Object.assign(new Error(serialized.value.message), serialized.value);
        }
        throw serialized.value;
    },
};
/**
 * Allows customizing the serialization of certain values.
 */
const transferHandlers = new Map([
    ["proxy", proxyTransferHandler],
    ["throw", throwTransferHandler],
]);
function isAllowedOrigin(allowedOrigins, origin) {
    for (const allowedOrigin of allowedOrigins) {
        if (origin === allowedOrigin || allowedOrigin === "*") {
            return true;
        }
        if (allowedOrigin instanceof RegExp && allowedOrigin.test(origin)) {
            return true;
        }
    }
    return false;
}
function expose(obj, ep = globalThis, allowedOrigins = ["*"]) {
    ep.addEventListener("message", function callback(ev) {
        if (!ev || !ev.data) {
            return;
        }
        if (!isAllowedOrigin(allowedOrigins, ev.origin)) {
            console.warn(`Invalid origin '${ev.origin}' for comlink proxy`);
            return;
        }
        const { id, type, path } = Object.assign({ path: [] }, ev.data);
        const argumentList = (ev.data.argumentList || []).map(fromWireValue);
        let returnValue;
        try {
            const parent = path.slice(0, -1).reduce((obj, prop) => obj[prop], obj);
            const rawValue = path.reduce((obj, prop) => obj[prop], obj);
            switch (type) {
                case "GET" /* MessageType.GET */:
                    {
                        returnValue = rawValue;
                    }
                    break;
                case "SET" /* MessageType.SET */:
                    {
                        parent[path.slice(-1)[0]] = fromWireValue(ev.data.value);
                        returnValue = true;
                    }
                    break;
                case "APPLY" /* MessageType.APPLY */:
                    {
                        returnValue = rawValue.apply(parent, argumentList);
                    }
                    break;
                case "CONSTRUCT" /* MessageType.CONSTRUCT */:
                    {
                        const value = new rawValue(...argumentList);
                        returnValue = proxy(value);
                    }
                    break;
                case "ENDPOINT" /* MessageType.ENDPOINT */:
                    {
                        const { port1, port2 } = new MessageChannel();
                        expose(obj, port2);
                        returnValue = transfer(port1, [port1]);
                    }
                    break;
                case "RELEASE" /* MessageType.RELEASE */:
                    {
                        returnValue = undefined;
                    }
                    break;
                default:
                    return;
            }
        }
        catch (value) {
            returnValue = { value, [throwMarker]: 0 };
        }
        Promise.resolve(returnValue)
            .catch((value) => {
            return { value, [throwMarker]: 0 };
        })
            .then((returnValue) => {
            const [wireValue, transferables] = toWireValue(returnValue);
            ep.postMessage(Object.assign(Object.assign({}, wireValue), { id }), transferables);
            if (type === "RELEASE" /* MessageType.RELEASE */) {
                // detach and deactive after sending release response above.
                ep.removeEventListener("message", callback);
                closeEndPoint(ep);
                if (finalizer in obj && typeof obj[finalizer] === "function") {
                    obj[finalizer]();
                }
            }
        })
            .catch((error) => {
            // Send Serialization Error To Caller
            const [wireValue, transferables] = toWireValue({
                value: new TypeError("Unserializable return value"),
                [throwMarker]: 0,
            });
            ep.postMessage(Object.assign(Object.assign({}, wireValue), { id }), transferables);
        });
    });
    if (ep.start) {
        ep.start();
    }
}
function isMessagePort(endpoint) {
    return endpoint.constructor.name === "MessagePort";
}
function closeEndPoint(endpoint) {
    if (isMessagePort(endpoint))
        endpoint.close();
}
function wrap(ep, target) {
    return createProxy(ep, [], target);
}
function throwIfProxyReleased(isReleased) {
    if (isReleased) {
        throw new Error("Proxy has been released and is not useable");
    }
}
function releaseEndpoint(ep) {
    return requestResponseMessage(ep, {
        type: "RELEASE" /* MessageType.RELEASE */,
    }).then(() => {
        closeEndPoint(ep);
    });
}
const proxyCounter = new WeakMap();
const proxyFinalizers = "FinalizationRegistry" in globalThis &&
    new FinalizationRegistry((ep) => {
        const newCount = (proxyCounter.get(ep) || 0) - 1;
        proxyCounter.set(ep, newCount);
        if (newCount === 0) {
            releaseEndpoint(ep);
        }
    });
function registerProxy(proxy, ep) {
    const newCount = (proxyCounter.get(ep) || 0) + 1;
    proxyCounter.set(ep, newCount);
    if (proxyFinalizers) {
        proxyFinalizers.register(proxy, ep, proxy);
    }
}
function unregisterProxy(proxy) {
    if (proxyFinalizers) {
        proxyFinalizers.unregister(proxy);
    }
}
function createProxy(ep, path = [], target = function () { }) {
    let isProxyReleased = false;
    const proxy = new Proxy(target, {
        get(_target, prop) {
            throwIfProxyReleased(isProxyReleased);
            if (prop === releaseProxy) {
                return () => {
                    unregisterProxy(proxy);
                    releaseEndpoint(ep);
                    isProxyReleased = true;
                };
            }
            if (prop === "then") {
                if (path.length === 0) {
                    return { then: () => proxy };
                }
                const r = requestResponseMessage(ep, {
                    type: "GET" /* MessageType.GET */,
                    path: path.map((p) => p.toString()),
                }).then(fromWireValue);
                return r.then.bind(r);
            }
            return createProxy(ep, [...path, prop]);
        },
        set(_target, prop, rawValue) {
            throwIfProxyReleased(isProxyReleased);
            // FIXME: ES6 Proxy Handler `set` methods are supposed to return a
            // boolean. To show good will, we return true asynchronously ¯\_(ツ)_/¯
            const [value, transferables] = toWireValue(rawValue);
            return requestResponseMessage(ep, {
                type: "SET" /* MessageType.SET */,
                path: [...path, prop].map((p) => p.toString()),
                value,
            }, transferables).then(fromWireValue);
        },
        apply(_target, _thisArg, rawArgumentList) {
            throwIfProxyReleased(isProxyReleased);
            const last = path[path.length - 1];
            if (last === createEndpoint) {
                return requestResponseMessage(ep, {
                    type: "ENDPOINT" /* MessageType.ENDPOINT */,
                }).then(fromWireValue);
            }
            // We just pretend that `bind()` didn’t happen.
            if (last === "bind") {
                return createProxy(ep, path.slice(0, -1));
            }
            const [argumentList, transferables] = processArguments(rawArgumentList);
            return requestResponseMessage(ep, {
                type: "APPLY" /* MessageType.APPLY */,
                path: path.map((p) => p.toString()),
                argumentList,
            }, transferables).then(fromWireValue);
        },
        construct(_target, rawArgumentList) {
            throwIfProxyReleased(isProxyReleased);
            const [argumentList, transferables] = processArguments(rawArgumentList);
            return requestResponseMessage(ep, {
                type: "CONSTRUCT" /* MessageType.CONSTRUCT */,
                path: path.map((p) => p.toString()),
                argumentList,
            }, transferables).then(fromWireValue);
        },
    });
    registerProxy(proxy, ep);
    return proxy;
}
function myFlat(arr) {
    return Array.prototype.concat.apply([], arr);
}
function processArguments(argumentList) {
    const processed = argumentList.map(toWireValue);
    return [processed.map((v) => v[0]), myFlat(processed.map((v) => v[1]))];
}
const transferCache = new WeakMap();
function transfer(obj, transfers) {
    transferCache.set(obj, transfers);
    return obj;
}
function proxy(obj) {
    return Object.assign(obj, { [proxyMarker]: true });
}
function windowEndpoint(w, context = globalThis, targetOrigin = "*") {
    return {
        postMessage: (msg, transferables) => w.postMessage(msg, targetOrigin, transferables),
        addEventListener: context.addEventListener.bind(context),
        removeEventListener: context.removeEventListener.bind(context),
    };
}
function toWireValue(value) {
    for (const [name, handler] of transferHandlers) {
        if (handler.canHandle(value)) {
            const [serializedValue, transferables] = handler.serialize(value);
            return [
                {
                    type: "HANDLER" /* WireValueType.HANDLER */,
                    name,
                    value: serializedValue,
                },
                transferables,
            ];
        }
    }
    return [
        {
            type: "RAW" /* WireValueType.RAW */,
            value,
        },
        transferCache.get(value) || [],
    ];
}
function fromWireValue(value) {
    switch (value.type) {
        case "HANDLER" /* WireValueType.HANDLER */:
            return transferHandlers.get(value.name).deserialize(value.value);
        case "RAW" /* WireValueType.RAW */:
            return value.value;
    }
}
function requestResponseMessage(ep, msg, transfers) {
    return new Promise((resolve) => {
        const id = generateUUID();
        ep.addEventListener("message", function l(ev) {
            if (!ev.data || !ev.data.id || ev.data.id !== id) {
                return;
            }
            ep.removeEventListener("message", l);
            resolve(ev.data);
        });
        if (ep.start) {
            ep.start();
        }
        ep.postMessage(Object.assign({ id }, msg), transfers);
    });
}
function generateUUID() {
    return new Array(4)
        .fill(0)
        .map(() => Math.floor(Math.random() * Number.MAX_SAFE_INTEGER).toString(16))
        .join("-");
}


//# sourceMappingURL=comlink.mjs.map

;// CONCATENATED MODULE: ./node_modules/@jupyterlite/pyodide-kernel/lib/kernel.js





/**
 * A kernel that executes Python code with Pyodide.
 */
class PyodideKernel extends BaseKernel {
  /**
   * Instantiate a new PyodideKernel
   *
   * @param options The instantiation options for a new PyodideKernel
   */
  constructor(options) {
    super(options);
    this._ready = new dist.PromiseDelegate();
    this._worker = this.initWorker(options);
    this._worker.onmessage = e => this._processWorkerMessage(e.data);
    this._remoteKernel = wrap(this._worker);
    this.initRemote(options);
  }
  /**
   * Load the worker.
   *
   * ### Note
   *
   * Subclasses must implement this typographically almost _exactly_ for
   * webpack to find it.
   */
  initWorker(options) {
    return new Worker(new URL(/* worker import */ __webpack_require__.p + __webpack_require__.u(3596), __webpack_require__.b), {
      type: undefined
    });
  }
  async initRemote(options) {
    const remoteOptions = this.initRemoteOptions(options);
    await this._remoteKernel.initialize(remoteOptions);
    this._ready.resolve();
  }
  initRemoteOptions(options) {
    const {
      pyodideUrl
    } = options;
    const indexUrl = pyodideUrl.slice(0, pyodideUrl.lastIndexOf('/') + 1);
    const baseUrl = lib.PageConfig.getBaseUrl();
    const pipliteUrls = [...(options.pipliteUrls || []), all_namespaceObject];
    const disablePyPIFallback = !!options.disablePyPIFallback;
    return {
      baseUrl,
      pyodideUrl,
      indexUrl,
      pipliteWheelUrl: options.pipliteWheelUrl || piplite_0_2_3_py3_none_any_namespaceObject,
      pipliteUrls,
      disablePyPIFallback,
      location: this.location,
      mountDrive: options.mountDrive
    };
  }
  /**
   * Dispose the kernel.
   */
  dispose() {
    if (this.isDisposed) {
      return;
    }
    this._worker.terminate();
    this._worker = null;
    super.dispose();
  }
  /**
   * A promise that is fulfilled when the kernel is ready.
   */
  get ready() {
    return this._ready.promise;
  }
  /**
   * Process a message coming from the pyodide web worker.
   *
   * @param msg The worker message to process.
   */
  _processWorkerMessage(msg) {
    var _a, _b, _c, _d, _e, _f, _g;
    if (!msg.type) {
      return;
    }
    switch (msg.type) {
      case 'stream':
        {
          const bundle = (_a = msg.bundle) !== null && _a !== void 0 ? _a : {
            name: 'stdout',
            text: ''
          };
          this.stream(bundle, msg.parentHeader);
          break;
        }
      case 'input_request':
        {
          const bundle = (_b = msg.content) !== null && _b !== void 0 ? _b : {
            prompt: '',
            password: false
          };
          this.inputRequest(bundle, msg.parentHeader);
          break;
        }
      case 'display_data':
        {
          const bundle = (_c = msg.bundle) !== null && _c !== void 0 ? _c : {
            data: {},
            metadata: {},
            transient: {}
          };
          this.displayData(bundle, msg.parentHeader);
          break;
        }
      case 'update_display_data':
        {
          const bundle = (_d = msg.bundle) !== null && _d !== void 0 ? _d : {
            data: {},
            metadata: {},
            transient: {}
          };
          this.updateDisplayData(bundle, msg.parentHeader);
          break;
        }
      case 'clear_output':
        {
          const bundle = (_e = msg.bundle) !== null && _e !== void 0 ? _e : {
            wait: false
          };
          this.clearOutput(bundle, msg.parentHeader);
          break;
        }
      case 'execute_result':
        {
          const bundle = (_f = msg.bundle) !== null && _f !== void 0 ? _f : {
            execution_count: 0,
            data: {},
            metadata: {}
          };
          this.publishExecuteResult(bundle, msg.parentHeader);
          break;
        }
      case 'execute_error':
        {
          const bundle = (_g = msg.bundle) !== null && _g !== void 0 ? _g : {
            ename: '',
            evalue: '',
            traceback: []
          };
          this.publishExecuteError(bundle, msg.parentHeader);
          break;
        }
      case 'comm_msg':
      case 'comm_open':
      case 'comm_close':
        {
          this.handleComm(msg.type, msg.content, msg.metadata, msg.buffers, msg.parentHeader);
          break;
        }
    }
  }
  /**
   * Handle a kernel_info_request message
   */
  async kernelInfoRequest() {
    const content = {
      implementation: 'pyodide',
      implementation_version: '0.1.0',
      language_info: {
        codemirror_mode: {
          name: 'python',
          version: 3
        },
        file_extension: '.py',
        mimetype: 'text/x-python',
        name: 'python',
        nbconvert_exporter: 'python',
        pygments_lexer: 'ipython3',
        version: '3.8'
      },
      protocol_version: '5.3',
      status: 'ok',
      banner: 'A WebAssembly-powered Python kernel backed by Pyodide',
      help_links: [{
        text: 'Python (WASM) Kernel',
        url: 'https://pyodide.org'
      }]
    };
    return content;
  }
  /**
   * Handle an `execute_request` message
   *
   * @param msg The parent message.
   */
  async executeRequest(content) {
    await this.ready;
    const result = await this._remoteKernel.execute(content, this.parent);
    result.execution_count = this.executionCount;
    return result;
  }
  /**
   * Handle an complete_request message
   *
   * @param msg The parent message.
   */
  async completeRequest(content) {
    return await this._remoteKernel.complete(content, this.parent);
  }
  /**
   * Handle an `inspect_request` message.
   *
   * @param content - The content of the request.
   *
   * @returns A promise that resolves with the response message.
   */
  async inspectRequest(content) {
    return await this._remoteKernel.inspect(content, this.parent);
  }
  /**
   * Handle an `is_complete_request` message.
   *
   * @param content - The content of the request.
   *
   * @returns A promise that resolves with the response message.
   */
  async isCompleteRequest(content) {
    return await this._remoteKernel.isComplete(content, this.parent);
  }
  /**
   * Handle a `comm_info_request` message.
   *
   * @param content - The content of the request.
   *
   * @returns A promise that resolves with the response message.
   */
  async commInfoRequest(content) {
    return await this._remoteKernel.commInfo(content, this.parent);
  }
  /**
   * Send an `comm_open` message.
   *
   * @param msg - The comm_open message.
   */
  async commOpen(msg) {
    return await this._remoteKernel.commOpen(msg, this.parent);
  }
  /**
   * Send an `comm_msg` message.
   *
   * @param msg - The comm_msg message.
   */
  async commMsg(msg) {
    return await this._remoteKernel.commMsg(msg, this.parent);
  }
  /**
   * Send an `comm_close` message.
   *
   * @param close - The comm_close message.
   */
  async commClose(msg) {
    return await this._remoteKernel.commClose(msg, this.parent);
  }
  /**
   * Send an `input_reply` message.
   *
   * @param content - The content of the reply.
   */
  async inputReply(content) {
    return await this._remoteKernel.inputReply(content, this.parent);
  }
}
;// CONCATENATED MODULE: ./node_modules/@jupyterlite/pyodide-kernel/schema/piplite.v0.schema.json
const piplite_v0_schema_namespaceObject = JSON.parse('{"$schema":"http://json-schema.org/draft-07/schema","$id":"https://jupyterlite-pyodide-kernel.readthedocs.org/en/latest/reference/schema/piplite-v0.html#","title":"PipLite Schema v0","description":"a schema for the warehouse-like API index","$ref":"#/definitions/top","definitions":{"top":{"type":"object","patternProperties":{".*":{"$ref":"#/definitions/a-piplite-project"}}},"a-piplite-project":{"type":"object","description":"a piplite-installable project, with one or more historical releases","properties":{"releases":{"patternProperties":{".*":{"type":"array","items":{"$ref":"#/definitions/a-piplite-distribution"}}}}}},"a-piplite-distribution":{"type":"object","properties":{"comment_text":{"type":"string"},"digests":{"type":"object","properties":{"md5":{"$ref":"#/definitions/an-md5-digest"},"sha256":{"$ref":"#/definitions/a-sha256-digest"}}},"downloads":{"type":"number"},"filename":{"type":"string"},"has_sig":{"type":"boolean"},"md5_digest":{"$ref":"#/definitions/an-md5-digest"},"packagetype":{"type":"string","enum":["bdist_wheel"]},"python_version":{"type":"string"},"requires_python":{"$ref":"#/definitions/string-or-null"},"size":{"type":"number"},"upload_time":{"type":"string","format":"date-time"},"upload_time_iso_8601":{"type":"string","format":"date-time"},"url":{"type":"string","format":"uri"},"yanked":{"type":"boolean"},"yanked_reason":{"$ref":"#/definitions/string-or-null"}}},"string-or-null":{"anyOf":[{"type":"string"},{"type":"null"}]},"an-md5-digest":{"type":"string","pattern":"[a-f0-9]{32}"},"a-sha256-digest":{"type":"string","pattern":"[a-f0-9]{64}"}}}');
var schema_piplite_v0_schema_namespaceObject = /*#__PURE__*/__webpack_require__.t(piplite_v0_schema_namespaceObject, 2);
;// CONCATENATED MODULE: ./node_modules/@jupyterlite/pyodide-kernel/lib/tokens.js
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.
/**
 * The schema for a Warehouse-like index, as used by piplite.
 */


// EXTERNAL MODULE: ./node_modules/@jupyterlite/pyodide-kernel/lib/worker.js
var worker = __webpack_require__(87179);
;// CONCATENATED MODULE: ./node_modules/@jupyterlite/pyodide-kernel/lib/index.js
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.






/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzU4Lmp1cHl0ZXItdmlld2VyLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1Y0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3pWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDaFJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AZGF0YWxheWVyL2p1cHl0ZXItdmlld2VyLy4vbm9kZV9tb2R1bGVzL0BqdXB5dGVybGl0ZS9weW9kaWRlLWtlcm5lbC9saWIvIGxhenkgbmFtZXNwYWNlIG9iamVjdCIsIndlYnBhY2s6Ly9AZGF0YWxheWVyL2p1cHl0ZXItdmlld2VyLy4vbm9kZV9tb2R1bGVzL0BqdXB5dGVybGl0ZS9weW9kaWRlLWtlcm5lbC9saWIvX3B5cGkuanMiLCJ3ZWJwYWNrOi8vQGRhdGFsYXllci9qdXB5dGVyLXZpZXdlci8uL25vZGVfbW9kdWxlcy9AanVweXRlcmxpdGUva2VybmVsL2xpYi9rZXJuZWwuanMiLCJ3ZWJwYWNrOi8vQGRhdGFsYXllci9qdXB5dGVyLXZpZXdlci8uL25vZGVfbW9kdWxlcy9jb21saW5rL2Rpc3QvZXNtL2NvbWxpbmsubWpzIiwid2VicGFjazovL0BkYXRhbGF5ZXIvanVweXRlci12aWV3ZXIvLi9ub2RlX21vZHVsZXMvQGp1cHl0ZXJsaXRlL3B5b2RpZGUta2VybmVsL2xpYi9rZXJuZWwuanMiLCJ3ZWJwYWNrOi8vQGRhdGFsYXllci9qdXB5dGVyLXZpZXdlci8uL25vZGVfbW9kdWxlcy9AanVweXRlcmxpdGUvcHlvZGlkZS1rZXJuZWwvbGliL3Rva2Vucy5qcyIsIndlYnBhY2s6Ly9AZGF0YWxheWVyL2p1cHl0ZXItdmlld2VyLy4vbm9kZV9tb2R1bGVzL0BqdXB5dGVybGl0ZS9weW9kaWRlLWtlcm5lbC9saWIvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gd2VicGFja0VtcHR5QXN5bmNDb250ZXh0KHJlcSkge1xuXHQvLyBIZXJlIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKSBpcyB1c2VkIGluc3RlYWQgb2YgbmV3IFByb21pc2UoKSB0byBwcmV2ZW50XG5cdC8vIHVuY2F1Z2h0IGV4Y2VwdGlvbiBwb3BwaW5nIHVwIGluIGRldnRvb2xzXG5cdHJldHVybiBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpID0+IHtcblx0XHR2YXIgZSA9IG5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIgKyByZXEgKyBcIidcIik7XG5cdFx0ZS5jb2RlID0gJ01PRFVMRV9OT1RfRk9VTkQnO1xuXHRcdHRocm93IGU7XG5cdH0pO1xufVxud2VicGFja0VtcHR5QXN5bmNDb250ZXh0LmtleXMgPSAoKSA9PiAoW10pO1xud2VicGFja0VtcHR5QXN5bmNDb250ZXh0LnJlc29sdmUgPSB3ZWJwYWNrRW1wdHlBc3luY0NvbnRleHQ7XG53ZWJwYWNrRW1wdHlBc3luY0NvbnRleHQuaWQgPSAyNjU7XG5tb2R1bGUuZXhwb3J0cyA9IHdlYnBhY2tFbXB0eUFzeW5jQ29udGV4dDsiLCIvLyB0aGlzIGZpbGUgaXMgYXV0b2dlbmVyYXRlZCBmcm9tIHRoZSB3aGVlbHMgZGVzY3JpYmVkIGluIC4uL3BhY2thZ2UuanNvblxuaW1wb3J0ICogYXMgX2FsbEpTT05VcmwgZnJvbSAnLi4vcHlwaS9hbGwuanNvbic7XG5leHBvcnQgeyBfYWxsSlNPTlVybCBhcyBhbGxKU09OVXJsIH07XG5pbXBvcnQgKiBhcyBfaXB5a2VybmVsV2hlZWxVcmwgZnJvbSAnLi4vcHlwaS9pcHlrZXJuZWwtNi45LjItcHkzLW5vbmUtYW55LndobCc7XG5leHBvcnQgeyBfaXB5a2VybmVsV2hlZWxVcmwgYXMgaXB5a2VybmVsV2hlZWxVcmwgfTtcbmltcG9ydCAqIGFzIF9waXBsaXRlV2hlZWxVcmwgZnJvbSAnLi4vcHlwaS9waXBsaXRlLTAuMi4zLXB5My1ub25lLWFueS53aGwnO1xuZXhwb3J0IHsgX3BpcGxpdGVXaGVlbFVybCBhcyBwaXBsaXRlV2hlZWxVcmwgfTtcbmltcG9ydCAqIGFzIF9weW9kaWRlX2tlcm5lbFdoZWVsVXJsIGZyb20gJy4uL3B5cGkvcHlvZGlkZV9rZXJuZWwtMC4yLjMtcHkzLW5vbmUtYW55LndobCc7XG5leHBvcnQgeyBfcHlvZGlkZV9rZXJuZWxXaGVlbFVybCBhcyBweW9kaWRlX2tlcm5lbFdoZWVsVXJsIH07XG5pbXBvcnQgKiBhcyBfd2lkZ2V0c25iZXh0ZW5zaW9uV2hlZWxVcmwgZnJvbSAnLi4vcHlwaS93aWRnZXRzbmJleHRlbnNpb24tMy42LjYtcHkzLW5vbmUtYW55LndobCc7XG5leHBvcnQgeyBfd2lkZ2V0c25iZXh0ZW5zaW9uV2hlZWxVcmwgYXMgd2lkZ2V0c25iZXh0ZW5zaW9uV2hlZWxVcmwgfTtcbmltcG9ydCAqIGFzIF93aWRnZXRzbmJleHRlbnNpb25XaGVlbFVybDIgZnJvbSAnLi4vcHlwaS93aWRnZXRzbmJleHRlbnNpb24tNC4wLjEwLXB5My1ub25lLWFueS53aGwnO1xuZXhwb3J0IHsgX3dpZGdldHNuYmV4dGVuc2lvbldoZWVsVXJsMiBhcyB3aWRnZXRzbmJleHRlbnNpb25XaGVlbFVybDEgfTsiLCJpbXBvcnQgeyBLZXJuZWxNZXNzYWdlIH0gZnJvbSAnQGp1cHl0ZXJsYWIvc2VydmljZXMnO1xuaW1wb3J0IHsgU2lnbmFsIH0gZnJvbSAnQGx1bWluby9zaWduYWxpbmcnO1xuLyoqXG4gKiBBIGJhc2Uga2VybmVsIGNsYXNzIGhhbmRsaW5nIGJhc2ljIGtlcm5lbCBtZXNzYWdpbmcuXG4gKi9cbmV4cG9ydCBjbGFzcyBCYXNlS2VybmVsIHtcbiAgLyoqXG4gICAqIENvbnN0cnVjdCBhIG5ldyBCYXNlS2VybmVsLlxuICAgKlxuICAgKiBAcGFyYW0gb3B0aW9ucyBUaGUgaW5zdGFudGlhdGlvbiBvcHRpb25zIGZvciBhIEJhc2VLZXJuZWwuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgdGhpcy5faGlzdG9yeSA9IFtdO1xuICAgIHRoaXMuX2V4ZWN1dGlvbkNvdW50ID0gMDtcbiAgICB0aGlzLl9pc0Rpc3Bvc2VkID0gZmFsc2U7XG4gICAgdGhpcy5fZGlzcG9zZWQgPSBuZXcgU2lnbmFsKHRoaXMpO1xuICAgIHRoaXMuX3BhcmVudEhlYWRlciA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9wYXJlbnQgPSB1bmRlZmluZWQ7XG4gICAgY29uc3Qge1xuICAgICAgaWQsXG4gICAgICBuYW1lLFxuICAgICAgbG9jYXRpb24sXG4gICAgICBzZW5kTWVzc2FnZVxuICAgIH0gPSBvcHRpb25zO1xuICAgIHRoaXMuX2lkID0gaWQ7XG4gICAgdGhpcy5fbmFtZSA9IG5hbWU7XG4gICAgdGhpcy5fbG9jYXRpb24gPSBsb2NhdGlvbjtcbiAgICB0aGlzLl9zZW5kTWVzc2FnZSA9IHNlbmRNZXNzYWdlO1xuICB9XG4gIC8qKlxuICAgKiBBIHByb21pc2UgdGhhdCBpcyBmdWxmaWxsZWQgd2hlbiB0aGUga2VybmVsIGlzIHJlYWR5LlxuICAgKi9cbiAgZ2V0IHJlYWR5KCkge1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJuIHdoZXRoZXIgdGhlIGtlcm5lbCBpcyBkaXNwb3NlZC5cbiAgICovXG4gIGdldCBpc0Rpc3Bvc2VkKCkge1xuICAgIHJldHVybiB0aGlzLl9pc0Rpc3Bvc2VkO1xuICB9XG4gIC8qKlxuICAgKiBBIHNpZ25hbCBlbWl0dGVkIHdoZW4gdGhlIGtlcm5lbCBpcyBkaXNwb3NlZC5cbiAgICovXG4gIGdldCBkaXNwb3NlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGlzcG9zZWQ7XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUga2VybmVsIGlkXG4gICAqL1xuICBnZXQgaWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2lkO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIG5hbWUgb2YgdGhlIGtlcm5lbFxuICAgKi9cbiAgZ2V0IG5hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX25hbWU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBsb2NhdGlvbiBpbiB0aGUgdmlydHVhbCBmaWxlc3lzdGVtIGZyb20gd2hpY2ggdGhlIGtlcm5lbCB3YXMgc3RhcnRlZC5cbiAgICovXG4gIGdldCBsb2NhdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fbG9jYXRpb247XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBjdXJyZW50IGV4ZWN1dGlvbiBjb3VudFxuICAgKi9cbiAgZ2V0IGV4ZWN1dGlvbkNvdW50KCkge1xuICAgIHJldHVybiB0aGlzLl9leGVjdXRpb25Db3VudDtcbiAgfVxuICAvKipcbiAgICogR2V0IHRoZSBsYXN0IHBhcmVudCBoZWFkZXJcbiAgICovXG4gIGdldCBwYXJlbnRIZWFkZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BhcmVudEhlYWRlcjtcbiAgfVxuICAvKipcbiAgICogR2V0IHRoZSBsYXN0IHBhcmVudCBtZXNzYWdlIChtaW1pYyBpcHlrZXJuZWwncyBnZXRfcGFyZW50KVxuICAgKi9cbiAgZ2V0IHBhcmVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5fcGFyZW50O1xuICB9XG4gIC8qKlxuICAgKiBEaXNwb3NlIHRoZSBrZXJuZWwuXG4gICAqL1xuICBkaXNwb3NlKCkge1xuICAgIGlmICh0aGlzLmlzRGlzcG9zZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5faXNEaXNwb3NlZCA9IHRydWU7XG4gICAgdGhpcy5fZGlzcG9zZWQuZW1pdCh2b2lkIDApO1xuICB9XG4gIC8qKlxuICAgKiBIYW5kbGUgYW4gaW5jb21pbmcgbWVzc2FnZSBmcm9tIHRoZSBjbGllbnQuXG4gICAqXG4gICAqIEBwYXJhbSBtc2cgVGhlIG1lc3NhZ2UgdG8gaGFuZGxlXG4gICAqL1xuICBhc3luYyBoYW5kbGVNZXNzYWdlKG1zZykge1xuICAgIHRoaXMuX2J1c3kobXNnKTtcbiAgICB0aGlzLl9wYXJlbnQgPSBtc2c7XG4gICAgY29uc3QgbXNnVHlwZSA9IG1zZy5oZWFkZXIubXNnX3R5cGU7XG4gICAgc3dpdGNoIChtc2dUeXBlKSB7XG4gICAgICBjYXNlICdrZXJuZWxfaW5mb19yZXF1ZXN0JzpcbiAgICAgICAgYXdhaXQgdGhpcy5fa2VybmVsSW5mbyhtc2cpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2V4ZWN1dGVfcmVxdWVzdCc6XG4gICAgICAgIGF3YWl0IHRoaXMuX2V4ZWN1dGUobXNnKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdpbnB1dF9yZXBseSc6XG4gICAgICAgIHRoaXMuaW5wdXRSZXBseShtc2cuY29udGVudCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnaW5zcGVjdF9yZXF1ZXN0JzpcbiAgICAgICAgYXdhaXQgdGhpcy5faW5zcGVjdChtc2cpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2lzX2NvbXBsZXRlX3JlcXVlc3QnOlxuICAgICAgICBhd2FpdCB0aGlzLl9pc0NvbXBsZXRlUmVxdWVzdChtc2cpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2NvbXBsZXRlX3JlcXVlc3QnOlxuICAgICAgICBhd2FpdCB0aGlzLl9jb21wbGV0ZShtc2cpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2hpc3RvcnlfcmVxdWVzdCc6XG4gICAgICAgIGF3YWl0IHRoaXMuX2hpc3RvcnlSZXF1ZXN0KG1zZyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnY29tbV9vcGVuJzpcbiAgICAgICAgYXdhaXQgdGhpcy5jb21tT3Blbihtc2cpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2NvbW1fbXNnJzpcbiAgICAgICAgYXdhaXQgdGhpcy5jb21tTXNnKG1zZyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnY29tbV9jbG9zZSc6XG4gICAgICAgIGF3YWl0IHRoaXMuY29tbUNsb3NlKG1zZyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHRoaXMuX2lkbGUobXNnKTtcbiAgfVxuICAvKipcbiAgICogU3RyZWFtIGFuIGV2ZW50IGZyb20gdGhlIGtlcm5lbFxuICAgKlxuICAgKiBAcGFyYW0gcGFyZW50SGVhZGVyIFRoZSBwYXJlbnQgaGVhZGVyLlxuICAgKiBAcGFyYW0gY29udGVudCBUaGUgc3RyZWFtIGNvbnRlbnQuXG4gICAqL1xuICBzdHJlYW0oY29udGVudCwgcGFyZW50SGVhZGVyID0gdW5kZWZpbmVkKSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IHBhcmVudEhlYWRlclZhbHVlID0gdHlwZW9mIHBhcmVudEhlYWRlciAhPT0gJ3VuZGVmaW5lZCcgPyBwYXJlbnRIZWFkZXIgOiB0aGlzLl9wYXJlbnRIZWFkZXI7XG4gICAgY29uc3QgbWVzc2FnZSA9IEtlcm5lbE1lc3NhZ2UuY3JlYXRlTWVzc2FnZSh7XG4gICAgICBjaGFubmVsOiAnaW9wdWInLFxuICAgICAgbXNnVHlwZTogJ3N0cmVhbScsXG4gICAgICAvLyBUT0RPOiBiZXR0ZXIgaGFuZGxlIHRoaXNcbiAgICAgIHNlc3Npb246IChfYSA9IHBhcmVudEhlYWRlclZhbHVlID09PSBudWxsIHx8IHBhcmVudEhlYWRlclZhbHVlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJlbnRIZWFkZXJWYWx1ZS5zZXNzaW9uKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAnJyxcbiAgICAgIHBhcmVudEhlYWRlcjogcGFyZW50SGVhZGVyVmFsdWUsXG4gICAgICBjb250ZW50XG4gICAgfSk7XG4gICAgdGhpcy5fc2VuZE1lc3NhZ2UobWVzc2FnZSk7XG4gIH1cbiAgLyoqXG4gICAqIFNlbmQgYSBgZGlzcGxheV9kYXRhYCBtZXNzYWdlIHRvIHRoZSBjbGllbnQuXG4gICAqXG4gICAqIEBwYXJhbSBwYXJlbnRIZWFkZXIgVGhlIHBhcmVudCBoZWFkZXIuXG4gICAqIEBwYXJhbSBjb250ZW50IFRoZSBkaXNwbGF5X2RhdGEgY29udGVudC5cbiAgICovXG4gIGRpc3BsYXlEYXRhKGNvbnRlbnQsIHBhcmVudEhlYWRlciA9IHVuZGVmaW5lZCkge1xuICAgIHZhciBfYSwgX2I7XG4gICAgLy8gTWFrZSBzdXJlIG1ldGFkYXRhIGlzIGFsd2F5cyBzZXRcbiAgICBjb25zdCBwYXJlbnRIZWFkZXJWYWx1ZSA9IHR5cGVvZiBwYXJlbnRIZWFkZXIgIT09ICd1bmRlZmluZWQnID8gcGFyZW50SGVhZGVyIDogdGhpcy5fcGFyZW50SGVhZGVyO1xuICAgIGNvbnRlbnQubWV0YWRhdGEgPSAoX2EgPSBjb250ZW50Lm1ldGFkYXRhKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB7fTtcbiAgICBjb25zdCBtZXNzYWdlID0gS2VybmVsTWVzc2FnZS5jcmVhdGVNZXNzYWdlKHtcbiAgICAgIGNoYW5uZWw6ICdpb3B1YicsXG4gICAgICBtc2dUeXBlOiAnZGlzcGxheV9kYXRhJyxcbiAgICAgIC8vIFRPRE86IGJldHRlciBoYW5kbGUgdGhpc1xuICAgICAgc2Vzc2lvbjogKF9iID0gcGFyZW50SGVhZGVyVmFsdWUgPT09IG51bGwgfHwgcGFyZW50SGVhZGVyVmFsdWUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmVudEhlYWRlclZhbHVlLnNlc3Npb24pICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6ICcnLFxuICAgICAgcGFyZW50SGVhZGVyOiBwYXJlbnRIZWFkZXJWYWx1ZSxcbiAgICAgIGNvbnRlbnRcbiAgICB9KTtcbiAgICB0aGlzLl9zZW5kTWVzc2FnZShtZXNzYWdlKTtcbiAgfVxuICAvKipcbiAgICogU2VuZCBhIGBpbnB1dF9yZXF1ZXN0YCBtZXNzYWdlIHRvIHRoZSBjbGllbnQuXG4gICAqXG4gICAqIEBwYXJhbSBwYXJlbnRIZWFkZXIgVGhlIHBhcmVudCBoZWFkZXIuXG4gICAqIEBwYXJhbSBjb250ZW50IFRoZSBpbnB1dF9yZXF1ZXN0IGNvbnRlbnQuXG4gICAqL1xuICBpbnB1dFJlcXVlc3QoY29udGVudCwgcGFyZW50SGVhZGVyID0gdW5kZWZpbmVkKSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IHBhcmVudEhlYWRlclZhbHVlID0gdHlwZW9mIHBhcmVudEhlYWRlciAhPT0gJ3VuZGVmaW5lZCcgPyBwYXJlbnRIZWFkZXIgOiB0aGlzLl9wYXJlbnRIZWFkZXI7XG4gICAgY29uc3QgbWVzc2FnZSA9IEtlcm5lbE1lc3NhZ2UuY3JlYXRlTWVzc2FnZSh7XG4gICAgICBjaGFubmVsOiAnc3RkaW4nLFxuICAgICAgbXNnVHlwZTogJ2lucHV0X3JlcXVlc3QnLFxuICAgICAgLy8gVE9ETzogYmV0dGVyIGhhbmRsZSB0aGlzXG4gICAgICBzZXNzaW9uOiAoX2EgPSBwYXJlbnRIZWFkZXJWYWx1ZSA9PT0gbnVsbCB8fCBwYXJlbnRIZWFkZXJWYWx1ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyZW50SGVhZGVyVmFsdWUuc2Vzc2lvbikgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogJycsXG4gICAgICBwYXJlbnRIZWFkZXI6IHBhcmVudEhlYWRlclZhbHVlLFxuICAgICAgY29udGVudFxuICAgIH0pO1xuICAgIHRoaXMuX3NlbmRNZXNzYWdlKG1lc3NhZ2UpO1xuICB9XG4gIC8qKlxuICAgKiBTZW5kIGFuIGBleGVjdXRlX3Jlc3VsdGAgbWVzc2FnZS5cbiAgICpcbiAgICogQHBhcmFtIHBhcmVudEhlYWRlciBUaGUgcGFyZW50IGhlYWRlci5cbiAgICogQHBhcmFtIGNvbnRlbnQgVGhlIGV4ZWN1dGUgcmVzdWx0IGNvbnRlbnQuXG4gICAqL1xuICBwdWJsaXNoRXhlY3V0ZVJlc3VsdChjb250ZW50LCBwYXJlbnRIZWFkZXIgPSB1bmRlZmluZWQpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgcGFyZW50SGVhZGVyVmFsdWUgPSB0eXBlb2YgcGFyZW50SGVhZGVyICE9PSAndW5kZWZpbmVkJyA/IHBhcmVudEhlYWRlciA6IHRoaXMuX3BhcmVudEhlYWRlcjtcbiAgICBjb25zdCBtZXNzYWdlID0gS2VybmVsTWVzc2FnZS5jcmVhdGVNZXNzYWdlKHtcbiAgICAgIGNoYW5uZWw6ICdpb3B1YicsXG4gICAgICBtc2dUeXBlOiAnZXhlY3V0ZV9yZXN1bHQnLFxuICAgICAgLy8gVE9ETzogYmV0dGVyIGhhbmRsZSB0aGlzXG4gICAgICBzZXNzaW9uOiAoX2EgPSBwYXJlbnRIZWFkZXJWYWx1ZSA9PT0gbnVsbCB8fCBwYXJlbnRIZWFkZXJWYWx1ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyZW50SGVhZGVyVmFsdWUuc2Vzc2lvbikgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogJycsXG4gICAgICBwYXJlbnRIZWFkZXI6IHBhcmVudEhlYWRlclZhbHVlLFxuICAgICAgY29udGVudFxuICAgIH0pO1xuICAgIHRoaXMuX3NlbmRNZXNzYWdlKG1lc3NhZ2UpO1xuICB9XG4gIC8qKlxuICAgKiBTZW5kIGFuIGBlcnJvcmAgbWVzc2FnZSB0byB0aGUgY2xpZW50LlxuICAgKlxuICAgKiBAcGFyYW0gcGFyZW50SGVhZGVyIFRoZSBwYXJlbnQgaGVhZGVyLlxuICAgKiBAcGFyYW0gY29udGVudCBUaGUgZXJyb3IgY29udGVudC5cbiAgICovXG4gIHB1Ymxpc2hFeGVjdXRlRXJyb3IoY29udGVudCwgcGFyZW50SGVhZGVyID0gdW5kZWZpbmVkKSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IHBhcmVudEhlYWRlclZhbHVlID0gdHlwZW9mIHBhcmVudEhlYWRlciAhPT0gJ3VuZGVmaW5lZCcgPyBwYXJlbnRIZWFkZXIgOiB0aGlzLl9wYXJlbnRIZWFkZXI7XG4gICAgY29uc3QgbWVzc2FnZSA9IEtlcm5lbE1lc3NhZ2UuY3JlYXRlTWVzc2FnZSh7XG4gICAgICBjaGFubmVsOiAnaW9wdWInLFxuICAgICAgbXNnVHlwZTogJ2Vycm9yJyxcbiAgICAgIC8vIFRPRE86IGJldHRlciBoYW5kbGUgdGhpc1xuICAgICAgc2Vzc2lvbjogKF9hID0gcGFyZW50SGVhZGVyVmFsdWUgPT09IG51bGwgfHwgcGFyZW50SGVhZGVyVmFsdWUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmVudEhlYWRlclZhbHVlLnNlc3Npb24pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICcnLFxuICAgICAgcGFyZW50SGVhZGVyOiBwYXJlbnRIZWFkZXJWYWx1ZSxcbiAgICAgIGNvbnRlbnRcbiAgICB9KTtcbiAgICB0aGlzLl9zZW5kTWVzc2FnZShtZXNzYWdlKTtcbiAgfVxuICAvKipcbiAgICogU2VuZCBhIGB1cGRhdGVfZGlzcGxheV9kYXRhYCBtZXNzYWdlIHRvIHRoZSBjbGllbnQuXG4gICAqXG4gICAqIEBwYXJhbSBwYXJlbnRIZWFkZXIgVGhlIHBhcmVudCBoZWFkZXIuXG4gICAqIEBwYXJhbSBjb250ZW50IFRoZSB1cGRhdGVfZGlzcGxheV9kYXRhIGNvbnRlbnQuXG4gICAqL1xuICB1cGRhdGVEaXNwbGF5RGF0YShjb250ZW50LCBwYXJlbnRIZWFkZXIgPSB1bmRlZmluZWQpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgcGFyZW50SGVhZGVyVmFsdWUgPSB0eXBlb2YgcGFyZW50SGVhZGVyICE9PSAndW5kZWZpbmVkJyA/IHBhcmVudEhlYWRlciA6IHRoaXMuX3BhcmVudEhlYWRlcjtcbiAgICBjb25zdCBtZXNzYWdlID0gS2VybmVsTWVzc2FnZS5jcmVhdGVNZXNzYWdlKHtcbiAgICAgIGNoYW5uZWw6ICdpb3B1YicsXG4gICAgICBtc2dUeXBlOiAndXBkYXRlX2Rpc3BsYXlfZGF0YScsXG4gICAgICAvLyBUT0RPOiBiZXR0ZXIgaGFuZGxlIHRoaXNcbiAgICAgIHNlc3Npb246IChfYSA9IHBhcmVudEhlYWRlclZhbHVlID09PSBudWxsIHx8IHBhcmVudEhlYWRlclZhbHVlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJlbnRIZWFkZXJWYWx1ZS5zZXNzaW9uKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAnJyxcbiAgICAgIHBhcmVudEhlYWRlcjogcGFyZW50SGVhZGVyVmFsdWUsXG4gICAgICBjb250ZW50XG4gICAgfSk7XG4gICAgdGhpcy5fc2VuZE1lc3NhZ2UobWVzc2FnZSk7XG4gIH1cbiAgLyoqXG4gICAqIFNlbmQgYSBgY2xlYXJfb3V0cHV0YCBtZXNzYWdlIHRvIHRoZSBjbGllbnQuXG4gICAqXG4gICAqIEBwYXJhbSBwYXJlbnRIZWFkZXIgVGhlIHBhcmVudCBoZWFkZXIuXG4gICAqIEBwYXJhbSBjb250ZW50IFRoZSBjbGVhcl9vdXRwdXQgY29udGVudC5cbiAgICovXG4gIGNsZWFyT3V0cHV0KGNvbnRlbnQsIHBhcmVudEhlYWRlciA9IHVuZGVmaW5lZCkge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCBwYXJlbnRIZWFkZXJWYWx1ZSA9IHR5cGVvZiBwYXJlbnRIZWFkZXIgIT09ICd1bmRlZmluZWQnID8gcGFyZW50SGVhZGVyIDogdGhpcy5fcGFyZW50SGVhZGVyO1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBLZXJuZWxNZXNzYWdlLmNyZWF0ZU1lc3NhZ2Uoe1xuICAgICAgY2hhbm5lbDogJ2lvcHViJyxcbiAgICAgIG1zZ1R5cGU6ICdjbGVhcl9vdXRwdXQnLFxuICAgICAgLy8gVE9ETzogYmV0dGVyIGhhbmRsZSB0aGlzXG4gICAgICBzZXNzaW9uOiAoX2EgPSBwYXJlbnRIZWFkZXJWYWx1ZSA9PT0gbnVsbCB8fCBwYXJlbnRIZWFkZXJWYWx1ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyZW50SGVhZGVyVmFsdWUuc2Vzc2lvbikgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogJycsXG4gICAgICBwYXJlbnRIZWFkZXI6IHBhcmVudEhlYWRlclZhbHVlLFxuICAgICAgY29udGVudFxuICAgIH0pO1xuICAgIHRoaXMuX3NlbmRNZXNzYWdlKG1lc3NhZ2UpO1xuICB9XG4gIC8qKlxuICAgKiBTZW5kIGEgYGNvbW1gIG1lc3NhZ2UgdG8gdGhlIGNsaWVudC5cbiAgICpcbiAgICogQHBhcmFtIC5cbiAgICovXG4gIGhhbmRsZUNvbW0odHlwZSwgY29udGVudCwgbWV0YWRhdGEsIGJ1ZmZlcnMsIHBhcmVudEhlYWRlciA9IHVuZGVmaW5lZCkge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCBwYXJlbnRIZWFkZXJWYWx1ZSA9IHR5cGVvZiBwYXJlbnRIZWFkZXIgIT09ICd1bmRlZmluZWQnID8gcGFyZW50SGVhZGVyIDogdGhpcy5fcGFyZW50SGVhZGVyO1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBLZXJuZWxNZXNzYWdlLmNyZWF0ZU1lc3NhZ2Uoe1xuICAgICAgY2hhbm5lbDogJ2lvcHViJyxcbiAgICAgIG1zZ1R5cGU6IHR5cGUsXG4gICAgICAvLyBUT0RPOiBiZXR0ZXIgaGFuZGxlIHRoaXNcbiAgICAgIHNlc3Npb246IChfYSA9IHBhcmVudEhlYWRlclZhbHVlID09PSBudWxsIHx8IHBhcmVudEhlYWRlclZhbHVlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJlbnRIZWFkZXJWYWx1ZS5zZXNzaW9uKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAnJyxcbiAgICAgIHBhcmVudEhlYWRlcjogcGFyZW50SGVhZGVyVmFsdWUsXG4gICAgICBjb250ZW50LFxuICAgICAgbWV0YWRhdGEsXG4gICAgICBidWZmZXJzXG4gICAgfSk7XG4gICAgdGhpcy5fc2VuZE1lc3NhZ2UobWVzc2FnZSk7XG4gIH1cbiAgLyoqXG4gICAqIFNlbmQgYW4gJ2lkbGUnIHN0YXR1cyBtZXNzYWdlLlxuICAgKlxuICAgKiBAcGFyYW0gcGFyZW50IFRoZSBwYXJlbnQgbWVzc2FnZVxuICAgKi9cbiAgX2lkbGUocGFyZW50KSB7XG4gICAgY29uc3QgbWVzc2FnZSA9IEtlcm5lbE1lc3NhZ2UuY3JlYXRlTWVzc2FnZSh7XG4gICAgICBtc2dUeXBlOiAnc3RhdHVzJyxcbiAgICAgIHNlc3Npb246IHBhcmVudC5oZWFkZXIuc2Vzc2lvbixcbiAgICAgIHBhcmVudEhlYWRlcjogcGFyZW50LmhlYWRlcixcbiAgICAgIGNoYW5uZWw6ICdpb3B1YicsXG4gICAgICBjb250ZW50OiB7XG4gICAgICAgIGV4ZWN1dGlvbl9zdGF0ZTogJ2lkbGUnXG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5fc2VuZE1lc3NhZ2UobWVzc2FnZSk7XG4gIH1cbiAgLyoqXG4gICAqIFNlbmQgYSAnYnVzeScgc3RhdHVzIG1lc3NhZ2UuXG4gICAqXG4gICAqIEBwYXJhbSBwYXJlbnQgVGhlIHBhcmVudCBtZXNzYWdlLlxuICAgKi9cbiAgX2J1c3kocGFyZW50KSB7XG4gICAgY29uc3QgbWVzc2FnZSA9IEtlcm5lbE1lc3NhZ2UuY3JlYXRlTWVzc2FnZSh7XG4gICAgICBtc2dUeXBlOiAnc3RhdHVzJyxcbiAgICAgIHNlc3Npb246IHBhcmVudC5oZWFkZXIuc2Vzc2lvbixcbiAgICAgIHBhcmVudEhlYWRlcjogcGFyZW50LmhlYWRlcixcbiAgICAgIGNoYW5uZWw6ICdpb3B1YicsXG4gICAgICBjb250ZW50OiB7XG4gICAgICAgIGV4ZWN1dGlvbl9zdGF0ZTogJ2J1c3knXG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5fc2VuZE1lc3NhZ2UobWVzc2FnZSk7XG4gIH1cbiAgLyoqXG4gICAqIEhhbmRsZSBhIGtlcm5lbF9pbmZvX3JlcXVlc3QgbWVzc2FnZVxuICAgKlxuICAgKiBAcGFyYW0gcGFyZW50IFRoZSBwYXJlbnQgbWVzc2FnZS5cbiAgICovXG4gIGFzeW5jIF9rZXJuZWxJbmZvKHBhcmVudCkge1xuICAgIGNvbnN0IGNvbnRlbnQgPSBhd2FpdCB0aGlzLmtlcm5lbEluZm9SZXF1ZXN0KCk7XG4gICAgY29uc3QgbWVzc2FnZSA9IEtlcm5lbE1lc3NhZ2UuY3JlYXRlTWVzc2FnZSh7XG4gICAgICBtc2dUeXBlOiAna2VybmVsX2luZm9fcmVwbHknLFxuICAgICAgY2hhbm5lbDogJ3NoZWxsJyxcbiAgICAgIHNlc3Npb246IHBhcmVudC5oZWFkZXIuc2Vzc2lvbixcbiAgICAgIHBhcmVudEhlYWRlcjogcGFyZW50LmhlYWRlcixcbiAgICAgIGNvbnRlbnRcbiAgICB9KTtcbiAgICB0aGlzLl9zZW5kTWVzc2FnZShtZXNzYWdlKTtcbiAgfVxuICAvKipcbiAgICogSGFuZGxlIGEgYGhpc3RvcnlfcmVxdWVzdGAgbWVzc2FnZVxuICAgKlxuICAgKiBAcGFyYW0gbXNnIFRoZSBwYXJlbnQgbWVzc2FnZS5cbiAgICovXG4gIGFzeW5jIF9oaXN0b3J5UmVxdWVzdChtc2cpIHtcbiAgICBjb25zdCBoaXN0b3J5TXNnID0gbXNnO1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBLZXJuZWxNZXNzYWdlLmNyZWF0ZU1lc3NhZ2Uoe1xuICAgICAgbXNnVHlwZTogJ2hpc3RvcnlfcmVwbHknLFxuICAgICAgY2hhbm5lbDogJ3NoZWxsJyxcbiAgICAgIHBhcmVudEhlYWRlcjogaGlzdG9yeU1zZy5oZWFkZXIsXG4gICAgICBzZXNzaW9uOiBtc2cuaGVhZGVyLnNlc3Npb24sXG4gICAgICBjb250ZW50OiB7XG4gICAgICAgIHN0YXR1czogJ29rJyxcbiAgICAgICAgaGlzdG9yeTogdGhpcy5faGlzdG9yeVxuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuX3NlbmRNZXNzYWdlKG1lc3NhZ2UpO1xuICB9XG4gIC8qKlxuICAgKiBTZW5kIGFuIGBleGVjdXRlX2lucHV0YCBtZXNzYWdlLlxuICAgKlxuICAgKiBAcGFyYW0gbXNnIFRoZSBwYXJlbnQgbWVzc2FnZS5cbiAgICovXG4gIF9leGVjdXRlSW5wdXQobXNnKSB7XG4gICAgY29uc3QgcGFyZW50ID0gbXNnO1xuICAgIGNvbnN0IGNvZGUgPSBwYXJlbnQuY29udGVudC5jb2RlO1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBLZXJuZWxNZXNzYWdlLmNyZWF0ZU1lc3NhZ2Uoe1xuICAgICAgbXNnVHlwZTogJ2V4ZWN1dGVfaW5wdXQnLFxuICAgICAgcGFyZW50SGVhZGVyOiBwYXJlbnQuaGVhZGVyLFxuICAgICAgY2hhbm5lbDogJ2lvcHViJyxcbiAgICAgIHNlc3Npb246IG1zZy5oZWFkZXIuc2Vzc2lvbixcbiAgICAgIGNvbnRlbnQ6IHtcbiAgICAgICAgY29kZSxcbiAgICAgICAgZXhlY3V0aW9uX2NvdW50OiB0aGlzLl9leGVjdXRpb25Db3VudFxuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuX3NlbmRNZXNzYWdlKG1lc3NhZ2UpO1xuICB9XG4gIC8qKlxuICAgKiBIYW5kbGUgYW4gZXhlY3V0ZV9yZXF1ZXN0IG1lc3NhZ2UuXG4gICAqXG4gICAqIEBwYXJhbSBtc2cgVGhlIHBhcmVudCBtZXNzYWdlLlxuICAgKi9cbiAgYXN5bmMgX2V4ZWN1dGUobXNnKSB7XG4gICAgY29uc3QgZXhlY3V0ZU1zZyA9IG1zZztcbiAgICBjb25zdCBjb250ZW50ID0gZXhlY3V0ZU1zZy5jb250ZW50O1xuICAgIGlmIChjb250ZW50LnN0b3JlX2hpc3RvcnkpIHtcbiAgICAgIHRoaXMuX2V4ZWN1dGlvbkNvdW50Kys7XG4gICAgfVxuICAgIC8vIFRPRE86IGhhbmRsZSBkaWZmZXJlbnRseVxuICAgIHRoaXMuX3BhcmVudEhlYWRlciA9IGV4ZWN1dGVNc2cuaGVhZGVyO1xuICAgIHRoaXMuX2V4ZWN1dGVJbnB1dChleGVjdXRlTXNnKTtcbiAgICBpZiAoY29udGVudC5zdG9yZV9oaXN0b3J5KSB7XG4gICAgICB0aGlzLl9oaXN0b3J5LnB1c2goWzAsIDAsIGNvbnRlbnQuY29kZV0pO1xuICAgIH1cbiAgICBjb25zdCByZXBseSA9IGF3YWl0IHRoaXMuZXhlY3V0ZVJlcXVlc3QoZXhlY3V0ZU1zZy5jb250ZW50KTtcbiAgICBjb25zdCBtZXNzYWdlID0gS2VybmVsTWVzc2FnZS5jcmVhdGVNZXNzYWdlKHtcbiAgICAgIG1zZ1R5cGU6ICdleGVjdXRlX3JlcGx5JyxcbiAgICAgIGNoYW5uZWw6ICdzaGVsbCcsXG4gICAgICBwYXJlbnRIZWFkZXI6IGV4ZWN1dGVNc2cuaGVhZGVyLFxuICAgICAgc2Vzc2lvbjogbXNnLmhlYWRlci5zZXNzaW9uLFxuICAgICAgY29udGVudDogcmVwbHlcbiAgICB9KTtcbiAgICB0aGlzLl9zZW5kTWVzc2FnZShtZXNzYWdlKTtcbiAgfVxuICAvKipcbiAgICogSGFuZGxlIGFuIGNvbXBsZXRlX3JlcXVlc3QgbWVzc2FnZVxuICAgKlxuICAgKiBAcGFyYW0gbXNnIFRoZSBwYXJlbnQgbWVzc2FnZS5cbiAgICovXG4gIGFzeW5jIF9jb21wbGV0ZShtc2cpIHtcbiAgICBjb25zdCBjb21wbGV0ZU1zZyA9IG1zZztcbiAgICBjb25zdCBjb250ZW50ID0gYXdhaXQgdGhpcy5jb21wbGV0ZVJlcXVlc3QoY29tcGxldGVNc2cuY29udGVudCk7XG4gICAgY29uc3QgbWVzc2FnZSA9IEtlcm5lbE1lc3NhZ2UuY3JlYXRlTWVzc2FnZSh7XG4gICAgICBtc2dUeXBlOiAnY29tcGxldGVfcmVwbHknLFxuICAgICAgcGFyZW50SGVhZGVyOiBjb21wbGV0ZU1zZy5oZWFkZXIsXG4gICAgICBjaGFubmVsOiAnc2hlbGwnLFxuICAgICAgc2Vzc2lvbjogbXNnLmhlYWRlci5zZXNzaW9uLFxuICAgICAgY29udGVudFxuICAgIH0pO1xuICAgIHRoaXMuX3NlbmRNZXNzYWdlKG1lc3NhZ2UpO1xuICB9XG4gIC8qKlxuICAgKiBIYW5kbGUgYW4gaW5zcGVjdF9yZXF1ZXN0IG1lc3NhZ2VcbiAgICpcbiAgICogQHBhcmFtIG1zZyBUaGUgcGFyZW50IG1lc3NhZ2UuXG4gICAqL1xuICBhc3luYyBfaW5zcGVjdChtc2cpIHtcbiAgICBjb25zdCBpbnNwZWN0TXNnID0gbXNnO1xuICAgIGNvbnN0IGNvbnRlbnQgPSBhd2FpdCB0aGlzLmluc3BlY3RSZXF1ZXN0KGluc3BlY3RNc2cuY29udGVudCk7XG4gICAgY29uc3QgbWVzc2FnZSA9IEtlcm5lbE1lc3NhZ2UuY3JlYXRlTWVzc2FnZSh7XG4gICAgICBtc2dUeXBlOiAnaW5zcGVjdF9yZXBseScsXG4gICAgICBwYXJlbnRIZWFkZXI6IGluc3BlY3RNc2cuaGVhZGVyLFxuICAgICAgY2hhbm5lbDogJ3NoZWxsJyxcbiAgICAgIHNlc3Npb246IG1zZy5oZWFkZXIuc2Vzc2lvbixcbiAgICAgIGNvbnRlbnRcbiAgICB9KTtcbiAgICB0aGlzLl9zZW5kTWVzc2FnZShtZXNzYWdlKTtcbiAgfVxuICAvKipcbiAgICogSGFuZGxlIGFuIGlzX2NvbXBsZXRlX3JlcXVlc3QgbWVzc2FnZVxuICAgKlxuICAgKiBAcGFyYW0gbXNnIFRoZSBwYXJlbnQgbWVzc2FnZS5cbiAgICovXG4gIGFzeW5jIF9pc0NvbXBsZXRlUmVxdWVzdChtc2cpIHtcbiAgICBjb25zdCBpc0NvbXBsZXRlTXNnID0gbXNnO1xuICAgIGNvbnN0IGNvbnRlbnQgPSBhd2FpdCB0aGlzLmlzQ29tcGxldGVSZXF1ZXN0KGlzQ29tcGxldGVNc2cuY29udGVudCk7XG4gICAgY29uc3QgbWVzc2FnZSA9IEtlcm5lbE1lc3NhZ2UuY3JlYXRlTWVzc2FnZSh7XG4gICAgICBtc2dUeXBlOiAnaXNfY29tcGxldGVfcmVwbHknLFxuICAgICAgcGFyZW50SGVhZGVyOiBpc0NvbXBsZXRlTXNnLmhlYWRlcixcbiAgICAgIGNoYW5uZWw6ICdzaGVsbCcsXG4gICAgICBzZXNzaW9uOiBtc2cuaGVhZGVyLnNlc3Npb24sXG4gICAgICBjb250ZW50XG4gICAgfSk7XG4gICAgdGhpcy5fc2VuZE1lc3NhZ2UobWVzc2FnZSk7XG4gIH1cbn0iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG5jb25zdCBwcm94eU1hcmtlciA9IFN5bWJvbChcIkNvbWxpbmsucHJveHlcIik7XG5jb25zdCBjcmVhdGVFbmRwb2ludCA9IFN5bWJvbChcIkNvbWxpbmsuZW5kcG9pbnRcIik7XG5jb25zdCByZWxlYXNlUHJveHkgPSBTeW1ib2woXCJDb21saW5rLnJlbGVhc2VQcm94eVwiKTtcbmNvbnN0IGZpbmFsaXplciA9IFN5bWJvbChcIkNvbWxpbmsuZmluYWxpemVyXCIpO1xuY29uc3QgdGhyb3dNYXJrZXIgPSBTeW1ib2woXCJDb21saW5rLnRocm93blwiKTtcbmNvbnN0IGlzT2JqZWN0ID0gKHZhbCkgPT4gKHR5cGVvZiB2YWwgPT09IFwib2JqZWN0XCIgJiYgdmFsICE9PSBudWxsKSB8fCB0eXBlb2YgdmFsID09PSBcImZ1bmN0aW9uXCI7XG4vKipcbiAqIEludGVybmFsIHRyYW5zZmVyIGhhbmRsZSB0byBoYW5kbGUgb2JqZWN0cyBtYXJrZWQgdG8gcHJveHkuXG4gKi9cbmNvbnN0IHByb3h5VHJhbnNmZXJIYW5kbGVyID0ge1xuICAgIGNhbkhhbmRsZTogKHZhbCkgPT4gaXNPYmplY3QodmFsKSAmJiB2YWxbcHJveHlNYXJrZXJdLFxuICAgIHNlcmlhbGl6ZShvYmopIHtcbiAgICAgICAgY29uc3QgeyBwb3J0MSwgcG9ydDIgfSA9IG5ldyBNZXNzYWdlQ2hhbm5lbCgpO1xuICAgICAgICBleHBvc2Uob2JqLCBwb3J0MSk7XG4gICAgICAgIHJldHVybiBbcG9ydDIsIFtwb3J0Ml1dO1xuICAgIH0sXG4gICAgZGVzZXJpYWxpemUocG9ydCkge1xuICAgICAgICBwb3J0LnN0YXJ0KCk7XG4gICAgICAgIHJldHVybiB3cmFwKHBvcnQpO1xuICAgIH0sXG59O1xuLyoqXG4gKiBJbnRlcm5hbCB0cmFuc2ZlciBoYW5kbGVyIHRvIGhhbmRsZSB0aHJvd24gZXhjZXB0aW9ucy5cbiAqL1xuY29uc3QgdGhyb3dUcmFuc2ZlckhhbmRsZXIgPSB7XG4gICAgY2FuSGFuZGxlOiAodmFsdWUpID0+IGlzT2JqZWN0KHZhbHVlKSAmJiB0aHJvd01hcmtlciBpbiB2YWx1ZSxcbiAgICBzZXJpYWxpemUoeyB2YWx1ZSB9KSB7XG4gICAgICAgIGxldCBzZXJpYWxpemVkO1xuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgc2VyaWFsaXplZCA9IHtcbiAgICAgICAgICAgICAgICBpc0Vycm9yOiB0cnVlLFxuICAgICAgICAgICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IHZhbHVlLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IHZhbHVlLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgIHN0YWNrOiB2YWx1ZS5zdGFjayxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNlcmlhbGl6ZWQgPSB7IGlzRXJyb3I6IGZhbHNlLCB2YWx1ZSB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbc2VyaWFsaXplZCwgW11dO1xuICAgIH0sXG4gICAgZGVzZXJpYWxpemUoc2VyaWFsaXplZCkge1xuICAgICAgICBpZiAoc2VyaWFsaXplZC5pc0Vycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBPYmplY3QuYXNzaWduKG5ldyBFcnJvcihzZXJpYWxpemVkLnZhbHVlLm1lc3NhZ2UpLCBzZXJpYWxpemVkLnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBzZXJpYWxpemVkLnZhbHVlO1xuICAgIH0sXG59O1xuLyoqXG4gKiBBbGxvd3MgY3VzdG9taXppbmcgdGhlIHNlcmlhbGl6YXRpb24gb2YgY2VydGFpbiB2YWx1ZXMuXG4gKi9cbmNvbnN0IHRyYW5zZmVySGFuZGxlcnMgPSBuZXcgTWFwKFtcbiAgICBbXCJwcm94eVwiLCBwcm94eVRyYW5zZmVySGFuZGxlcl0sXG4gICAgW1widGhyb3dcIiwgdGhyb3dUcmFuc2ZlckhhbmRsZXJdLFxuXSk7XG5mdW5jdGlvbiBpc0FsbG93ZWRPcmlnaW4oYWxsb3dlZE9yaWdpbnMsIG9yaWdpbikge1xuICAgIGZvciAoY29uc3QgYWxsb3dlZE9yaWdpbiBvZiBhbGxvd2VkT3JpZ2lucykge1xuICAgICAgICBpZiAob3JpZ2luID09PSBhbGxvd2VkT3JpZ2luIHx8IGFsbG93ZWRPcmlnaW4gPT09IFwiKlwiKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYWxsb3dlZE9yaWdpbiBpbnN0YW5jZW9mIFJlZ0V4cCAmJiBhbGxvd2VkT3JpZ2luLnRlc3Qob3JpZ2luKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gZXhwb3NlKG9iaiwgZXAgPSBnbG9iYWxUaGlzLCBhbGxvd2VkT3JpZ2lucyA9IFtcIipcIl0pIHtcbiAgICBlcC5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBmdW5jdGlvbiBjYWxsYmFjayhldikge1xuICAgICAgICBpZiAoIWV2IHx8ICFldi5kYXRhKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc0FsbG93ZWRPcmlnaW4oYWxsb3dlZE9yaWdpbnMsIGV2Lm9yaWdpbikpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgSW52YWxpZCBvcmlnaW4gJyR7ZXYub3JpZ2lufScgZm9yIGNvbWxpbmsgcHJveHlgKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IGlkLCB0eXBlLCBwYXRoIH0gPSBPYmplY3QuYXNzaWduKHsgcGF0aDogW10gfSwgZXYuZGF0YSk7XG4gICAgICAgIGNvbnN0IGFyZ3VtZW50TGlzdCA9IChldi5kYXRhLmFyZ3VtZW50TGlzdCB8fCBbXSkubWFwKGZyb21XaXJlVmFsdWUpO1xuICAgICAgICBsZXQgcmV0dXJuVmFsdWU7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBwYXJlbnQgPSBwYXRoLnNsaWNlKDAsIC0xKS5yZWR1Y2UoKG9iaiwgcHJvcCkgPT4gb2JqW3Byb3BdLCBvYmopO1xuICAgICAgICAgICAgY29uc3QgcmF3VmFsdWUgPSBwYXRoLnJlZHVjZSgob2JqLCBwcm9wKSA9PiBvYmpbcHJvcF0sIG9iaik7XG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwiR0VUXCIgLyogTWVzc2FnZVR5cGUuR0VUICovOlxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm5WYWx1ZSA9IHJhd1ZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJTRVRcIiAvKiBNZXNzYWdlVHlwZS5TRVQgKi86XG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudFtwYXRoLnNsaWNlKC0xKVswXV0gPSBmcm9tV2lyZVZhbHVlKGV2LmRhdGEudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuVmFsdWUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJBUFBMWVwiIC8qIE1lc3NhZ2VUeXBlLkFQUExZICovOlxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm5WYWx1ZSA9IHJhd1ZhbHVlLmFwcGx5KHBhcmVudCwgYXJndW1lbnRMaXN0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwiQ09OU1RSVUNUXCIgLyogTWVzc2FnZVR5cGUuQ09OU1RSVUNUICovOlxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IG5ldyByYXdWYWx1ZSguLi5hcmd1bWVudExpc3QpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuVmFsdWUgPSBwcm94eSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcIkVORFBPSU5UXCIgLyogTWVzc2FnZVR5cGUuRU5EUE9JTlQgKi86XG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgcG9ydDEsIHBvcnQyIH0gPSBuZXcgTWVzc2FnZUNoYW5uZWwoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cG9zZShvYmosIHBvcnQyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVyblZhbHVlID0gdHJhbnNmZXIocG9ydDEsIFtwb3J0MV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJSRUxFQVNFXCIgLyogTWVzc2FnZVR5cGUuUkVMRUFTRSAqLzpcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuVmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoICh2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuVmFsdWUgPSB7IHZhbHVlLCBbdGhyb3dNYXJrZXJdOiAwIH07XG4gICAgICAgIH1cbiAgICAgICAgUHJvbWlzZS5yZXNvbHZlKHJldHVyblZhbHVlKVxuICAgICAgICAgICAgLmNhdGNoKCh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWUsIFt0aHJvd01hcmtlcl06IDAgfTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC50aGVuKChyZXR1cm5WYWx1ZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgW3dpcmVWYWx1ZSwgdHJhbnNmZXJhYmxlc10gPSB0b1dpcmVWYWx1ZShyZXR1cm5WYWx1ZSk7XG4gICAgICAgICAgICBlcC5wb3N0TWVzc2FnZShPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHdpcmVWYWx1ZSksIHsgaWQgfSksIHRyYW5zZmVyYWJsZXMpO1xuICAgICAgICAgICAgaWYgKHR5cGUgPT09IFwiUkVMRUFTRVwiIC8qIE1lc3NhZ2VUeXBlLlJFTEVBU0UgKi8pIHtcbiAgICAgICAgICAgICAgICAvLyBkZXRhY2ggYW5kIGRlYWN0aXZlIGFmdGVyIHNlbmRpbmcgcmVsZWFzZSByZXNwb25zZSBhYm92ZS5cbiAgICAgICAgICAgICAgICBlcC5yZW1vdmVFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBjYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgY2xvc2VFbmRQb2ludChlcCk7XG4gICAgICAgICAgICAgICAgaWYgKGZpbmFsaXplciBpbiBvYmogJiYgdHlwZW9mIG9ialtmaW5hbGl6ZXJdID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgb2JqW2ZpbmFsaXplcl0oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICAgICAgICAuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICAgICAgICAvLyBTZW5kIFNlcmlhbGl6YXRpb24gRXJyb3IgVG8gQ2FsbGVyXG4gICAgICAgICAgICBjb25zdCBbd2lyZVZhbHVlLCB0cmFuc2ZlcmFibGVzXSA9IHRvV2lyZVZhbHVlKHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogbmV3IFR5cGVFcnJvcihcIlVuc2VyaWFsaXphYmxlIHJldHVybiB2YWx1ZVwiKSxcbiAgICAgICAgICAgICAgICBbdGhyb3dNYXJrZXJdOiAwLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBlcC5wb3N0TWVzc2FnZShPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHdpcmVWYWx1ZSksIHsgaWQgfSksIHRyYW5zZmVyYWJsZXMpO1xuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICBpZiAoZXAuc3RhcnQpIHtcbiAgICAgICAgZXAuc3RhcnQoKTtcbiAgICB9XG59XG5mdW5jdGlvbiBpc01lc3NhZ2VQb3J0KGVuZHBvaW50KSB7XG4gICAgcmV0dXJuIGVuZHBvaW50LmNvbnN0cnVjdG9yLm5hbWUgPT09IFwiTWVzc2FnZVBvcnRcIjtcbn1cbmZ1bmN0aW9uIGNsb3NlRW5kUG9pbnQoZW5kcG9pbnQpIHtcbiAgICBpZiAoaXNNZXNzYWdlUG9ydChlbmRwb2ludCkpXG4gICAgICAgIGVuZHBvaW50LmNsb3NlKCk7XG59XG5mdW5jdGlvbiB3cmFwKGVwLCB0YXJnZXQpIHtcbiAgICByZXR1cm4gY3JlYXRlUHJveHkoZXAsIFtdLCB0YXJnZXQpO1xufVxuZnVuY3Rpb24gdGhyb3dJZlByb3h5UmVsZWFzZWQoaXNSZWxlYXNlZCkge1xuICAgIGlmIChpc1JlbGVhc2VkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlByb3h5IGhhcyBiZWVuIHJlbGVhc2VkIGFuZCBpcyBub3QgdXNlYWJsZVwiKTtcbiAgICB9XG59XG5mdW5jdGlvbiByZWxlYXNlRW5kcG9pbnQoZXApIHtcbiAgICByZXR1cm4gcmVxdWVzdFJlc3BvbnNlTWVzc2FnZShlcCwge1xuICAgICAgICB0eXBlOiBcIlJFTEVBU0VcIiAvKiBNZXNzYWdlVHlwZS5SRUxFQVNFICovLFxuICAgIH0pLnRoZW4oKCkgPT4ge1xuICAgICAgICBjbG9zZUVuZFBvaW50KGVwKTtcbiAgICB9KTtcbn1cbmNvbnN0IHByb3h5Q291bnRlciA9IG5ldyBXZWFrTWFwKCk7XG5jb25zdCBwcm94eUZpbmFsaXplcnMgPSBcIkZpbmFsaXphdGlvblJlZ2lzdHJ5XCIgaW4gZ2xvYmFsVGhpcyAmJlxuICAgIG5ldyBGaW5hbGl6YXRpb25SZWdpc3RyeSgoZXApID0+IHtcbiAgICAgICAgY29uc3QgbmV3Q291bnQgPSAocHJveHlDb3VudGVyLmdldChlcCkgfHwgMCkgLSAxO1xuICAgICAgICBwcm94eUNvdW50ZXIuc2V0KGVwLCBuZXdDb3VudCk7XG4gICAgICAgIGlmIChuZXdDb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgcmVsZWFzZUVuZHBvaW50KGVwKTtcbiAgICAgICAgfVxuICAgIH0pO1xuZnVuY3Rpb24gcmVnaXN0ZXJQcm94eShwcm94eSwgZXApIHtcbiAgICBjb25zdCBuZXdDb3VudCA9IChwcm94eUNvdW50ZXIuZ2V0KGVwKSB8fCAwKSArIDE7XG4gICAgcHJveHlDb3VudGVyLnNldChlcCwgbmV3Q291bnQpO1xuICAgIGlmIChwcm94eUZpbmFsaXplcnMpIHtcbiAgICAgICAgcHJveHlGaW5hbGl6ZXJzLnJlZ2lzdGVyKHByb3h5LCBlcCwgcHJveHkpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHVucmVnaXN0ZXJQcm94eShwcm94eSkge1xuICAgIGlmIChwcm94eUZpbmFsaXplcnMpIHtcbiAgICAgICAgcHJveHlGaW5hbGl6ZXJzLnVucmVnaXN0ZXIocHJveHkpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNyZWF0ZVByb3h5KGVwLCBwYXRoID0gW10sIHRhcmdldCA9IGZ1bmN0aW9uICgpIHsgfSkge1xuICAgIGxldCBpc1Byb3h5UmVsZWFzZWQgPSBmYWxzZTtcbiAgICBjb25zdCBwcm94eSA9IG5ldyBQcm94eSh0YXJnZXQsIHtcbiAgICAgICAgZ2V0KF90YXJnZXQsIHByb3ApIHtcbiAgICAgICAgICAgIHRocm93SWZQcm94eVJlbGVhc2VkKGlzUHJveHlSZWxlYXNlZCk7XG4gICAgICAgICAgICBpZiAocHJvcCA9PT0gcmVsZWFzZVByb3h5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdW5yZWdpc3RlclByb3h5KHByb3h5KTtcbiAgICAgICAgICAgICAgICAgICAgcmVsZWFzZUVuZHBvaW50KGVwKTtcbiAgICAgICAgICAgICAgICAgICAgaXNQcm94eVJlbGVhc2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHByb3AgPT09IFwidGhlblwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBhdGgubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHRoZW46ICgpID0+IHByb3h5IH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHIgPSByZXF1ZXN0UmVzcG9uc2VNZXNzYWdlKGVwLCB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiR0VUXCIgLyogTWVzc2FnZVR5cGUuR0VUICovLFxuICAgICAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLm1hcCgocCkgPT4gcC50b1N0cmluZygpKSxcbiAgICAgICAgICAgICAgICB9KS50aGVuKGZyb21XaXJlVmFsdWUpO1xuICAgICAgICAgICAgICAgIHJldHVybiByLnRoZW4uYmluZChyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVQcm94eShlcCwgWy4uLnBhdGgsIHByb3BdKTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0KF90YXJnZXQsIHByb3AsIHJhd1ZhbHVlKSB7XG4gICAgICAgICAgICB0aHJvd0lmUHJveHlSZWxlYXNlZChpc1Byb3h5UmVsZWFzZWQpO1xuICAgICAgICAgICAgLy8gRklYTUU6IEVTNiBQcm94eSBIYW5kbGVyIGBzZXRgIG1ldGhvZHMgYXJlIHN1cHBvc2VkIHRvIHJldHVybiBhXG4gICAgICAgICAgICAvLyBib29sZWFuLiBUbyBzaG93IGdvb2Qgd2lsbCwgd2UgcmV0dXJuIHRydWUgYXN5bmNocm9ub3VzbHkgwq9cXF8o44OEKV8vwq9cbiAgICAgICAgICAgIGNvbnN0IFt2YWx1ZSwgdHJhbnNmZXJhYmxlc10gPSB0b1dpcmVWYWx1ZShyYXdWYWx1ZSk7XG4gICAgICAgICAgICByZXR1cm4gcmVxdWVzdFJlc3BvbnNlTWVzc2FnZShlcCwge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiU0VUXCIgLyogTWVzc2FnZVR5cGUuU0VUICovLFxuICAgICAgICAgICAgICAgIHBhdGg6IFsuLi5wYXRoLCBwcm9wXS5tYXAoKHApID0+IHAudG9TdHJpbmcoKSksXG4gICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICB9LCB0cmFuc2ZlcmFibGVzKS50aGVuKGZyb21XaXJlVmFsdWUpO1xuICAgICAgICB9LFxuICAgICAgICBhcHBseShfdGFyZ2V0LCBfdGhpc0FyZywgcmF3QXJndW1lbnRMaXN0KSB7XG4gICAgICAgICAgICB0aHJvd0lmUHJveHlSZWxlYXNlZChpc1Byb3h5UmVsZWFzZWQpO1xuICAgICAgICAgICAgY29uc3QgbGFzdCA9IHBhdGhbcGF0aC5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIGlmIChsYXN0ID09PSBjcmVhdGVFbmRwb2ludCkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXF1ZXN0UmVzcG9uc2VNZXNzYWdlKGVwLCB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiRU5EUE9JTlRcIiAvKiBNZXNzYWdlVHlwZS5FTkRQT0lOVCAqLyxcbiAgICAgICAgICAgICAgICB9KS50aGVuKGZyb21XaXJlVmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gV2UganVzdCBwcmV0ZW5kIHRoYXQgYGJpbmQoKWAgZGlkbuKAmXQgaGFwcGVuLlxuICAgICAgICAgICAgaWYgKGxhc3QgPT09IFwiYmluZFwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZVByb3h5KGVwLCBwYXRoLnNsaWNlKDAsIC0xKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBbYXJndW1lbnRMaXN0LCB0cmFuc2ZlcmFibGVzXSA9IHByb2Nlc3NBcmd1bWVudHMocmF3QXJndW1lbnRMaXN0KTtcbiAgICAgICAgICAgIHJldHVybiByZXF1ZXN0UmVzcG9uc2VNZXNzYWdlKGVwLCB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJBUFBMWVwiIC8qIE1lc3NhZ2VUeXBlLkFQUExZICovLFxuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgubWFwKChwKSA9PiBwLnRvU3RyaW5nKCkpLFxuICAgICAgICAgICAgICAgIGFyZ3VtZW50TGlzdCxcbiAgICAgICAgICAgIH0sIHRyYW5zZmVyYWJsZXMpLnRoZW4oZnJvbVdpcmVWYWx1ZSk7XG4gICAgICAgIH0sXG4gICAgICAgIGNvbnN0cnVjdChfdGFyZ2V0LCByYXdBcmd1bWVudExpc3QpIHtcbiAgICAgICAgICAgIHRocm93SWZQcm94eVJlbGVhc2VkKGlzUHJveHlSZWxlYXNlZCk7XG4gICAgICAgICAgICBjb25zdCBbYXJndW1lbnRMaXN0LCB0cmFuc2ZlcmFibGVzXSA9IHByb2Nlc3NBcmd1bWVudHMocmF3QXJndW1lbnRMaXN0KTtcbiAgICAgICAgICAgIHJldHVybiByZXF1ZXN0UmVzcG9uc2VNZXNzYWdlKGVwLCB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJDT05TVFJVQ1RcIiAvKiBNZXNzYWdlVHlwZS5DT05TVFJVQ1QgKi8sXG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aC5tYXAoKHApID0+IHAudG9TdHJpbmcoKSksXG4gICAgICAgICAgICAgICAgYXJndW1lbnRMaXN0LFxuICAgICAgICAgICAgfSwgdHJhbnNmZXJhYmxlcykudGhlbihmcm9tV2lyZVZhbHVlKTtcbiAgICAgICAgfSxcbiAgICB9KTtcbiAgICByZWdpc3RlclByb3h5KHByb3h5LCBlcCk7XG4gICAgcmV0dXJuIHByb3h5O1xufVxuZnVuY3Rpb24gbXlGbGF0KGFycikge1xuICAgIHJldHVybiBBcnJheS5wcm90b3R5cGUuY29uY2F0LmFwcGx5KFtdLCBhcnIpO1xufVxuZnVuY3Rpb24gcHJvY2Vzc0FyZ3VtZW50cyhhcmd1bWVudExpc3QpIHtcbiAgICBjb25zdCBwcm9jZXNzZWQgPSBhcmd1bWVudExpc3QubWFwKHRvV2lyZVZhbHVlKTtcbiAgICByZXR1cm4gW3Byb2Nlc3NlZC5tYXAoKHYpID0+IHZbMF0pLCBteUZsYXQocHJvY2Vzc2VkLm1hcCgodikgPT4gdlsxXSkpXTtcbn1cbmNvbnN0IHRyYW5zZmVyQ2FjaGUgPSBuZXcgV2Vha01hcCgpO1xuZnVuY3Rpb24gdHJhbnNmZXIob2JqLCB0cmFuc2ZlcnMpIHtcbiAgICB0cmFuc2ZlckNhY2hlLnNldChvYmosIHRyYW5zZmVycyk7XG4gICAgcmV0dXJuIG9iajtcbn1cbmZ1bmN0aW9uIHByb3h5KG9iaikge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKG9iaiwgeyBbcHJveHlNYXJrZXJdOiB0cnVlIH0pO1xufVxuZnVuY3Rpb24gd2luZG93RW5kcG9pbnQodywgY29udGV4dCA9IGdsb2JhbFRoaXMsIHRhcmdldE9yaWdpbiA9IFwiKlwiKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcG9zdE1lc3NhZ2U6IChtc2csIHRyYW5zZmVyYWJsZXMpID0+IHcucG9zdE1lc3NhZ2UobXNnLCB0YXJnZXRPcmlnaW4sIHRyYW5zZmVyYWJsZXMpLFxuICAgICAgICBhZGRFdmVudExpc3RlbmVyOiBjb250ZXh0LmFkZEV2ZW50TGlzdGVuZXIuYmluZChjb250ZXh0KSxcbiAgICAgICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcjogY29udGV4dC5yZW1vdmVFdmVudExpc3RlbmVyLmJpbmQoY29udGV4dCksXG4gICAgfTtcbn1cbmZ1bmN0aW9uIHRvV2lyZVZhbHVlKHZhbHVlKSB7XG4gICAgZm9yIChjb25zdCBbbmFtZSwgaGFuZGxlcl0gb2YgdHJhbnNmZXJIYW5kbGVycykge1xuICAgICAgICBpZiAoaGFuZGxlci5jYW5IYW5kbGUodmFsdWUpKSB7XG4gICAgICAgICAgICBjb25zdCBbc2VyaWFsaXplZFZhbHVlLCB0cmFuc2ZlcmFibGVzXSA9IGhhbmRsZXIuc2VyaWFsaXplKHZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcIkhBTkRMRVJcIiAvKiBXaXJlVmFsdWVUeXBlLkhBTkRMRVIgKi8sXG4gICAgICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBzZXJpYWxpemVkVmFsdWUsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB0cmFuc2ZlcmFibGVzLFxuICAgICAgICAgICAgXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gW1xuICAgICAgICB7XG4gICAgICAgICAgICB0eXBlOiBcIlJBV1wiIC8qIFdpcmVWYWx1ZVR5cGUuUkFXICovLFxuICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgIH0sXG4gICAgICAgIHRyYW5zZmVyQ2FjaGUuZ2V0KHZhbHVlKSB8fCBbXSxcbiAgICBdO1xufVxuZnVuY3Rpb24gZnJvbVdpcmVWYWx1ZSh2YWx1ZSkge1xuICAgIHN3aXRjaCAodmFsdWUudHlwZSkge1xuICAgICAgICBjYXNlIFwiSEFORExFUlwiIC8qIFdpcmVWYWx1ZVR5cGUuSEFORExFUiAqLzpcbiAgICAgICAgICAgIHJldHVybiB0cmFuc2ZlckhhbmRsZXJzLmdldCh2YWx1ZS5uYW1lKS5kZXNlcmlhbGl6ZSh2YWx1ZS52YWx1ZSk7XG4gICAgICAgIGNhc2UgXCJSQVdcIiAvKiBXaXJlVmFsdWVUeXBlLlJBVyAqLzpcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZS52YWx1ZTtcbiAgICB9XG59XG5mdW5jdGlvbiByZXF1ZXN0UmVzcG9uc2VNZXNzYWdlKGVwLCBtc2csIHRyYW5zZmVycykge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICBjb25zdCBpZCA9IGdlbmVyYXRlVVVJRCgpO1xuICAgICAgICBlcC5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBmdW5jdGlvbiBsKGV2KSB7XG4gICAgICAgICAgICBpZiAoIWV2LmRhdGEgfHwgIWV2LmRhdGEuaWQgfHwgZXYuZGF0YS5pZCAhPT0gaWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlcC5yZW1vdmVFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBsKTtcbiAgICAgICAgICAgIHJlc29sdmUoZXYuZGF0YSk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoZXAuc3RhcnQpIHtcbiAgICAgICAgICAgIGVwLnN0YXJ0KCk7XG4gICAgICAgIH1cbiAgICAgICAgZXAucG9zdE1lc3NhZ2UoT2JqZWN0LmFzc2lnbih7IGlkIH0sIG1zZyksIHRyYW5zZmVycyk7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBnZW5lcmF0ZVVVSUQoKSB7XG4gICAgcmV0dXJuIG5ldyBBcnJheSg0KVxuICAgICAgICAuZmlsbCgwKVxuICAgICAgICAubWFwKCgpID0+IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIE51bWJlci5NQVhfU0FGRV9JTlRFR0VSKS50b1N0cmluZygxNikpXG4gICAgICAgIC5qb2luKFwiLVwiKTtcbn1cblxuZXhwb3J0IHsgY3JlYXRlRW5kcG9pbnQsIGV4cG9zZSwgZmluYWxpemVyLCBwcm94eSwgcHJveHlNYXJrZXIsIHJlbGVhc2VQcm94eSwgdHJhbnNmZXIsIHRyYW5zZmVySGFuZGxlcnMsIHdpbmRvd0VuZHBvaW50LCB3cmFwIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb21saW5rLm1qcy5tYXBcbiIsImltcG9ydCB7IFByb21pc2VEZWxlZ2F0ZSB9IGZyb20gJ0BsdW1pbm8vY29yZXV0aWxzJztcbmltcG9ydCB7IFBhZ2VDb25maWcgfSBmcm9tICdAanVweXRlcmxhYi9jb3JldXRpbHMnO1xuaW1wb3J0IHsgQmFzZUtlcm5lbCB9IGZyb20gJ0BqdXB5dGVybGl0ZS9rZXJuZWwnO1xuaW1wb3J0IHsgd3JhcCB9IGZyb20gJ2NvbWxpbmsnO1xuaW1wb3J0IHsgYWxsSlNPTlVybCwgcGlwbGl0ZVdoZWVsVXJsIH0gZnJvbSAnLi9fcHlwaSc7XG4vKipcbiAqIEEga2VybmVsIHRoYXQgZXhlY3V0ZXMgUHl0aG9uIGNvZGUgd2l0aCBQeW9kaWRlLlxuICovXG5leHBvcnQgY2xhc3MgUHlvZGlkZUtlcm5lbCBleHRlbmRzIEJhc2VLZXJuZWwge1xuICAvKipcbiAgICogSW5zdGFudGlhdGUgYSBuZXcgUHlvZGlkZUtlcm5lbFxuICAgKlxuICAgKiBAcGFyYW0gb3B0aW9ucyBUaGUgaW5zdGFudGlhdGlvbiBvcHRpb25zIGZvciBhIG5ldyBQeW9kaWRlS2VybmVsXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgc3VwZXIob3B0aW9ucyk7XG4gICAgdGhpcy5fcmVhZHkgPSBuZXcgUHJvbWlzZURlbGVnYXRlKCk7XG4gICAgdGhpcy5fd29ya2VyID0gdGhpcy5pbml0V29ya2VyKG9wdGlvbnMpO1xuICAgIHRoaXMuX3dvcmtlci5vbm1lc3NhZ2UgPSBlID0+IHRoaXMuX3Byb2Nlc3NXb3JrZXJNZXNzYWdlKGUuZGF0YSk7XG4gICAgdGhpcy5fcmVtb3RlS2VybmVsID0gd3JhcCh0aGlzLl93b3JrZXIpO1xuICAgIHRoaXMuaW5pdFJlbW90ZShvcHRpb25zKTtcbiAgfVxuICAvKipcbiAgICogTG9hZCB0aGUgd29ya2VyLlxuICAgKlxuICAgKiAjIyMgTm90ZVxuICAgKlxuICAgKiBTdWJjbGFzc2VzIG11c3QgaW1wbGVtZW50IHRoaXMgdHlwb2dyYXBoaWNhbGx5IGFsbW9zdCBfZXhhY3RseV8gZm9yXG4gICAqIHdlYnBhY2sgdG8gZmluZCBpdC5cbiAgICovXG4gIGluaXRXb3JrZXIob3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgV29ya2VyKG5ldyBVUkwoJy4vY29tbGluay53b3JrZXIuanMnLCBpbXBvcnQubWV0YS51cmwpLCB7XG4gICAgICB0eXBlOiAnbW9kdWxlJ1xuICAgIH0pO1xuICB9XG4gIGFzeW5jIGluaXRSZW1vdGUob3B0aW9ucykge1xuICAgIGNvbnN0IHJlbW90ZU9wdGlvbnMgPSB0aGlzLmluaXRSZW1vdGVPcHRpb25zKG9wdGlvbnMpO1xuICAgIGF3YWl0IHRoaXMuX3JlbW90ZUtlcm5lbC5pbml0aWFsaXplKHJlbW90ZU9wdGlvbnMpO1xuICAgIHRoaXMuX3JlYWR5LnJlc29sdmUoKTtcbiAgfVxuICBpbml0UmVtb3RlT3B0aW9ucyhvcHRpb25zKSB7XG4gICAgY29uc3Qge1xuICAgICAgcHlvZGlkZVVybFxuICAgIH0gPSBvcHRpb25zO1xuICAgIGNvbnN0IGluZGV4VXJsID0gcHlvZGlkZVVybC5zbGljZSgwLCBweW9kaWRlVXJsLmxhc3RJbmRleE9mKCcvJykgKyAxKTtcbiAgICBjb25zdCBiYXNlVXJsID0gUGFnZUNvbmZpZy5nZXRCYXNlVXJsKCk7XG4gICAgY29uc3QgcGlwbGl0ZVVybHMgPSBbLi4uKG9wdGlvbnMucGlwbGl0ZVVybHMgfHwgW10pLCBhbGxKU09OVXJsLmRlZmF1bHRdO1xuICAgIGNvbnN0IGRpc2FibGVQeVBJRmFsbGJhY2sgPSAhIW9wdGlvbnMuZGlzYWJsZVB5UElGYWxsYmFjaztcbiAgICByZXR1cm4ge1xuICAgICAgYmFzZVVybCxcbiAgICAgIHB5b2RpZGVVcmwsXG4gICAgICBpbmRleFVybCxcbiAgICAgIHBpcGxpdGVXaGVlbFVybDogb3B0aW9ucy5waXBsaXRlV2hlZWxVcmwgfHwgcGlwbGl0ZVdoZWVsVXJsLmRlZmF1bHQsXG4gICAgICBwaXBsaXRlVXJscyxcbiAgICAgIGRpc2FibGVQeVBJRmFsbGJhY2ssXG4gICAgICBsb2NhdGlvbjogdGhpcy5sb2NhdGlvbixcbiAgICAgIG1vdW50RHJpdmU6IG9wdGlvbnMubW91bnREcml2ZVxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIERpc3Bvc2UgdGhlIGtlcm5lbC5cbiAgICovXG4gIGRpc3Bvc2UoKSB7XG4gICAgaWYgKHRoaXMuaXNEaXNwb3NlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl93b3JrZXIudGVybWluYXRlKCk7XG4gICAgdGhpcy5fd29ya2VyID0gbnVsbDtcbiAgICBzdXBlci5kaXNwb3NlKCk7XG4gIH1cbiAgLyoqXG4gICAqIEEgcHJvbWlzZSB0aGF0IGlzIGZ1bGZpbGxlZCB3aGVuIHRoZSBrZXJuZWwgaXMgcmVhZHkuXG4gICAqL1xuICBnZXQgcmVhZHkoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JlYWR5LnByb21pc2U7XG4gIH1cbiAgLyoqXG4gICAqIFByb2Nlc3MgYSBtZXNzYWdlIGNvbWluZyBmcm9tIHRoZSBweW9kaWRlIHdlYiB3b3JrZXIuXG4gICAqXG4gICAqIEBwYXJhbSBtc2cgVGhlIHdvcmtlciBtZXNzYWdlIHRvIHByb2Nlc3MuXG4gICAqL1xuICBfcHJvY2Vzc1dvcmtlck1lc3NhZ2UobXNnKSB7XG4gICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2YsIF9nO1xuICAgIGlmICghbXNnLnR5cGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc3dpdGNoIChtc2cudHlwZSkge1xuICAgICAgY2FzZSAnc3RyZWFtJzpcbiAgICAgICAge1xuICAgICAgICAgIGNvbnN0IGJ1bmRsZSA9IChfYSA9IG1zZy5idW5kbGUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHtcbiAgICAgICAgICAgIG5hbWU6ICdzdGRvdXQnLFxuICAgICAgICAgICAgdGV4dDogJydcbiAgICAgICAgICB9O1xuICAgICAgICAgIHRoaXMuc3RyZWFtKGJ1bmRsZSwgbXNnLnBhcmVudEhlYWRlcik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgJ2lucHV0X3JlcXVlc3QnOlxuICAgICAgICB7XG4gICAgICAgICAgY29uc3QgYnVuZGxlID0gKF9iID0gbXNnLmNvbnRlbnQpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IHtcbiAgICAgICAgICAgIHByb21wdDogJycsXG4gICAgICAgICAgICBwYXNzd29yZDogZmFsc2VcbiAgICAgICAgICB9O1xuICAgICAgICAgIHRoaXMuaW5wdXRSZXF1ZXN0KGJ1bmRsZSwgbXNnLnBhcmVudEhlYWRlcik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgJ2Rpc3BsYXlfZGF0YSc6XG4gICAgICAgIHtcbiAgICAgICAgICBjb25zdCBidW5kbGUgPSAoX2MgPSBtc2cuYnVuZGxlKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiB7XG4gICAgICAgICAgICBkYXRhOiB7fSxcbiAgICAgICAgICAgIG1ldGFkYXRhOiB7fSxcbiAgICAgICAgICAgIHRyYW5zaWVudDoge31cbiAgICAgICAgICB9O1xuICAgICAgICAgIHRoaXMuZGlzcGxheURhdGEoYnVuZGxlLCBtc2cucGFyZW50SGVhZGVyKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgY2FzZSAndXBkYXRlX2Rpc3BsYXlfZGF0YSc6XG4gICAgICAgIHtcbiAgICAgICAgICBjb25zdCBidW5kbGUgPSAoX2QgPSBtc2cuYnVuZGxlKSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiB7XG4gICAgICAgICAgICBkYXRhOiB7fSxcbiAgICAgICAgICAgIG1ldGFkYXRhOiB7fSxcbiAgICAgICAgICAgIHRyYW5zaWVudDoge31cbiAgICAgICAgICB9O1xuICAgICAgICAgIHRoaXMudXBkYXRlRGlzcGxheURhdGEoYnVuZGxlLCBtc2cucGFyZW50SGVhZGVyKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgY2FzZSAnY2xlYXJfb3V0cHV0JzpcbiAgICAgICAge1xuICAgICAgICAgIGNvbnN0IGJ1bmRsZSA9IChfZSA9IG1zZy5idW5kbGUpICE9PSBudWxsICYmIF9lICE9PSB2b2lkIDAgPyBfZSA6IHtcbiAgICAgICAgICAgIHdhaXQ6IGZhbHNlXG4gICAgICAgICAgfTtcbiAgICAgICAgICB0aGlzLmNsZWFyT3V0cHV0KGJ1bmRsZSwgbXNnLnBhcmVudEhlYWRlcik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgJ2V4ZWN1dGVfcmVzdWx0JzpcbiAgICAgICAge1xuICAgICAgICAgIGNvbnN0IGJ1bmRsZSA9IChfZiA9IG1zZy5idW5kbGUpICE9PSBudWxsICYmIF9mICE9PSB2b2lkIDAgPyBfZiA6IHtcbiAgICAgICAgICAgIGV4ZWN1dGlvbl9jb3VudDogMCxcbiAgICAgICAgICAgIGRhdGE6IHt9LFxuICAgICAgICAgICAgbWV0YWRhdGE6IHt9XG4gICAgICAgICAgfTtcbiAgICAgICAgICB0aGlzLnB1Ymxpc2hFeGVjdXRlUmVzdWx0KGJ1bmRsZSwgbXNnLnBhcmVudEhlYWRlcik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgJ2V4ZWN1dGVfZXJyb3InOlxuICAgICAgICB7XG4gICAgICAgICAgY29uc3QgYnVuZGxlID0gKF9nID0gbXNnLmJ1bmRsZSkgIT09IG51bGwgJiYgX2cgIT09IHZvaWQgMCA/IF9nIDoge1xuICAgICAgICAgICAgZW5hbWU6ICcnLFxuICAgICAgICAgICAgZXZhbHVlOiAnJyxcbiAgICAgICAgICAgIHRyYWNlYmFjazogW11cbiAgICAgICAgICB9O1xuICAgICAgICAgIHRoaXMucHVibGlzaEV4ZWN1dGVFcnJvcihidW5kbGUsIG1zZy5wYXJlbnRIZWFkZXIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICBjYXNlICdjb21tX21zZyc6XG4gICAgICBjYXNlICdjb21tX29wZW4nOlxuICAgICAgY2FzZSAnY29tbV9jbG9zZSc6XG4gICAgICAgIHtcbiAgICAgICAgICB0aGlzLmhhbmRsZUNvbW0obXNnLnR5cGUsIG1zZy5jb250ZW50LCBtc2cubWV0YWRhdGEsIG1zZy5idWZmZXJzLCBtc2cucGFyZW50SGVhZGVyKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgfVxuICAvKipcbiAgICogSGFuZGxlIGEga2VybmVsX2luZm9fcmVxdWVzdCBtZXNzYWdlXG4gICAqL1xuICBhc3luYyBrZXJuZWxJbmZvUmVxdWVzdCgpIHtcbiAgICBjb25zdCBjb250ZW50ID0ge1xuICAgICAgaW1wbGVtZW50YXRpb246ICdweW9kaWRlJyxcbiAgICAgIGltcGxlbWVudGF0aW9uX3ZlcnNpb246ICcwLjEuMCcsXG4gICAgICBsYW5ndWFnZV9pbmZvOiB7XG4gICAgICAgIGNvZGVtaXJyb3JfbW9kZToge1xuICAgICAgICAgIG5hbWU6ICdweXRob24nLFxuICAgICAgICAgIHZlcnNpb246IDNcbiAgICAgICAgfSxcbiAgICAgICAgZmlsZV9leHRlbnNpb246ICcucHknLFxuICAgICAgICBtaW1ldHlwZTogJ3RleHQveC1weXRob24nLFxuICAgICAgICBuYW1lOiAncHl0aG9uJyxcbiAgICAgICAgbmJjb252ZXJ0X2V4cG9ydGVyOiAncHl0aG9uJyxcbiAgICAgICAgcHlnbWVudHNfbGV4ZXI6ICdpcHl0aG9uMycsXG4gICAgICAgIHZlcnNpb246ICczLjgnXG4gICAgICB9LFxuICAgICAgcHJvdG9jb2xfdmVyc2lvbjogJzUuMycsXG4gICAgICBzdGF0dXM6ICdvaycsXG4gICAgICBiYW5uZXI6ICdBIFdlYkFzc2VtYmx5LXBvd2VyZWQgUHl0aG9uIGtlcm5lbCBiYWNrZWQgYnkgUHlvZGlkZScsXG4gICAgICBoZWxwX2xpbmtzOiBbe1xuICAgICAgICB0ZXh0OiAnUHl0aG9uIChXQVNNKSBLZXJuZWwnLFxuICAgICAgICB1cmw6ICdodHRwczovL3B5b2RpZGUub3JnJ1xuICAgICAgfV1cbiAgICB9O1xuICAgIHJldHVybiBjb250ZW50O1xuICB9XG4gIC8qKlxuICAgKiBIYW5kbGUgYW4gYGV4ZWN1dGVfcmVxdWVzdGAgbWVzc2FnZVxuICAgKlxuICAgKiBAcGFyYW0gbXNnIFRoZSBwYXJlbnQgbWVzc2FnZS5cbiAgICovXG4gIGFzeW5jIGV4ZWN1dGVSZXF1ZXN0KGNvbnRlbnQpIHtcbiAgICBhd2FpdCB0aGlzLnJlYWR5O1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuX3JlbW90ZUtlcm5lbC5leGVjdXRlKGNvbnRlbnQsIHRoaXMucGFyZW50KTtcbiAgICByZXN1bHQuZXhlY3V0aW9uX2NvdW50ID0gdGhpcy5leGVjdXRpb25Db3VudDtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIC8qKlxuICAgKiBIYW5kbGUgYW4gY29tcGxldGVfcmVxdWVzdCBtZXNzYWdlXG4gICAqXG4gICAqIEBwYXJhbSBtc2cgVGhlIHBhcmVudCBtZXNzYWdlLlxuICAgKi9cbiAgYXN5bmMgY29tcGxldGVSZXF1ZXN0KGNvbnRlbnQpIHtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5fcmVtb3RlS2VybmVsLmNvbXBsZXRlKGNvbnRlbnQsIHRoaXMucGFyZW50KTtcbiAgfVxuICAvKipcbiAgICogSGFuZGxlIGFuIGBpbnNwZWN0X3JlcXVlc3RgIG1lc3NhZ2UuXG4gICAqXG4gICAqIEBwYXJhbSBjb250ZW50IC0gVGhlIGNvbnRlbnQgb2YgdGhlIHJlcXVlc3QuXG4gICAqXG4gICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggdGhlIHJlc3BvbnNlIG1lc3NhZ2UuXG4gICAqL1xuICBhc3luYyBpbnNwZWN0UmVxdWVzdChjb250ZW50KSB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuX3JlbW90ZUtlcm5lbC5pbnNwZWN0KGNvbnRlbnQsIHRoaXMucGFyZW50KTtcbiAgfVxuICAvKipcbiAgICogSGFuZGxlIGFuIGBpc19jb21wbGV0ZV9yZXF1ZXN0YCBtZXNzYWdlLlxuICAgKlxuICAgKiBAcGFyYW0gY29udGVudCAtIFRoZSBjb250ZW50IG9mIHRoZSByZXF1ZXN0LlxuICAgKlxuICAgKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIHRoZSByZXNwb25zZSBtZXNzYWdlLlxuICAgKi9cbiAgYXN5bmMgaXNDb21wbGV0ZVJlcXVlc3QoY29udGVudCkge1xuICAgIHJldHVybiBhd2FpdCB0aGlzLl9yZW1vdGVLZXJuZWwuaXNDb21wbGV0ZShjb250ZW50LCB0aGlzLnBhcmVudCk7XG4gIH1cbiAgLyoqXG4gICAqIEhhbmRsZSBhIGBjb21tX2luZm9fcmVxdWVzdGAgbWVzc2FnZS5cbiAgICpcbiAgICogQHBhcmFtIGNvbnRlbnQgLSBUaGUgY29udGVudCBvZiB0aGUgcmVxdWVzdC5cbiAgICpcbiAgICogQHJldHVybnMgQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCB0aGUgcmVzcG9uc2UgbWVzc2FnZS5cbiAgICovXG4gIGFzeW5jIGNvbW1JbmZvUmVxdWVzdChjb250ZW50KSB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuX3JlbW90ZUtlcm5lbC5jb21tSW5mbyhjb250ZW50LCB0aGlzLnBhcmVudCk7XG4gIH1cbiAgLyoqXG4gICAqIFNlbmQgYW4gYGNvbW1fb3BlbmAgbWVzc2FnZS5cbiAgICpcbiAgICogQHBhcmFtIG1zZyAtIFRoZSBjb21tX29wZW4gbWVzc2FnZS5cbiAgICovXG4gIGFzeW5jIGNvbW1PcGVuKG1zZykge1xuICAgIHJldHVybiBhd2FpdCB0aGlzLl9yZW1vdGVLZXJuZWwuY29tbU9wZW4obXNnLCB0aGlzLnBhcmVudCk7XG4gIH1cbiAgLyoqXG4gICAqIFNlbmQgYW4gYGNvbW1fbXNnYCBtZXNzYWdlLlxuICAgKlxuICAgKiBAcGFyYW0gbXNnIC0gVGhlIGNvbW1fbXNnIG1lc3NhZ2UuXG4gICAqL1xuICBhc3luYyBjb21tTXNnKG1zZykge1xuICAgIHJldHVybiBhd2FpdCB0aGlzLl9yZW1vdGVLZXJuZWwuY29tbU1zZyhtc2csIHRoaXMucGFyZW50KTtcbiAgfVxuICAvKipcbiAgICogU2VuZCBhbiBgY29tbV9jbG9zZWAgbWVzc2FnZS5cbiAgICpcbiAgICogQHBhcmFtIGNsb3NlIC0gVGhlIGNvbW1fY2xvc2UgbWVzc2FnZS5cbiAgICovXG4gIGFzeW5jIGNvbW1DbG9zZShtc2cpIHtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5fcmVtb3RlS2VybmVsLmNvbW1DbG9zZShtc2csIHRoaXMucGFyZW50KTtcbiAgfVxuICAvKipcbiAgICogU2VuZCBhbiBgaW5wdXRfcmVwbHlgIG1lc3NhZ2UuXG4gICAqXG4gICAqIEBwYXJhbSBjb250ZW50IC0gVGhlIGNvbnRlbnQgb2YgdGhlIHJlcGx5LlxuICAgKi9cbiAgYXN5bmMgaW5wdXRSZXBseShjb250ZW50KSB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuX3JlbW90ZUtlcm5lbC5pbnB1dFJlcGx5KGNvbnRlbnQsIHRoaXMucGFyZW50KTtcbiAgfVxufSIsIi8vIENvcHlyaWdodCAoYykgSnVweXRlciBEZXZlbG9wbWVudCBUZWFtLlxuLy8gRGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBNb2RpZmllZCBCU0QgTGljZW5zZS5cbi8qKlxuICogVGhlIHNjaGVtYSBmb3IgYSBXYXJlaG91c2UtbGlrZSBpbmRleCwgYXMgdXNlZCBieSBwaXBsaXRlLlxuICovXG5pbXBvcnQgKiBhcyBfUElQTElURV9JTkRFWF9TQ0hFTUEgZnJvbSAnLi4vc2NoZW1hL3BpcGxpdGUudjAuc2NoZW1hLmpzb24nO1xuZXhwb3J0IHsgX1BJUExJVEVfSU5ERVhfU0NIRU1BIGFzIFBJUExJVEVfSU5ERVhfU0NIRU1BIH07IiwiLy8gQ29weXJpZ2h0IChjKSBKdXB5dGVyIERldmVsb3BtZW50IFRlYW0uXG4vLyBEaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIE1vZGlmaWVkIEJTRCBMaWNlbnNlLlxuZXhwb3J0ICogZnJvbSAnLi9fcHlwaSc7XG5leHBvcnQgKiBmcm9tICcuL2NvbWxpbmsud29ya2VyJztcbmV4cG9ydCAqIGZyb20gJy4va2VybmVsJztcbmV4cG9ydCAqIGZyb20gJy4vdG9rZW5zJztcbmV4cG9ydCAqIGZyb20gJy4vd29ya2VyJzsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=