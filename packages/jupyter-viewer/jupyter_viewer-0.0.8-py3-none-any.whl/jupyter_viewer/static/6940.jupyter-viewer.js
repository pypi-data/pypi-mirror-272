"use strict";
(self["webpackChunk_datalayer_jupyter_viewer"] = self["webpackChunk_datalayer_jupyter_viewer"] || []).push([[6940],{

/***/ 46940:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "clojure": () => (/* binding */ clojure)
/* harmony export */ });
var atoms = ["false", "nil", "true"];
var specialForms = [".", "catch", "def", "do", "if", "monitor-enter", "monitor-exit", "new", "quote", "recur", "set!", "throw", "try", "var"];
var coreSymbols = ["*", "*'", "*1", "*2", "*3", "*agent*", "*allow-unresolved-vars*", "*assert*", "*clojure-version*", "*command-line-args*", "*compile-files*", "*compile-path*", "*compiler-options*", "*data-readers*", "*default-data-reader-fn*", "*e", "*err*", "*file*", "*flush-on-newline*", "*fn-loader*", "*in*", "*math-context*", "*ns*", "*out*", "*print-dup*", "*print-length*", "*print-level*", "*print-meta*", "*print-namespace-maps*", "*print-readably*", "*read-eval*", "*reader-resolver*", "*source-path*", "*suppress-read*", "*unchecked-math*", "*use-context-classloader*", "*verbose-defrecords*", "*warn-on-reflection*", "+", "+'", "-", "-'", "->", "->>", "->ArrayChunk", "->Eduction", "->Vec", "->VecNode", "->VecSeq", "-cache-protocol-fn", "-reset-methods", "..", "/", "<", "<=", "=", "==", ">", ">=", "EMPTY-NODE", "Inst", "StackTraceElement->vec", "Throwable->map", "accessor", "aclone", "add-classpath", "add-watch", "agent", "agent-error", "agent-errors", "aget", "alength", "alias", "all-ns", "alter", "alter-meta!", "alter-var-root", "amap", "ancestors", "and", "any?", "apply", "areduce", "array-map", "as->", "aset", "aset-boolean", "aset-byte", "aset-char", "aset-double", "aset-float", "aset-int", "aset-long", "aset-short", "assert", "assoc", "assoc!", "assoc-in", "associative?", "atom", "await", "await-for", "await1", "bases", "bean", "bigdec", "bigint", "biginteger", "binding", "bit-and", "bit-and-not", "bit-clear", "bit-flip", "bit-not", "bit-or", "bit-set", "bit-shift-left", "bit-shift-right", "bit-test", "bit-xor", "boolean", "boolean-array", "boolean?", "booleans", "bound-fn", "bound-fn*", "bound?", "bounded-count", "butlast", "byte", "byte-array", "bytes", "bytes?", "case", "cast", "cat", "char", "char-array", "char-escape-string", "char-name-string", "char?", "chars", "chunk", "chunk-append", "chunk-buffer", "chunk-cons", "chunk-first", "chunk-next", "chunk-rest", "chunked-seq?", "class", "class?", "clear-agent-errors", "clojure-version", "coll?", "comment", "commute", "comp", "comparator", "compare", "compare-and-set!", "compile", "complement", "completing", "concat", "cond", "cond->", "cond->>", "condp", "conj", "conj!", "cons", "constantly", "construct-proxy", "contains?", "count", "counted?", "create-ns", "create-struct", "cycle", "dec", "dec'", "decimal?", "declare", "dedupe", "default-data-readers", "definline", "definterface", "defmacro", "defmethod", "defmulti", "defn", "defn-", "defonce", "defprotocol", "defrecord", "defstruct", "deftype", "delay", "delay?", "deliver", "denominator", "deref", "derive", "descendants", "destructure", "disj", "disj!", "dissoc", "dissoc!", "distinct", "distinct?", "doall", "dorun", "doseq", "dosync", "dotimes", "doto", "double", "double-array", "double?", "doubles", "drop", "drop-last", "drop-while", "eduction", "empty", "empty?", "ensure", "ensure-reduced", "enumeration-seq", "error-handler", "error-mode", "eval", "even?", "every-pred", "every?", "ex-data", "ex-info", "extend", "extend-protocol", "extend-type", "extenders", "extends?", "false?", "ffirst", "file-seq", "filter", "filterv", "find", "find-keyword", "find-ns", "find-protocol-impl", "find-protocol-method", "find-var", "first", "flatten", "float", "float-array", "float?", "floats", "flush", "fn", "fn?", "fnext", "fnil", "for", "force", "format", "frequencies", "future", "future-call", "future-cancel", "future-cancelled?", "future-done?", "future?", "gen-class", "gen-interface", "gensym", "get", "get-in", "get-method", "get-proxy-class", "get-thread-bindings", "get-validator", "group-by", "halt-when", "hash", "hash-combine", "hash-map", "hash-ordered-coll", "hash-set", "hash-unordered-coll", "ident?", "identical?", "identity", "if-let", "if-not", "if-some", "ifn?", "import", "in-ns", "inc", "inc'", "indexed?", "init-proxy", "inst-ms", "inst-ms*", "inst?", "instance?", "int", "int-array", "int?", "integer?", "interleave", "intern", "interpose", "into", "into-array", "ints", "io!", "isa?", "iterate", "iterator-seq", "juxt", "keep", "keep-indexed", "key", "keys", "keyword", "keyword?", "last", "lazy-cat", "lazy-seq", "let", "letfn", "line-seq", "list", "list*", "list?", "load", "load-file", "load-reader", "load-string", "loaded-libs", "locking", "long", "long-array", "longs", "loop", "macroexpand", "macroexpand-1", "make-array", "make-hierarchy", "map", "map-entry?", "map-indexed", "map?", "mapcat", "mapv", "max", "max-key", "memfn", "memoize", "merge", "merge-with", "meta", "method-sig", "methods", "min", "min-key", "mix-collection-hash", "mod", "munge", "name", "namespace", "namespace-munge", "nat-int?", "neg-int?", "neg?", "newline", "next", "nfirst", "nil?", "nnext", "not", "not-any?", "not-empty", "not-every?", "not=", "ns", "ns-aliases", "ns-imports", "ns-interns", "ns-map", "ns-name", "ns-publics", "ns-refers", "ns-resolve", "ns-unalias", "ns-unmap", "nth", "nthnext", "nthrest", "num", "number?", "numerator", "object-array", "odd?", "or", "parents", "partial", "partition", "partition-all", "partition-by", "pcalls", "peek", "persistent!", "pmap", "pop", "pop!", "pop-thread-bindings", "pos-int?", "pos?", "pr", "pr-str", "prefer-method", "prefers", "primitives-classnames", "print", "print-ctor", "print-dup", "print-method", "print-simple", "print-str", "printf", "println", "println-str", "prn", "prn-str", "promise", "proxy", "proxy-call-with-super", "proxy-mappings", "proxy-name", "proxy-super", "push-thread-bindings", "pvalues", "qualified-ident?", "qualified-keyword?", "qualified-symbol?", "quot", "rand", "rand-int", "rand-nth", "random-sample", "range", "ratio?", "rational?", "rationalize", "re-find", "re-groups", "re-matcher", "re-matches", "re-pattern", "re-seq", "read", "read-line", "read-string", "reader-conditional", "reader-conditional?", "realized?", "record?", "reduce", "reduce-kv", "reduced", "reduced?", "reductions", "ref", "ref-history-count", "ref-max-history", "ref-min-history", "ref-set", "refer", "refer-clojure", "reify", "release-pending-sends", "rem", "remove", "remove-all-methods", "remove-method", "remove-ns", "remove-watch", "repeat", "repeatedly", "replace", "replicate", "require", "reset!", "reset-meta!", "reset-vals!", "resolve", "rest", "restart-agent", "resultset-seq", "reverse", "reversible?", "rseq", "rsubseq", "run!", "satisfies?", "second", "select-keys", "send", "send-off", "send-via", "seq", "seq?", "seqable?", "seque", "sequence", "sequential?", "set", "set-agent-send-executor!", "set-agent-send-off-executor!", "set-error-handler!", "set-error-mode!", "set-validator!", "set?", "short", "short-array", "shorts", "shuffle", "shutdown-agents", "simple-ident?", "simple-keyword?", "simple-symbol?", "slurp", "some", "some->", "some->>", "some-fn", "some?", "sort", "sort-by", "sorted-map", "sorted-map-by", "sorted-set", "sorted-set-by", "sorted?", "special-symbol?", "spit", "split-at", "split-with", "str", "string?", "struct", "struct-map", "subs", "subseq", "subvec", "supers", "swap!", "swap-vals!", "symbol", "symbol?", "sync", "tagged-literal", "tagged-literal?", "take", "take-last", "take-nth", "take-while", "test", "the-ns", "thread-bound?", "time", "to-array", "to-array-2d", "trampoline", "transduce", "transient", "tree-seq", "true?", "type", "unchecked-add", "unchecked-add-int", "unchecked-byte", "unchecked-char", "unchecked-dec", "unchecked-dec-int", "unchecked-divide-int", "unchecked-double", "unchecked-float", "unchecked-inc", "unchecked-inc-int", "unchecked-int", "unchecked-long", "unchecked-multiply", "unchecked-multiply-int", "unchecked-negate", "unchecked-negate-int", "unchecked-remainder-int", "unchecked-short", "unchecked-subtract", "unchecked-subtract-int", "underive", "unquote", "unquote-splicing", "unreduced", "unsigned-bit-shift-right", "update", "update-in", "update-proxy", "uri?", "use", "uuid?", "val", "vals", "var-get", "var-set", "var?", "vary-meta", "vec", "vector", "vector-of", "vector?", "volatile!", "volatile?", "vreset!", "vswap!", "when", "when-first", "when-let", "when-not", "when-some", "while", "with-bindings", "with-bindings*", "with-in-str", "with-loading-context", "with-local-vars", "with-meta", "with-open", "with-out-str", "with-precision", "with-redefs", "with-redefs-fn", "xml-seq", "zero?", "zipmap"];
var haveBodyParameter = ["->", "->>", "as->", "binding", "bound-fn", "case", "catch", "comment", "cond", "cond->", "cond->>", "condp", "def", "definterface", "defmethod", "defn", "defmacro", "defprotocol", "defrecord", "defstruct", "deftype", "do", "doseq", "dotimes", "doto", "extend", "extend-protocol", "extend-type", "fn", "for", "future", "if", "if-let", "if-not", "if-some", "let", "letfn", "locking", "loop", "ns", "proxy", "reify", "struct-map", "some->", "some->>", "try", "when", "when-first", "when-let", "when-not", "when-some", "while", "with-bindings", "with-bindings*", "with-in-str", "with-loading-context", "with-local-vars", "with-meta", "with-open", "with-out-str", "with-precision", "with-redefs", "with-redefs-fn"];
var atom = createLookupMap(atoms);
var specialForm = createLookupMap(specialForms);
var coreSymbol = createLookupMap(coreSymbols);
var hasBodyParameter = createLookupMap(haveBodyParameter);
var delimiter = /^(?:[\\\[\]\s"(),;@^`{}~]|$)/;
var numberLiteral = /^(?:[+\-]?\d+(?:(?:N|(?:[eE][+\-]?\d+))|(?:\.?\d*(?:M|(?:[eE][+\-]?\d+))?)|\/\d+|[xX][0-9a-fA-F]+|r[0-9a-zA-Z]+)?(?=[\\\[\]\s"#'(),;@^`{}~]|$))/;
var characterLiteral = /^(?:\\(?:backspace|formfeed|newline|return|space|tab|o[0-7]{3}|u[0-9A-Fa-f]{4}|x[0-9A-Fa-f]{4}|.)?(?=[\\\[\]\s"(),;@^`{}~]|$))/;

// simple-namespace := /^[^\\\/\[\]\d\s"#'(),;@^`{}~.][^\\\[\]\s"(),;@^`{}~.\/]*/
// simple-symbol    := /^(?:\/|[^\\\/\[\]\d\s"#'(),;@^`{}~][^\\\[\]\s"(),;@^`{}~]*)/
// qualified-symbol := (<simple-namespace>(<.><simple-namespace>)*</>)?<simple-symbol>
var qualifiedSymbol = /^(?:(?:[^\\\/\[\]\d\s"#'(),;@^`{}~.][^\\\[\]\s"(),;@^`{}~.\/]*(?:\.[^\\\/\[\]\d\s"#'(),;@^`{}~.][^\\\[\]\s"(),;@^`{}~.\/]*)*\/)?(?:\/|[^\\\/\[\]\d\s"#'(),;@^`{}~][^\\\[\]\s"(),;@^`{}~]*)*(?=[\\\[\]\s"(),;@^`{}~]|$))/;
function base(stream, state) {
  if (stream.eatSpace() || stream.eat(",")) return ["space", null];
  if (stream.match(numberLiteral)) return [null, "number"];
  if (stream.match(characterLiteral)) return [null, "string.special"];
  if (stream.eat(/^"/)) return (state.tokenize = inString)(stream, state);
  if (stream.eat(/^[(\[{]/)) return ["open", "bracket"];
  if (stream.eat(/^[)\]}]/)) return ["close", "bracket"];
  if (stream.eat(/^;/)) {
    stream.skipToEnd();
    return ["space", "comment"];
  }
  if (stream.eat(/^[#'@^`~]/)) return [null, "meta"];
  var matches = stream.match(qualifiedSymbol);
  var symbol = matches && matches[0];
  if (!symbol) {
    // advance stream by at least one character so we don't get stuck.
    stream.next();
    stream.eatWhile(function (c) {
      return !is(c, delimiter);
    });
    return [null, "error"];
  }
  if (symbol === "comment" && state.lastToken === "(") return (state.tokenize = inComment)(stream, state);
  if (is(symbol, atom) || symbol.charAt(0) === ":") return ["symbol", "atom"];
  if (is(symbol, specialForm) || is(symbol, coreSymbol)) return ["symbol", "keyword"];
  if (state.lastToken === "(") return ["symbol", "builtin"]; // other operator

  return ["symbol", "variable"];
}
function inString(stream, state) {
  var escaped = false,
    next;
  while (next = stream.next()) {
    if (next === "\"" && !escaped) {
      state.tokenize = base;
      break;
    }
    escaped = !escaped && next === "\\";
  }
  return [null, "string"];
}
function inComment(stream, state) {
  var parenthesisCount = 1;
  var next;
  while (next = stream.next()) {
    if (next === ")") parenthesisCount--;
    if (next === "(") parenthesisCount++;
    if (parenthesisCount === 0) {
      stream.backUp(1);
      state.tokenize = base;
      break;
    }
  }
  return ["space", "comment"];
}
function createLookupMap(words) {
  var obj = {};
  for (var i = 0; i < words.length; ++i) obj[words[i]] = true;
  return obj;
}
function is(value, test) {
  if (test instanceof RegExp) return test.test(value);
  if (test instanceof Object) return test.propertyIsEnumerable(value);
}
const clojure = {
  name: "clojure",
  startState: function () {
    return {
      ctx: {
        prev: null,
        start: 0,
        indentTo: 0
      },
      lastToken: null,
      tokenize: base
    };
  },
  token: function (stream, state) {
    if (stream.sol() && typeof state.ctx.indentTo !== "number") state.ctx.indentTo = state.ctx.start + 1;
    var typeStylePair = state.tokenize(stream, state);
    var type = typeStylePair[0];
    var style = typeStylePair[1];
    var current = stream.current();
    if (type !== "space") {
      if (state.lastToken === "(" && state.ctx.indentTo === null) {
        if (type === "symbol" && is(current, hasBodyParameter)) state.ctx.indentTo = state.ctx.start + stream.indentUnit;else state.ctx.indentTo = "next";
      } else if (state.ctx.indentTo === "next") {
        state.ctx.indentTo = stream.column();
      }
      state.lastToken = current;
    }
    if (type === "open") state.ctx = {
      prev: state.ctx,
      start: stream.column(),
      indentTo: null
    };else if (type === "close") state.ctx = state.ctx.prev || state.ctx;
    return style;
  },
  indent: function (state) {
    var i = state.ctx.indentTo;
    return typeof i === "number" ? i : state.ctx.start + 1;
  },
  languageData: {
    closeBrackets: {
      brackets: ["(", "[", "{", '"']
    },
    commentTokens: {
      line: ";;"
    },
    autocomplete: [].concat(atoms, specialForms, coreSymbols)
  }
};

/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjk0MC5qdXB5dGVyLXZpZXdlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0BkYXRhbGF5ZXIvanVweXRlci12aWV3ZXIvLi9ub2RlX21vZHVsZXMvQGNvZGVtaXJyb3IvbGVnYWN5LW1vZGVzL21vZGUvY2xvanVyZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgYXRvbXMgPSBbXCJmYWxzZVwiLCBcIm5pbFwiLCBcInRydWVcIl07XG52YXIgc3BlY2lhbEZvcm1zID0gW1wiLlwiLCBcImNhdGNoXCIsIFwiZGVmXCIsIFwiZG9cIiwgXCJpZlwiLCBcIm1vbml0b3ItZW50ZXJcIiwgXCJtb25pdG9yLWV4aXRcIiwgXCJuZXdcIiwgXCJxdW90ZVwiLCBcInJlY3VyXCIsIFwic2V0IVwiLCBcInRocm93XCIsIFwidHJ5XCIsIFwidmFyXCJdO1xudmFyIGNvcmVTeW1ib2xzID0gW1wiKlwiLCBcIionXCIsIFwiKjFcIiwgXCIqMlwiLCBcIiozXCIsIFwiKmFnZW50KlwiLCBcIiphbGxvdy11bnJlc29sdmVkLXZhcnMqXCIsIFwiKmFzc2VydCpcIiwgXCIqY2xvanVyZS12ZXJzaW9uKlwiLCBcIipjb21tYW5kLWxpbmUtYXJncypcIiwgXCIqY29tcGlsZS1maWxlcypcIiwgXCIqY29tcGlsZS1wYXRoKlwiLCBcIipjb21waWxlci1vcHRpb25zKlwiLCBcIipkYXRhLXJlYWRlcnMqXCIsIFwiKmRlZmF1bHQtZGF0YS1yZWFkZXItZm4qXCIsIFwiKmVcIiwgXCIqZXJyKlwiLCBcIipmaWxlKlwiLCBcIipmbHVzaC1vbi1uZXdsaW5lKlwiLCBcIipmbi1sb2FkZXIqXCIsIFwiKmluKlwiLCBcIiptYXRoLWNvbnRleHQqXCIsIFwiKm5zKlwiLCBcIipvdXQqXCIsIFwiKnByaW50LWR1cCpcIiwgXCIqcHJpbnQtbGVuZ3RoKlwiLCBcIipwcmludC1sZXZlbCpcIiwgXCIqcHJpbnQtbWV0YSpcIiwgXCIqcHJpbnQtbmFtZXNwYWNlLW1hcHMqXCIsIFwiKnByaW50LXJlYWRhYmx5KlwiLCBcIipyZWFkLWV2YWwqXCIsIFwiKnJlYWRlci1yZXNvbHZlcipcIiwgXCIqc291cmNlLXBhdGgqXCIsIFwiKnN1cHByZXNzLXJlYWQqXCIsIFwiKnVuY2hlY2tlZC1tYXRoKlwiLCBcIip1c2UtY29udGV4dC1jbGFzc2xvYWRlcipcIiwgXCIqdmVyYm9zZS1kZWZyZWNvcmRzKlwiLCBcIip3YXJuLW9uLXJlZmxlY3Rpb24qXCIsIFwiK1wiLCBcIisnXCIsIFwiLVwiLCBcIi0nXCIsIFwiLT5cIiwgXCItPj5cIiwgXCItPkFycmF5Q2h1bmtcIiwgXCItPkVkdWN0aW9uXCIsIFwiLT5WZWNcIiwgXCItPlZlY05vZGVcIiwgXCItPlZlY1NlcVwiLCBcIi1jYWNoZS1wcm90b2NvbC1mblwiLCBcIi1yZXNldC1tZXRob2RzXCIsIFwiLi5cIiwgXCIvXCIsIFwiPFwiLCBcIjw9XCIsIFwiPVwiLCBcIj09XCIsIFwiPlwiLCBcIj49XCIsIFwiRU1QVFktTk9ERVwiLCBcIkluc3RcIiwgXCJTdGFja1RyYWNlRWxlbWVudC0+dmVjXCIsIFwiVGhyb3dhYmxlLT5tYXBcIiwgXCJhY2Nlc3NvclwiLCBcImFjbG9uZVwiLCBcImFkZC1jbGFzc3BhdGhcIiwgXCJhZGQtd2F0Y2hcIiwgXCJhZ2VudFwiLCBcImFnZW50LWVycm9yXCIsIFwiYWdlbnQtZXJyb3JzXCIsIFwiYWdldFwiLCBcImFsZW5ndGhcIiwgXCJhbGlhc1wiLCBcImFsbC1uc1wiLCBcImFsdGVyXCIsIFwiYWx0ZXItbWV0YSFcIiwgXCJhbHRlci12YXItcm9vdFwiLCBcImFtYXBcIiwgXCJhbmNlc3RvcnNcIiwgXCJhbmRcIiwgXCJhbnk/XCIsIFwiYXBwbHlcIiwgXCJhcmVkdWNlXCIsIFwiYXJyYXktbWFwXCIsIFwiYXMtPlwiLCBcImFzZXRcIiwgXCJhc2V0LWJvb2xlYW5cIiwgXCJhc2V0LWJ5dGVcIiwgXCJhc2V0LWNoYXJcIiwgXCJhc2V0LWRvdWJsZVwiLCBcImFzZXQtZmxvYXRcIiwgXCJhc2V0LWludFwiLCBcImFzZXQtbG9uZ1wiLCBcImFzZXQtc2hvcnRcIiwgXCJhc3NlcnRcIiwgXCJhc3NvY1wiLCBcImFzc29jIVwiLCBcImFzc29jLWluXCIsIFwiYXNzb2NpYXRpdmU/XCIsIFwiYXRvbVwiLCBcImF3YWl0XCIsIFwiYXdhaXQtZm9yXCIsIFwiYXdhaXQxXCIsIFwiYmFzZXNcIiwgXCJiZWFuXCIsIFwiYmlnZGVjXCIsIFwiYmlnaW50XCIsIFwiYmlnaW50ZWdlclwiLCBcImJpbmRpbmdcIiwgXCJiaXQtYW5kXCIsIFwiYml0LWFuZC1ub3RcIiwgXCJiaXQtY2xlYXJcIiwgXCJiaXQtZmxpcFwiLCBcImJpdC1ub3RcIiwgXCJiaXQtb3JcIiwgXCJiaXQtc2V0XCIsIFwiYml0LXNoaWZ0LWxlZnRcIiwgXCJiaXQtc2hpZnQtcmlnaHRcIiwgXCJiaXQtdGVzdFwiLCBcImJpdC14b3JcIiwgXCJib29sZWFuXCIsIFwiYm9vbGVhbi1hcnJheVwiLCBcImJvb2xlYW4/XCIsIFwiYm9vbGVhbnNcIiwgXCJib3VuZC1mblwiLCBcImJvdW5kLWZuKlwiLCBcImJvdW5kP1wiLCBcImJvdW5kZWQtY291bnRcIiwgXCJidXRsYXN0XCIsIFwiYnl0ZVwiLCBcImJ5dGUtYXJyYXlcIiwgXCJieXRlc1wiLCBcImJ5dGVzP1wiLCBcImNhc2VcIiwgXCJjYXN0XCIsIFwiY2F0XCIsIFwiY2hhclwiLCBcImNoYXItYXJyYXlcIiwgXCJjaGFyLWVzY2FwZS1zdHJpbmdcIiwgXCJjaGFyLW5hbWUtc3RyaW5nXCIsIFwiY2hhcj9cIiwgXCJjaGFyc1wiLCBcImNodW5rXCIsIFwiY2h1bmstYXBwZW5kXCIsIFwiY2h1bmstYnVmZmVyXCIsIFwiY2h1bmstY29uc1wiLCBcImNodW5rLWZpcnN0XCIsIFwiY2h1bmstbmV4dFwiLCBcImNodW5rLXJlc3RcIiwgXCJjaHVua2VkLXNlcT9cIiwgXCJjbGFzc1wiLCBcImNsYXNzP1wiLCBcImNsZWFyLWFnZW50LWVycm9yc1wiLCBcImNsb2p1cmUtdmVyc2lvblwiLCBcImNvbGw/XCIsIFwiY29tbWVudFwiLCBcImNvbW11dGVcIiwgXCJjb21wXCIsIFwiY29tcGFyYXRvclwiLCBcImNvbXBhcmVcIiwgXCJjb21wYXJlLWFuZC1zZXQhXCIsIFwiY29tcGlsZVwiLCBcImNvbXBsZW1lbnRcIiwgXCJjb21wbGV0aW5nXCIsIFwiY29uY2F0XCIsIFwiY29uZFwiLCBcImNvbmQtPlwiLCBcImNvbmQtPj5cIiwgXCJjb25kcFwiLCBcImNvbmpcIiwgXCJjb25qIVwiLCBcImNvbnNcIiwgXCJjb25zdGFudGx5XCIsIFwiY29uc3RydWN0LXByb3h5XCIsIFwiY29udGFpbnM/XCIsIFwiY291bnRcIiwgXCJjb3VudGVkP1wiLCBcImNyZWF0ZS1uc1wiLCBcImNyZWF0ZS1zdHJ1Y3RcIiwgXCJjeWNsZVwiLCBcImRlY1wiLCBcImRlYydcIiwgXCJkZWNpbWFsP1wiLCBcImRlY2xhcmVcIiwgXCJkZWR1cGVcIiwgXCJkZWZhdWx0LWRhdGEtcmVhZGVyc1wiLCBcImRlZmlubGluZVwiLCBcImRlZmludGVyZmFjZVwiLCBcImRlZm1hY3JvXCIsIFwiZGVmbWV0aG9kXCIsIFwiZGVmbXVsdGlcIiwgXCJkZWZuXCIsIFwiZGVmbi1cIiwgXCJkZWZvbmNlXCIsIFwiZGVmcHJvdG9jb2xcIiwgXCJkZWZyZWNvcmRcIiwgXCJkZWZzdHJ1Y3RcIiwgXCJkZWZ0eXBlXCIsIFwiZGVsYXlcIiwgXCJkZWxheT9cIiwgXCJkZWxpdmVyXCIsIFwiZGVub21pbmF0b3JcIiwgXCJkZXJlZlwiLCBcImRlcml2ZVwiLCBcImRlc2NlbmRhbnRzXCIsIFwiZGVzdHJ1Y3R1cmVcIiwgXCJkaXNqXCIsIFwiZGlzaiFcIiwgXCJkaXNzb2NcIiwgXCJkaXNzb2MhXCIsIFwiZGlzdGluY3RcIiwgXCJkaXN0aW5jdD9cIiwgXCJkb2FsbFwiLCBcImRvcnVuXCIsIFwiZG9zZXFcIiwgXCJkb3N5bmNcIiwgXCJkb3RpbWVzXCIsIFwiZG90b1wiLCBcImRvdWJsZVwiLCBcImRvdWJsZS1hcnJheVwiLCBcImRvdWJsZT9cIiwgXCJkb3VibGVzXCIsIFwiZHJvcFwiLCBcImRyb3AtbGFzdFwiLCBcImRyb3Atd2hpbGVcIiwgXCJlZHVjdGlvblwiLCBcImVtcHR5XCIsIFwiZW1wdHk/XCIsIFwiZW5zdXJlXCIsIFwiZW5zdXJlLXJlZHVjZWRcIiwgXCJlbnVtZXJhdGlvbi1zZXFcIiwgXCJlcnJvci1oYW5kbGVyXCIsIFwiZXJyb3ItbW9kZVwiLCBcImV2YWxcIiwgXCJldmVuP1wiLCBcImV2ZXJ5LXByZWRcIiwgXCJldmVyeT9cIiwgXCJleC1kYXRhXCIsIFwiZXgtaW5mb1wiLCBcImV4dGVuZFwiLCBcImV4dGVuZC1wcm90b2NvbFwiLCBcImV4dGVuZC10eXBlXCIsIFwiZXh0ZW5kZXJzXCIsIFwiZXh0ZW5kcz9cIiwgXCJmYWxzZT9cIiwgXCJmZmlyc3RcIiwgXCJmaWxlLXNlcVwiLCBcImZpbHRlclwiLCBcImZpbHRlcnZcIiwgXCJmaW5kXCIsIFwiZmluZC1rZXl3b3JkXCIsIFwiZmluZC1uc1wiLCBcImZpbmQtcHJvdG9jb2wtaW1wbFwiLCBcImZpbmQtcHJvdG9jb2wtbWV0aG9kXCIsIFwiZmluZC12YXJcIiwgXCJmaXJzdFwiLCBcImZsYXR0ZW5cIiwgXCJmbG9hdFwiLCBcImZsb2F0LWFycmF5XCIsIFwiZmxvYXQ/XCIsIFwiZmxvYXRzXCIsIFwiZmx1c2hcIiwgXCJmblwiLCBcImZuP1wiLCBcImZuZXh0XCIsIFwiZm5pbFwiLCBcImZvclwiLCBcImZvcmNlXCIsIFwiZm9ybWF0XCIsIFwiZnJlcXVlbmNpZXNcIiwgXCJmdXR1cmVcIiwgXCJmdXR1cmUtY2FsbFwiLCBcImZ1dHVyZS1jYW5jZWxcIiwgXCJmdXR1cmUtY2FuY2VsbGVkP1wiLCBcImZ1dHVyZS1kb25lP1wiLCBcImZ1dHVyZT9cIiwgXCJnZW4tY2xhc3NcIiwgXCJnZW4taW50ZXJmYWNlXCIsIFwiZ2Vuc3ltXCIsIFwiZ2V0XCIsIFwiZ2V0LWluXCIsIFwiZ2V0LW1ldGhvZFwiLCBcImdldC1wcm94eS1jbGFzc1wiLCBcImdldC10aHJlYWQtYmluZGluZ3NcIiwgXCJnZXQtdmFsaWRhdG9yXCIsIFwiZ3JvdXAtYnlcIiwgXCJoYWx0LXdoZW5cIiwgXCJoYXNoXCIsIFwiaGFzaC1jb21iaW5lXCIsIFwiaGFzaC1tYXBcIiwgXCJoYXNoLW9yZGVyZWQtY29sbFwiLCBcImhhc2gtc2V0XCIsIFwiaGFzaC11bm9yZGVyZWQtY29sbFwiLCBcImlkZW50P1wiLCBcImlkZW50aWNhbD9cIiwgXCJpZGVudGl0eVwiLCBcImlmLWxldFwiLCBcImlmLW5vdFwiLCBcImlmLXNvbWVcIiwgXCJpZm4/XCIsIFwiaW1wb3J0XCIsIFwiaW4tbnNcIiwgXCJpbmNcIiwgXCJpbmMnXCIsIFwiaW5kZXhlZD9cIiwgXCJpbml0LXByb3h5XCIsIFwiaW5zdC1tc1wiLCBcImluc3QtbXMqXCIsIFwiaW5zdD9cIiwgXCJpbnN0YW5jZT9cIiwgXCJpbnRcIiwgXCJpbnQtYXJyYXlcIiwgXCJpbnQ/XCIsIFwiaW50ZWdlcj9cIiwgXCJpbnRlcmxlYXZlXCIsIFwiaW50ZXJuXCIsIFwiaW50ZXJwb3NlXCIsIFwiaW50b1wiLCBcImludG8tYXJyYXlcIiwgXCJpbnRzXCIsIFwiaW8hXCIsIFwiaXNhP1wiLCBcIml0ZXJhdGVcIiwgXCJpdGVyYXRvci1zZXFcIiwgXCJqdXh0XCIsIFwia2VlcFwiLCBcImtlZXAtaW5kZXhlZFwiLCBcImtleVwiLCBcImtleXNcIiwgXCJrZXl3b3JkXCIsIFwia2V5d29yZD9cIiwgXCJsYXN0XCIsIFwibGF6eS1jYXRcIiwgXCJsYXp5LXNlcVwiLCBcImxldFwiLCBcImxldGZuXCIsIFwibGluZS1zZXFcIiwgXCJsaXN0XCIsIFwibGlzdCpcIiwgXCJsaXN0P1wiLCBcImxvYWRcIiwgXCJsb2FkLWZpbGVcIiwgXCJsb2FkLXJlYWRlclwiLCBcImxvYWQtc3RyaW5nXCIsIFwibG9hZGVkLWxpYnNcIiwgXCJsb2NraW5nXCIsIFwibG9uZ1wiLCBcImxvbmctYXJyYXlcIiwgXCJsb25nc1wiLCBcImxvb3BcIiwgXCJtYWNyb2V4cGFuZFwiLCBcIm1hY3JvZXhwYW5kLTFcIiwgXCJtYWtlLWFycmF5XCIsIFwibWFrZS1oaWVyYXJjaHlcIiwgXCJtYXBcIiwgXCJtYXAtZW50cnk/XCIsIFwibWFwLWluZGV4ZWRcIiwgXCJtYXA/XCIsIFwibWFwY2F0XCIsIFwibWFwdlwiLCBcIm1heFwiLCBcIm1heC1rZXlcIiwgXCJtZW1mblwiLCBcIm1lbW9pemVcIiwgXCJtZXJnZVwiLCBcIm1lcmdlLXdpdGhcIiwgXCJtZXRhXCIsIFwibWV0aG9kLXNpZ1wiLCBcIm1ldGhvZHNcIiwgXCJtaW5cIiwgXCJtaW4ta2V5XCIsIFwibWl4LWNvbGxlY3Rpb24taGFzaFwiLCBcIm1vZFwiLCBcIm11bmdlXCIsIFwibmFtZVwiLCBcIm5hbWVzcGFjZVwiLCBcIm5hbWVzcGFjZS1tdW5nZVwiLCBcIm5hdC1pbnQ/XCIsIFwibmVnLWludD9cIiwgXCJuZWc/XCIsIFwibmV3bGluZVwiLCBcIm5leHRcIiwgXCJuZmlyc3RcIiwgXCJuaWw/XCIsIFwibm5leHRcIiwgXCJub3RcIiwgXCJub3QtYW55P1wiLCBcIm5vdC1lbXB0eVwiLCBcIm5vdC1ldmVyeT9cIiwgXCJub3Q9XCIsIFwibnNcIiwgXCJucy1hbGlhc2VzXCIsIFwibnMtaW1wb3J0c1wiLCBcIm5zLWludGVybnNcIiwgXCJucy1tYXBcIiwgXCJucy1uYW1lXCIsIFwibnMtcHVibGljc1wiLCBcIm5zLXJlZmVyc1wiLCBcIm5zLXJlc29sdmVcIiwgXCJucy11bmFsaWFzXCIsIFwibnMtdW5tYXBcIiwgXCJudGhcIiwgXCJudGhuZXh0XCIsIFwibnRocmVzdFwiLCBcIm51bVwiLCBcIm51bWJlcj9cIiwgXCJudW1lcmF0b3JcIiwgXCJvYmplY3QtYXJyYXlcIiwgXCJvZGQ/XCIsIFwib3JcIiwgXCJwYXJlbnRzXCIsIFwicGFydGlhbFwiLCBcInBhcnRpdGlvblwiLCBcInBhcnRpdGlvbi1hbGxcIiwgXCJwYXJ0aXRpb24tYnlcIiwgXCJwY2FsbHNcIiwgXCJwZWVrXCIsIFwicGVyc2lzdGVudCFcIiwgXCJwbWFwXCIsIFwicG9wXCIsIFwicG9wIVwiLCBcInBvcC10aHJlYWQtYmluZGluZ3NcIiwgXCJwb3MtaW50P1wiLCBcInBvcz9cIiwgXCJwclwiLCBcInByLXN0clwiLCBcInByZWZlci1tZXRob2RcIiwgXCJwcmVmZXJzXCIsIFwicHJpbWl0aXZlcy1jbGFzc25hbWVzXCIsIFwicHJpbnRcIiwgXCJwcmludC1jdG9yXCIsIFwicHJpbnQtZHVwXCIsIFwicHJpbnQtbWV0aG9kXCIsIFwicHJpbnQtc2ltcGxlXCIsIFwicHJpbnQtc3RyXCIsIFwicHJpbnRmXCIsIFwicHJpbnRsblwiLCBcInByaW50bG4tc3RyXCIsIFwicHJuXCIsIFwicHJuLXN0clwiLCBcInByb21pc2VcIiwgXCJwcm94eVwiLCBcInByb3h5LWNhbGwtd2l0aC1zdXBlclwiLCBcInByb3h5LW1hcHBpbmdzXCIsIFwicHJveHktbmFtZVwiLCBcInByb3h5LXN1cGVyXCIsIFwicHVzaC10aHJlYWQtYmluZGluZ3NcIiwgXCJwdmFsdWVzXCIsIFwicXVhbGlmaWVkLWlkZW50P1wiLCBcInF1YWxpZmllZC1rZXl3b3JkP1wiLCBcInF1YWxpZmllZC1zeW1ib2w/XCIsIFwicXVvdFwiLCBcInJhbmRcIiwgXCJyYW5kLWludFwiLCBcInJhbmQtbnRoXCIsIFwicmFuZG9tLXNhbXBsZVwiLCBcInJhbmdlXCIsIFwicmF0aW8/XCIsIFwicmF0aW9uYWw/XCIsIFwicmF0aW9uYWxpemVcIiwgXCJyZS1maW5kXCIsIFwicmUtZ3JvdXBzXCIsIFwicmUtbWF0Y2hlclwiLCBcInJlLW1hdGNoZXNcIiwgXCJyZS1wYXR0ZXJuXCIsIFwicmUtc2VxXCIsIFwicmVhZFwiLCBcInJlYWQtbGluZVwiLCBcInJlYWQtc3RyaW5nXCIsIFwicmVhZGVyLWNvbmRpdGlvbmFsXCIsIFwicmVhZGVyLWNvbmRpdGlvbmFsP1wiLCBcInJlYWxpemVkP1wiLCBcInJlY29yZD9cIiwgXCJyZWR1Y2VcIiwgXCJyZWR1Y2Uta3ZcIiwgXCJyZWR1Y2VkXCIsIFwicmVkdWNlZD9cIiwgXCJyZWR1Y3Rpb25zXCIsIFwicmVmXCIsIFwicmVmLWhpc3RvcnktY291bnRcIiwgXCJyZWYtbWF4LWhpc3RvcnlcIiwgXCJyZWYtbWluLWhpc3RvcnlcIiwgXCJyZWYtc2V0XCIsIFwicmVmZXJcIiwgXCJyZWZlci1jbG9qdXJlXCIsIFwicmVpZnlcIiwgXCJyZWxlYXNlLXBlbmRpbmctc2VuZHNcIiwgXCJyZW1cIiwgXCJyZW1vdmVcIiwgXCJyZW1vdmUtYWxsLW1ldGhvZHNcIiwgXCJyZW1vdmUtbWV0aG9kXCIsIFwicmVtb3ZlLW5zXCIsIFwicmVtb3ZlLXdhdGNoXCIsIFwicmVwZWF0XCIsIFwicmVwZWF0ZWRseVwiLCBcInJlcGxhY2VcIiwgXCJyZXBsaWNhdGVcIiwgXCJyZXF1aXJlXCIsIFwicmVzZXQhXCIsIFwicmVzZXQtbWV0YSFcIiwgXCJyZXNldC12YWxzIVwiLCBcInJlc29sdmVcIiwgXCJyZXN0XCIsIFwicmVzdGFydC1hZ2VudFwiLCBcInJlc3VsdHNldC1zZXFcIiwgXCJyZXZlcnNlXCIsIFwicmV2ZXJzaWJsZT9cIiwgXCJyc2VxXCIsIFwicnN1YnNlcVwiLCBcInJ1biFcIiwgXCJzYXRpc2ZpZXM/XCIsIFwic2Vjb25kXCIsIFwic2VsZWN0LWtleXNcIiwgXCJzZW5kXCIsIFwic2VuZC1vZmZcIiwgXCJzZW5kLXZpYVwiLCBcInNlcVwiLCBcInNlcT9cIiwgXCJzZXFhYmxlP1wiLCBcInNlcXVlXCIsIFwic2VxdWVuY2VcIiwgXCJzZXF1ZW50aWFsP1wiLCBcInNldFwiLCBcInNldC1hZ2VudC1zZW5kLWV4ZWN1dG9yIVwiLCBcInNldC1hZ2VudC1zZW5kLW9mZi1leGVjdXRvciFcIiwgXCJzZXQtZXJyb3ItaGFuZGxlciFcIiwgXCJzZXQtZXJyb3ItbW9kZSFcIiwgXCJzZXQtdmFsaWRhdG9yIVwiLCBcInNldD9cIiwgXCJzaG9ydFwiLCBcInNob3J0LWFycmF5XCIsIFwic2hvcnRzXCIsIFwic2h1ZmZsZVwiLCBcInNodXRkb3duLWFnZW50c1wiLCBcInNpbXBsZS1pZGVudD9cIiwgXCJzaW1wbGUta2V5d29yZD9cIiwgXCJzaW1wbGUtc3ltYm9sP1wiLCBcInNsdXJwXCIsIFwic29tZVwiLCBcInNvbWUtPlwiLCBcInNvbWUtPj5cIiwgXCJzb21lLWZuXCIsIFwic29tZT9cIiwgXCJzb3J0XCIsIFwic29ydC1ieVwiLCBcInNvcnRlZC1tYXBcIiwgXCJzb3J0ZWQtbWFwLWJ5XCIsIFwic29ydGVkLXNldFwiLCBcInNvcnRlZC1zZXQtYnlcIiwgXCJzb3J0ZWQ/XCIsIFwic3BlY2lhbC1zeW1ib2w/XCIsIFwic3BpdFwiLCBcInNwbGl0LWF0XCIsIFwic3BsaXQtd2l0aFwiLCBcInN0clwiLCBcInN0cmluZz9cIiwgXCJzdHJ1Y3RcIiwgXCJzdHJ1Y3QtbWFwXCIsIFwic3Vic1wiLCBcInN1YnNlcVwiLCBcInN1YnZlY1wiLCBcInN1cGVyc1wiLCBcInN3YXAhXCIsIFwic3dhcC12YWxzIVwiLCBcInN5bWJvbFwiLCBcInN5bWJvbD9cIiwgXCJzeW5jXCIsIFwidGFnZ2VkLWxpdGVyYWxcIiwgXCJ0YWdnZWQtbGl0ZXJhbD9cIiwgXCJ0YWtlXCIsIFwidGFrZS1sYXN0XCIsIFwidGFrZS1udGhcIiwgXCJ0YWtlLXdoaWxlXCIsIFwidGVzdFwiLCBcInRoZS1uc1wiLCBcInRocmVhZC1ib3VuZD9cIiwgXCJ0aW1lXCIsIFwidG8tYXJyYXlcIiwgXCJ0by1hcnJheS0yZFwiLCBcInRyYW1wb2xpbmVcIiwgXCJ0cmFuc2R1Y2VcIiwgXCJ0cmFuc2llbnRcIiwgXCJ0cmVlLXNlcVwiLCBcInRydWU/XCIsIFwidHlwZVwiLCBcInVuY2hlY2tlZC1hZGRcIiwgXCJ1bmNoZWNrZWQtYWRkLWludFwiLCBcInVuY2hlY2tlZC1ieXRlXCIsIFwidW5jaGVja2VkLWNoYXJcIiwgXCJ1bmNoZWNrZWQtZGVjXCIsIFwidW5jaGVja2VkLWRlYy1pbnRcIiwgXCJ1bmNoZWNrZWQtZGl2aWRlLWludFwiLCBcInVuY2hlY2tlZC1kb3VibGVcIiwgXCJ1bmNoZWNrZWQtZmxvYXRcIiwgXCJ1bmNoZWNrZWQtaW5jXCIsIFwidW5jaGVja2VkLWluYy1pbnRcIiwgXCJ1bmNoZWNrZWQtaW50XCIsIFwidW5jaGVja2VkLWxvbmdcIiwgXCJ1bmNoZWNrZWQtbXVsdGlwbHlcIiwgXCJ1bmNoZWNrZWQtbXVsdGlwbHktaW50XCIsIFwidW5jaGVja2VkLW5lZ2F0ZVwiLCBcInVuY2hlY2tlZC1uZWdhdGUtaW50XCIsIFwidW5jaGVja2VkLXJlbWFpbmRlci1pbnRcIiwgXCJ1bmNoZWNrZWQtc2hvcnRcIiwgXCJ1bmNoZWNrZWQtc3VidHJhY3RcIiwgXCJ1bmNoZWNrZWQtc3VidHJhY3QtaW50XCIsIFwidW5kZXJpdmVcIiwgXCJ1bnF1b3RlXCIsIFwidW5xdW90ZS1zcGxpY2luZ1wiLCBcInVucmVkdWNlZFwiLCBcInVuc2lnbmVkLWJpdC1zaGlmdC1yaWdodFwiLCBcInVwZGF0ZVwiLCBcInVwZGF0ZS1pblwiLCBcInVwZGF0ZS1wcm94eVwiLCBcInVyaT9cIiwgXCJ1c2VcIiwgXCJ1dWlkP1wiLCBcInZhbFwiLCBcInZhbHNcIiwgXCJ2YXItZ2V0XCIsIFwidmFyLXNldFwiLCBcInZhcj9cIiwgXCJ2YXJ5LW1ldGFcIiwgXCJ2ZWNcIiwgXCJ2ZWN0b3JcIiwgXCJ2ZWN0b3Itb2ZcIiwgXCJ2ZWN0b3I/XCIsIFwidm9sYXRpbGUhXCIsIFwidm9sYXRpbGU/XCIsIFwidnJlc2V0IVwiLCBcInZzd2FwIVwiLCBcIndoZW5cIiwgXCJ3aGVuLWZpcnN0XCIsIFwid2hlbi1sZXRcIiwgXCJ3aGVuLW5vdFwiLCBcIndoZW4tc29tZVwiLCBcIndoaWxlXCIsIFwid2l0aC1iaW5kaW5nc1wiLCBcIndpdGgtYmluZGluZ3MqXCIsIFwid2l0aC1pbi1zdHJcIiwgXCJ3aXRoLWxvYWRpbmctY29udGV4dFwiLCBcIndpdGgtbG9jYWwtdmFyc1wiLCBcIndpdGgtbWV0YVwiLCBcIndpdGgtb3BlblwiLCBcIndpdGgtb3V0LXN0clwiLCBcIndpdGgtcHJlY2lzaW9uXCIsIFwid2l0aC1yZWRlZnNcIiwgXCJ3aXRoLXJlZGVmcy1mblwiLCBcInhtbC1zZXFcIiwgXCJ6ZXJvP1wiLCBcInppcG1hcFwiXTtcbnZhciBoYXZlQm9keVBhcmFtZXRlciA9IFtcIi0+XCIsIFwiLT4+XCIsIFwiYXMtPlwiLCBcImJpbmRpbmdcIiwgXCJib3VuZC1mblwiLCBcImNhc2VcIiwgXCJjYXRjaFwiLCBcImNvbW1lbnRcIiwgXCJjb25kXCIsIFwiY29uZC0+XCIsIFwiY29uZC0+PlwiLCBcImNvbmRwXCIsIFwiZGVmXCIsIFwiZGVmaW50ZXJmYWNlXCIsIFwiZGVmbWV0aG9kXCIsIFwiZGVmblwiLCBcImRlZm1hY3JvXCIsIFwiZGVmcHJvdG9jb2xcIiwgXCJkZWZyZWNvcmRcIiwgXCJkZWZzdHJ1Y3RcIiwgXCJkZWZ0eXBlXCIsIFwiZG9cIiwgXCJkb3NlcVwiLCBcImRvdGltZXNcIiwgXCJkb3RvXCIsIFwiZXh0ZW5kXCIsIFwiZXh0ZW5kLXByb3RvY29sXCIsIFwiZXh0ZW5kLXR5cGVcIiwgXCJmblwiLCBcImZvclwiLCBcImZ1dHVyZVwiLCBcImlmXCIsIFwiaWYtbGV0XCIsIFwiaWYtbm90XCIsIFwiaWYtc29tZVwiLCBcImxldFwiLCBcImxldGZuXCIsIFwibG9ja2luZ1wiLCBcImxvb3BcIiwgXCJuc1wiLCBcInByb3h5XCIsIFwicmVpZnlcIiwgXCJzdHJ1Y3QtbWFwXCIsIFwic29tZS0+XCIsIFwic29tZS0+PlwiLCBcInRyeVwiLCBcIndoZW5cIiwgXCJ3aGVuLWZpcnN0XCIsIFwid2hlbi1sZXRcIiwgXCJ3aGVuLW5vdFwiLCBcIndoZW4tc29tZVwiLCBcIndoaWxlXCIsIFwid2l0aC1iaW5kaW5nc1wiLCBcIndpdGgtYmluZGluZ3MqXCIsIFwid2l0aC1pbi1zdHJcIiwgXCJ3aXRoLWxvYWRpbmctY29udGV4dFwiLCBcIndpdGgtbG9jYWwtdmFyc1wiLCBcIndpdGgtbWV0YVwiLCBcIndpdGgtb3BlblwiLCBcIndpdGgtb3V0LXN0clwiLCBcIndpdGgtcHJlY2lzaW9uXCIsIFwid2l0aC1yZWRlZnNcIiwgXCJ3aXRoLXJlZGVmcy1mblwiXTtcbnZhciBhdG9tID0gY3JlYXRlTG9va3VwTWFwKGF0b21zKTtcbnZhciBzcGVjaWFsRm9ybSA9IGNyZWF0ZUxvb2t1cE1hcChzcGVjaWFsRm9ybXMpO1xudmFyIGNvcmVTeW1ib2wgPSBjcmVhdGVMb29rdXBNYXAoY29yZVN5bWJvbHMpO1xudmFyIGhhc0JvZHlQYXJhbWV0ZXIgPSBjcmVhdGVMb29rdXBNYXAoaGF2ZUJvZHlQYXJhbWV0ZXIpO1xudmFyIGRlbGltaXRlciA9IC9eKD86W1xcXFxcXFtcXF1cXHNcIigpLDtAXmB7fX5dfCQpLztcbnZhciBudW1iZXJMaXRlcmFsID0gL14oPzpbK1xcLV0/XFxkKyg/Oig/Ok58KD86W2VFXVsrXFwtXT9cXGQrKSl8KD86XFwuP1xcZCooPzpNfCg/OltlRV1bK1xcLV0/XFxkKykpPyl8XFwvXFxkK3xbeFhdWzAtOWEtZkEtRl0rfHJbMC05YS16QS1aXSspPyg/PVtcXFxcXFxbXFxdXFxzXCIjJygpLDtAXmB7fX5dfCQpKS87XG52YXIgY2hhcmFjdGVyTGl0ZXJhbCA9IC9eKD86XFxcXCg/OmJhY2tzcGFjZXxmb3JtZmVlZHxuZXdsaW5lfHJldHVybnxzcGFjZXx0YWJ8b1swLTddezN9fHVbMC05QS1GYS1mXXs0fXx4WzAtOUEtRmEtZl17NH18Lik/KD89W1xcXFxcXFtcXF1cXHNcIigpLDtAXmB7fX5dfCQpKS87XG5cbi8vIHNpbXBsZS1uYW1lc3BhY2UgOj0gL15bXlxcXFxcXC9cXFtcXF1cXGRcXHNcIiMnKCksO0BeYHt9fi5dW15cXFxcXFxbXFxdXFxzXCIoKSw7QF5ge31+LlxcL10qL1xuLy8gc2ltcGxlLXN5bWJvbCAgICA6PSAvXig/OlxcL3xbXlxcXFxcXC9cXFtcXF1cXGRcXHNcIiMnKCksO0BeYHt9fl1bXlxcXFxcXFtcXF1cXHNcIigpLDtAXmB7fX5dKikvXG4vLyBxdWFsaWZpZWQtc3ltYm9sIDo9ICg8c2ltcGxlLW5hbWVzcGFjZT4oPC4+PHNpbXBsZS1uYW1lc3BhY2U+KSo8Lz4pPzxzaW1wbGUtc3ltYm9sPlxudmFyIHF1YWxpZmllZFN5bWJvbCA9IC9eKD86KD86W15cXFxcXFwvXFxbXFxdXFxkXFxzXCIjJygpLDtAXmB7fX4uXVteXFxcXFxcW1xcXVxcc1wiKCksO0BeYHt9fi5cXC9dKig/OlxcLlteXFxcXFxcL1xcW1xcXVxcZFxcc1wiIycoKSw7QF5ge31+Ll1bXlxcXFxcXFtcXF1cXHNcIigpLDtAXmB7fX4uXFwvXSopKlxcLyk/KD86XFwvfFteXFxcXFxcL1xcW1xcXVxcZFxcc1wiIycoKSw7QF5ge31+XVteXFxcXFxcW1xcXVxcc1wiKCksO0BeYHt9fl0qKSooPz1bXFxcXFxcW1xcXVxcc1wiKCksO0BeYHt9fl18JCkpLztcbmZ1bmN0aW9uIGJhc2Uoc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoc3RyZWFtLmVhdFNwYWNlKCkgfHwgc3RyZWFtLmVhdChcIixcIikpIHJldHVybiBbXCJzcGFjZVwiLCBudWxsXTtcbiAgaWYgKHN0cmVhbS5tYXRjaChudW1iZXJMaXRlcmFsKSkgcmV0dXJuIFtudWxsLCBcIm51bWJlclwiXTtcbiAgaWYgKHN0cmVhbS5tYXRjaChjaGFyYWN0ZXJMaXRlcmFsKSkgcmV0dXJuIFtudWxsLCBcInN0cmluZy5zcGVjaWFsXCJdO1xuICBpZiAoc3RyZWFtLmVhdCgvXlwiLykpIHJldHVybiAoc3RhdGUudG9rZW5pemUgPSBpblN0cmluZykoc3RyZWFtLCBzdGF0ZSk7XG4gIGlmIChzdHJlYW0uZWF0KC9eWyhcXFt7XS8pKSByZXR1cm4gW1wib3BlblwiLCBcImJyYWNrZXRcIl07XG4gIGlmIChzdHJlYW0uZWF0KC9eWylcXF19XS8pKSByZXR1cm4gW1wiY2xvc2VcIiwgXCJicmFja2V0XCJdO1xuICBpZiAoc3RyZWFtLmVhdCgvXjsvKSkge1xuICAgIHN0cmVhbS5za2lwVG9FbmQoKTtcbiAgICByZXR1cm4gW1wic3BhY2VcIiwgXCJjb21tZW50XCJdO1xuICB9XG4gIGlmIChzdHJlYW0uZWF0KC9eWyMnQF5gfl0vKSkgcmV0dXJuIFtudWxsLCBcIm1ldGFcIl07XG4gIHZhciBtYXRjaGVzID0gc3RyZWFtLm1hdGNoKHF1YWxpZmllZFN5bWJvbCk7XG4gIHZhciBzeW1ib2wgPSBtYXRjaGVzICYmIG1hdGNoZXNbMF07XG4gIGlmICghc3ltYm9sKSB7XG4gICAgLy8gYWR2YW5jZSBzdHJlYW0gYnkgYXQgbGVhc3Qgb25lIGNoYXJhY3RlciBzbyB3ZSBkb24ndCBnZXQgc3R1Y2suXG4gICAgc3RyZWFtLm5leHQoKTtcbiAgICBzdHJlYW0uZWF0V2hpbGUoZnVuY3Rpb24gKGMpIHtcbiAgICAgIHJldHVybiAhaXMoYywgZGVsaW1pdGVyKTtcbiAgICB9KTtcbiAgICByZXR1cm4gW251bGwsIFwiZXJyb3JcIl07XG4gIH1cbiAgaWYgKHN5bWJvbCA9PT0gXCJjb21tZW50XCIgJiYgc3RhdGUubGFzdFRva2VuID09PSBcIihcIikgcmV0dXJuIChzdGF0ZS50b2tlbml6ZSA9IGluQ29tbWVudCkoc3RyZWFtLCBzdGF0ZSk7XG4gIGlmIChpcyhzeW1ib2wsIGF0b20pIHx8IHN5bWJvbC5jaGFyQXQoMCkgPT09IFwiOlwiKSByZXR1cm4gW1wic3ltYm9sXCIsIFwiYXRvbVwiXTtcbiAgaWYgKGlzKHN5bWJvbCwgc3BlY2lhbEZvcm0pIHx8IGlzKHN5bWJvbCwgY29yZVN5bWJvbCkpIHJldHVybiBbXCJzeW1ib2xcIiwgXCJrZXl3b3JkXCJdO1xuICBpZiAoc3RhdGUubGFzdFRva2VuID09PSBcIihcIikgcmV0dXJuIFtcInN5bWJvbFwiLCBcImJ1aWx0aW5cIl07IC8vIG90aGVyIG9wZXJhdG9yXG5cbiAgcmV0dXJuIFtcInN5bWJvbFwiLCBcInZhcmlhYmxlXCJdO1xufVxuZnVuY3Rpb24gaW5TdHJpbmcoc3RyZWFtLCBzdGF0ZSkge1xuICB2YXIgZXNjYXBlZCA9IGZhbHNlLFxuICAgIG5leHQ7XG4gIHdoaWxlIChuZXh0ID0gc3RyZWFtLm5leHQoKSkge1xuICAgIGlmIChuZXh0ID09PSBcIlxcXCJcIiAmJiAhZXNjYXBlZCkge1xuICAgICAgc3RhdGUudG9rZW5pemUgPSBiYXNlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGVzY2FwZWQgPSAhZXNjYXBlZCAmJiBuZXh0ID09PSBcIlxcXFxcIjtcbiAgfVxuICByZXR1cm4gW251bGwsIFwic3RyaW5nXCJdO1xufVxuZnVuY3Rpb24gaW5Db21tZW50KHN0cmVhbSwgc3RhdGUpIHtcbiAgdmFyIHBhcmVudGhlc2lzQ291bnQgPSAxO1xuICB2YXIgbmV4dDtcbiAgd2hpbGUgKG5leHQgPSBzdHJlYW0ubmV4dCgpKSB7XG4gICAgaWYgKG5leHQgPT09IFwiKVwiKSBwYXJlbnRoZXNpc0NvdW50LS07XG4gICAgaWYgKG5leHQgPT09IFwiKFwiKSBwYXJlbnRoZXNpc0NvdW50Kys7XG4gICAgaWYgKHBhcmVudGhlc2lzQ291bnQgPT09IDApIHtcbiAgICAgIHN0cmVhbS5iYWNrVXAoMSk7XG4gICAgICBzdGF0ZS50b2tlbml6ZSA9IGJhc2U7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIFtcInNwYWNlXCIsIFwiY29tbWVudFwiXTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUxvb2t1cE1hcCh3b3Jkcykge1xuICB2YXIgb2JqID0ge307XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgd29yZHMubGVuZ3RoOyArK2kpIG9ialt3b3Jkc1tpXV0gPSB0cnVlO1xuICByZXR1cm4gb2JqO1xufVxuZnVuY3Rpb24gaXModmFsdWUsIHRlc3QpIHtcbiAgaWYgKHRlc3QgaW5zdGFuY2VvZiBSZWdFeHApIHJldHVybiB0ZXN0LnRlc3QodmFsdWUpO1xuICBpZiAodGVzdCBpbnN0YW5jZW9mIE9iamVjdCkgcmV0dXJuIHRlc3QucHJvcGVydHlJc0VudW1lcmFibGUodmFsdWUpO1xufVxuZXhwb3J0IGNvbnN0IGNsb2p1cmUgPSB7XG4gIG5hbWU6IFwiY2xvanVyZVwiLFxuICBzdGFydFN0YXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGN0eDoge1xuICAgICAgICBwcmV2OiBudWxsLFxuICAgICAgICBzdGFydDogMCxcbiAgICAgICAgaW5kZW50VG86IDBcbiAgICAgIH0sXG4gICAgICBsYXN0VG9rZW46IG51bGwsXG4gICAgICB0b2tlbml6ZTogYmFzZVxuICAgIH07XG4gIH0sXG4gIHRva2VuOiBmdW5jdGlvbiAoc3RyZWFtLCBzdGF0ZSkge1xuICAgIGlmIChzdHJlYW0uc29sKCkgJiYgdHlwZW9mIHN0YXRlLmN0eC5pbmRlbnRUbyAhPT0gXCJudW1iZXJcIikgc3RhdGUuY3R4LmluZGVudFRvID0gc3RhdGUuY3R4LnN0YXJ0ICsgMTtcbiAgICB2YXIgdHlwZVN0eWxlUGFpciA9IHN0YXRlLnRva2VuaXplKHN0cmVhbSwgc3RhdGUpO1xuICAgIHZhciB0eXBlID0gdHlwZVN0eWxlUGFpclswXTtcbiAgICB2YXIgc3R5bGUgPSB0eXBlU3R5bGVQYWlyWzFdO1xuICAgIHZhciBjdXJyZW50ID0gc3RyZWFtLmN1cnJlbnQoKTtcbiAgICBpZiAodHlwZSAhPT0gXCJzcGFjZVwiKSB7XG4gICAgICBpZiAoc3RhdGUubGFzdFRva2VuID09PSBcIihcIiAmJiBzdGF0ZS5jdHguaW5kZW50VG8gPT09IG51bGwpIHtcbiAgICAgICAgaWYgKHR5cGUgPT09IFwic3ltYm9sXCIgJiYgaXMoY3VycmVudCwgaGFzQm9keVBhcmFtZXRlcikpIHN0YXRlLmN0eC5pbmRlbnRUbyA9IHN0YXRlLmN0eC5zdGFydCArIHN0cmVhbS5pbmRlbnRVbml0O2Vsc2Ugc3RhdGUuY3R4LmluZGVudFRvID0gXCJuZXh0XCI7XG4gICAgICB9IGVsc2UgaWYgKHN0YXRlLmN0eC5pbmRlbnRUbyA9PT0gXCJuZXh0XCIpIHtcbiAgICAgICAgc3RhdGUuY3R4LmluZGVudFRvID0gc3RyZWFtLmNvbHVtbigpO1xuICAgICAgfVxuICAgICAgc3RhdGUubGFzdFRva2VuID0gY3VycmVudDtcbiAgICB9XG4gICAgaWYgKHR5cGUgPT09IFwib3BlblwiKSBzdGF0ZS5jdHggPSB7XG4gICAgICBwcmV2OiBzdGF0ZS5jdHgsXG4gICAgICBzdGFydDogc3RyZWFtLmNvbHVtbigpLFxuICAgICAgaW5kZW50VG86IG51bGxcbiAgICB9O2Vsc2UgaWYgKHR5cGUgPT09IFwiY2xvc2VcIikgc3RhdGUuY3R4ID0gc3RhdGUuY3R4LnByZXYgfHwgc3RhdGUuY3R4O1xuICAgIHJldHVybiBzdHlsZTtcbiAgfSxcbiAgaW5kZW50OiBmdW5jdGlvbiAoc3RhdGUpIHtcbiAgICB2YXIgaSA9IHN0YXRlLmN0eC5pbmRlbnRUbztcbiAgICByZXR1cm4gdHlwZW9mIGkgPT09IFwibnVtYmVyXCIgPyBpIDogc3RhdGUuY3R4LnN0YXJ0ICsgMTtcbiAgfSxcbiAgbGFuZ3VhZ2VEYXRhOiB7XG4gICAgY2xvc2VCcmFja2V0czoge1xuICAgICAgYnJhY2tldHM6IFtcIihcIiwgXCJbXCIsIFwie1wiLCAnXCInXVxuICAgIH0sXG4gICAgY29tbWVudFRva2Vuczoge1xuICAgICAgbGluZTogXCI7O1wiXG4gICAgfSxcbiAgICBhdXRvY29tcGxldGU6IFtdLmNvbmNhdChhdG9tcywgc3BlY2lhbEZvcm1zLCBjb3JlU3ltYm9scylcbiAgfVxufTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=