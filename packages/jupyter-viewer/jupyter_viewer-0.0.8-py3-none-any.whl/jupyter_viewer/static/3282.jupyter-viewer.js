"use strict";
(self["webpackChunk_datalayer_jupyter_viewer"] = self["webpackChunk_datalayer_jupyter_viewer"] || []).push([[3282],{

/***/ 13282:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "autoCloseTags": () => (/* binding */ autoCloseTags),
  "completeFromSchema": () => (/* binding */ completeFromSchema),
  "xml": () => (/* binding */ xml),
  "xmlLanguage": () => (/* binding */ xmlLanguage)
});

// EXTERNAL MODULE: ./node_modules/@lezer/lr/dist/index.js
var dist = __webpack_require__(37734);
// EXTERNAL MODULE: ./node_modules/@lezer/highlight/dist/index.js
var highlight_dist = __webpack_require__(36345);
;// CONCATENATED MODULE: ./node_modules/@lezer/xml/dist/index.js



// This file was generated by lezer-generator. You probably shouldn't edit it.
const StartTag = 1,
  StartCloseTag = 2,
  MissingCloseTag = 3,
  mismatchedStartCloseTag = 4,
  incompleteStartCloseTag = 5,
  commentContent$1 = 35,
  piContent$1 = 36,
  cdataContent$1 = 37,
  Element = 11,
  OpenTag = 13;

/* Hand-written tokenizer for XML tag matching. */

function nameChar(ch) {
  return ch == 45 || ch == 46 || ch == 58 || ch >= 65 && ch <= 90 || ch == 95 || ch >= 97 && ch <= 122 || ch >= 161;
}
function isSpace(ch) {
  return ch == 9 || ch == 10 || ch == 13 || ch == 32;
}
let cachedName = null,
  cachedInput = null,
  cachedPos = 0;
function tagNameAfter(input, offset) {
  let pos = input.pos + offset;
  if (cachedInput == input && cachedPos == pos) return cachedName;
  while (isSpace(input.peek(offset))) offset++;
  let name = "";
  for (;;) {
    let next = input.peek(offset);
    if (!nameChar(next)) break;
    name += String.fromCharCode(next);
    offset++;
  }
  cachedInput = input;
  cachedPos = pos;
  return cachedName = name || null;
}
function ElementContext(name, parent) {
  this.name = name;
  this.parent = parent;
  this.hash = parent ? parent.hash : 0;
  for (let i = 0; i < name.length; i++) this.hash += (this.hash << 4) + name.charCodeAt(i) + (name.charCodeAt(i) << 8);
}
const elementContext = new dist/* ContextTracker */.IK({
  start: null,
  shift(context, term, stack, input) {
    return term == StartTag ? new ElementContext(tagNameAfter(input, 1) || "", context) : context;
  },
  reduce(context, term) {
    return term == Element && context ? context.parent : context;
  },
  reuse(context, node, _stack, input) {
    let type = node.type.id;
    return type == StartTag || type == OpenTag ? new ElementContext(tagNameAfter(input, 1) || "", context) : context;
  },
  hash(context) {
    return context ? context.hash : 0;
  },
  strict: false
});
const startTag = new dist/* ExternalTokenizer */.Jq((input, stack) => {
  if (input.next != 60 /* '<' */) return;
  input.advance();
  if (input.next == 47 /* '/' */) {
    input.advance();
    let name = tagNameAfter(input, 0);
    if (!name) return input.acceptToken(incompleteStartCloseTag);
    if (stack.context && name == stack.context.name) return input.acceptToken(StartCloseTag);
    for (let cx = stack.context; cx; cx = cx.parent) if (cx.name == name) return input.acceptToken(MissingCloseTag, -2);
    input.acceptToken(mismatchedStartCloseTag);
  } else if (input.next != 33 /* '!' */ && input.next != 63 /* '?' */) {
    return input.acceptToken(StartTag);
  }
}, {
  contextual: true
});
function scanTo(type, end) {
  return new dist/* ExternalTokenizer */.Jq(input => {
    let len = 0,
      first = end.charCodeAt(0);
    scan: for (;; input.advance(), len++) {
      if (input.next < 0) break;
      if (input.next == first) {
        for (let i = 1; i < end.length; i++) if (input.peek(i) != end.charCodeAt(i)) continue scan;
        break;
      }
    }
    if (len) input.acceptToken(type);
  });
}
const commentContent = scanTo(commentContent$1, "-->");
const piContent = scanTo(piContent$1, "?>");
const cdataContent = scanTo(cdataContent$1, "]]>");
const xmlHighlighting = (0,highlight_dist/* styleTags */.Gv)({
  Text: highlight_dist/* tags.content */.pJ.content,
  "StartTag StartCloseTag EndTag SelfCloseEndTag": highlight_dist/* tags.angleBracket */.pJ.angleBracket,
  TagName: highlight_dist/* tags.tagName */.pJ.tagName,
  "MismatchedCloseTag/TagName": [highlight_dist/* tags.tagName */.pJ.tagName, highlight_dist/* tags.invalid */.pJ.invalid],
  AttributeName: highlight_dist/* tags.attributeName */.pJ.attributeName,
  AttributeValue: highlight_dist/* tags.attributeValue */.pJ.attributeValue,
  Is: highlight_dist/* tags.definitionOperator */.pJ.definitionOperator,
  "EntityReference CharacterReference": highlight_dist/* tags.character */.pJ.character,
  Comment: highlight_dist/* tags.blockComment */.pJ.blockComment,
  ProcessingInst: highlight_dist/* tags.processingInstruction */.pJ.processingInstruction,
  DoctypeDecl: highlight_dist/* tags.documentMeta */.pJ.documentMeta,
  Cdata: highlight_dist/* tags.special */.pJ.special(highlight_dist/* tags.string */.pJ.string)
});

// This file was generated by lezer-generator. You probably shouldn't edit it.
const parser = dist/* LRParser.deserialize */.WQ.deserialize({
  version: 14,
  states: ",SOQOaOOOrOxO'#CfOzOpO'#CiO!tOaO'#CgOOOP'#Cg'#CgO!{OrO'#CrO#TOtO'#CsO#]OpO'#CtOOOP'#DS'#DSOOOP'#Cv'#CvQQOaOOOOOW'#Cw'#CwO#eOxO,59QOOOP,59Q,59QOOOO'#Cx'#CxO#mOpO,59TO#uO!bO,59TOOOP'#C{'#C{O$TOaO,59RO$[OpO'#CoOOOP,59R,59ROOOQ'#C|'#C|O$dOrO,59^OOOP,59^,59^OOOS'#C}'#C}O$lOtO,59_OOOP,59_,59_O$tOpO,59`O$|OpO,59`OOOP-E6t-E6tOOOW-E6u-E6uOOOP1G.l1G.lOOOO-E6v-E6vO%UO!bO1G.oO%UO!bO1G.oO%dOpO'#CkO%lO!bO'#CyO%zO!bO1G.oOOOP1G.o1G.oOOOP1G.w1G.wOOOP-E6y-E6yOOOP1G.m1G.mO&VOpO,59ZO&_OpO,59ZOOOQ-E6z-E6zOOOP1G.x1G.xOOOS-E6{-E6{OOOP1G.y1G.yO&gOpO1G.zO&gOpO1G.zOOOP1G.z1G.zO&oO!bO7+$ZO&}O!bO7+$ZOOOP7+$Z7+$ZOOOP7+$c7+$cO'YOpO,59VO'bOpO,59VO'jO!bO,59eOOOO-E6w-E6wO'xOpO1G.uO'xOpO1G.uOOOP1G.u1G.uO(QOpO7+$fOOOP7+$f7+$fO(YO!bO<<GuOOOP<<Gu<<GuOOOP<<G}<<G}O'bOpO1G.qO'bOpO1G.qO(eO#tO'#CnOOOO1G.q1G.qO(sOpO7+$aOOOP7+$a7+$aOOOP<<HQ<<HQOOOPAN=aAN=aOOOPAN=iAN=iO'bOpO7+$]OOOO7+$]7+$]OOOO'#Cz'#CzO({O#tO,59YOOOO,59Y,59YOOOP<<G{<<G{OOOO<<Gw<<GwOOOO-E6x-E6xOOOO1G.t1G.t",
  stateData: ")Z~OPQOSVOTWOVWOWWOXWOiXOxPO}TO!PUO~OuZOw]O~O^`Oy^O~OPQOQcOSVOTWOVWOWWOXWOxPO}TO!PUO~ORdO~P!SOseO|gO~OthO!OjO~O^lOy^O~OuZOwoO~O^qOy^O~O[vO`sOdwOy^O~ORyO~P!SO^{Oy^O~OseO|}O~OthO!O!PO~O^!QOy^O~O[!SOy^O~O[!VO`sOd!WOy^O~Oa!YOy^O~Oy^O[mX`mXdmX~O[!VO`sOd!WO~O^!]Oy^O~O[!_Oy^O~O[!aOy^O~O[!cO`sOd!dOy^O~O[!cO`sOd!dO~Oa!eOy^O~Oy^Oz!gO~Oy^O[ma`madma~O[!jOy^O~O[!kOy^O~O[!lO`sOd!mO~OW!pOX!pOz!rO{!pO~O[!sOy^O~OW!pOX!pOz!vO{!pO~O",
  goto: "%[wPPPPPPPPPPxxP!OP!UPP!_!iP!oxxxP!u!{#R$Z$j$p$v$|PPPP%SXWORYbXRORYb_t`qru!T!U!bQ!h!YS!o!e!fR!t!nQdRRybXSORYbQYORmYQ[PRn[Q_QQkVjp_krz!R!T!X!Z!^!`!f!i!nQr`QzcQ!RlQ!TqQ!XsQ!ZtQ!^{Q!`!QQ!f!YQ!i!]R!n!eQu`S!UqrU![u!U!bR!b!TQ!q!gR!u!qQbRRxbQfTR|fQiUR!OiSXOYTaRb",
  nodeNames: "âš  StartTag StartCloseTag MissingCloseTag StartCloseTag StartCloseTag Document Text EntityReference CharacterReference Cdata Element EndTag OpenTag TagName Attribute AttributeName Is AttributeValue CloseTag SelfCloseEndTag SelfClosingTag Comment ProcessingInst MismatchedCloseTag DoctypeDecl",
  maxTerm: 47,
  context: elementContext,
  nodeProps: [["closedBy", 1, "SelfCloseEndTag EndTag", 13, "CloseTag MissingCloseTag"], ["openedBy", 12, "StartTag StartCloseTag", 19, "OpenTag", 20, "StartTag"], ["isolate", -6, 13, 18, 19, 21, 22, 24, ""]],
  propSources: [xmlHighlighting],
  skippedNodes: [0],
  repeatNodeCount: 8,
  tokenData: "Jy~R!XOX$nXY&kYZ&kZ]$n]^&k^p$npq&kqr$nrs'ssv$nvw(Zw}$n}!O,^!O!P$n!P!Q.m!Q![$n![!]0V!]!^$n!^!_3h!_!`El!`!aF_!a!bGQ!b!c$n!c!}0V!}#P$n#P#QHj#Q#R$n#R#S0V#S#T$n#T#o0V#o%W$n%W%o0V%o%p$n%p&a0V&a&b$n&b1p0V1p4U$n4U4d0V4d4e$n4e$IS0V$IS$I`$n$I`$Ib0V$Ib$Kh$n$Kh%#t0V%#t&/x$n&/x&Et0V&Et&FV$n&FV;'S0V;'S;:j3b;:j;=`&e<%l?&r$n?&r?Ah0V?Ah?BY$n?BY?Mn0V?MnO$nX$uWVP{WOr$nrs%_sv$nw!^$n!^!_%y!_;'S$n;'S;=`&e<%lO$nP%dTVPOv%_w!^%_!_;'S%_;'S;=`%s<%lO%_P%vP;=`<%l%_W&OT{WOr%ysv%yw;'S%y;'S;=`&_<%lO%yW&bP;=`<%l%yX&hP;=`<%l$n_&t_VP{WyUOX$nXY&kYZ&kZ]$n]^&k^p$npq&kqr$nrs%_sv$nw!^$n!^!_%y!_;'S$n;'S;=`&e<%lO$nZ'zTzYVPOv%_w!^%_!_;'S%_;'S;=`%s<%lO%_~(^ast)c![!]*g!c!}*g#R#S*g#T#o*g%W%o*g%p&a*g&b1p*g4U4d*g4e$IS*g$I`$Ib*g$Kh%#t*g&/x&Et*g&FV;'S*g;'S;:j,W?&r?Ah*g?BY?Mn*g~)fQ!Q![)l#l#m)z~)oQ!Q![)l!]!^)u~)zOX~~)}R!Q![*W!c!i*W#T#Z*W~*ZS!Q![*W!]!^)u!c!i*W#T#Z*W~*jg}!O*g!O!P*g!Q![*g![!]*g!]!^,R!c!}*g#R#S*g#T#o*g$}%O*g%W%o*g%p&a*g&b1p*g1p4U*g4U4d*g4e$IS*g$I`$Ib*g$Je$Jg*g$Kh%#t*g&/x&Et*g&FV;'S*g;'S;:j,W?&r?Ah*g?BY?Mn*g~,WOW~~,ZP;=`<%l*gZ,eYVP{WOr$nrs%_sv$nw}$n}!O-T!O!^$n!^!_%y!_;'S$n;'S;=`&e<%lO$nZ-[YVP{WOr$nrs%_sv$nw!^$n!^!_%y!_!`$n!`!a-z!a;'S$n;'S;=`&e<%lO$nZ.TW|QVP{WOr$nrs%_sv$nw!^$n!^!_%y!_;'S$n;'S;=`&e<%lO$n].tYVP{WOr$nrs%_sv$nw!^$n!^!_%y!_!`$n!`!a/d!a;'S$n;'S;=`&e<%lO$n]/mWdSVP{WOr$nrs%_sv$nw!^$n!^!_%y!_;'S$n;'S;=`&e<%lO$n_0b!O`S^QVP{WOr$nrs%_sv$nw}$n}!O0V!O!P0V!P!Q$n!Q![0V![!]0V!]!^$n!^!_%y!_!c$n!c!}0V!}#R$n#R#S0V#S#T$n#T#o0V#o$}$n$}%O0V%O%W$n%W%o0V%o%p$n%p&a0V&a&b$n&b1p0V1p4U0V4U4d0V4d4e$n4e$IS0V$IS$I`$n$I`$Ib0V$Ib$Je$n$Je$Jg0V$Jg$Kh$n$Kh%#t0V%#t&/x$n&/x&Et0V&Et&FV$n&FV;'S0V;'S;:j3b;:j;=`&e<%l?&r$n?&r?Ah0V?Ah?BY$n?BY?Mn0V?MnO$n_3eP;=`<%l0VX3mW{WOq%yqr4Vsv%yw!a%y!a!bEU!b;'S%y;'S;=`&_<%lO%yX4[]{WOr%ysv%yw}%y}!O5T!O!f%y!f!g6V!g!}%y!}#O;f#O#W%y#W#XAr#X;'S%y;'S;=`&_<%lO%yX5YV{WOr%ysv%yw}%y}!O5o!O;'S%y;'S;=`&_<%lO%yX5vT}P{WOr%ysv%yw;'S%y;'S;=`&_<%lO%yX6[V{WOr%ysv%yw!q%y!q!r6q!r;'S%y;'S;=`&_<%lO%yX6vV{WOr%ysv%yw!e%y!e!f7]!f;'S%y;'S;=`&_<%lO%yX7bV{WOr%ysv%yw!v%y!v!w7w!w;'S%y;'S;=`&_<%lO%yX7|V{WOr%ysv%yw!{%y!{!|8c!|;'S%y;'S;=`&_<%lO%yX8hV{WOr%ysv%yw!r%y!r!s8}!s;'S%y;'S;=`&_<%lO%yX9SV{WOr%ysv%yw!g%y!g!h9i!h;'S%y;'S;=`&_<%lO%yX9nX{WOr9irs:Zsv9ivw:Zw!`9i!`!a:x!a;'S9i;'S;=`;`<%lO9iP:^TO!`:Z!`!a:m!a;'S:Z;'S;=`:r<%lO:ZP:rOiPP:uP;=`<%l:ZX;PTiP{WOr%ysv%yw;'S%y;'S;=`&_<%lO%yX;cP;=`<%l9iX;kX{WOr%ysv%yw!e%y!e!f<W!f#V%y#V#W?f#W;'S%y;'S;=`&_<%lO%yX<]V{WOr%ysv%yw!f%y!f!g<r!g;'S%y;'S;=`&_<%lO%yX<wV{WOr%ysv%yw!c%y!c!d=^!d;'S%y;'S;=`&_<%lO%yX=cV{WOr%ysv%yw!v%y!v!w=x!w;'S%y;'S;=`&_<%lO%yX=}V{WOr%ysv%yw!c%y!c!d>d!d;'S%y;'S;=`&_<%lO%yX>iV{WOr%ysv%yw!}%y!}#O?O#O;'S%y;'S;=`&_<%lO%yX?VT{WxPOr%ysv%yw;'S%y;'S;=`&_<%lO%yX?kV{WOr%ysv%yw#W%y#W#X@Q#X;'S%y;'S;=`&_<%lO%yX@VV{WOr%ysv%yw#T%y#T#U@l#U;'S%y;'S;=`&_<%lO%yX@qV{WOr%ysv%yw#h%y#h#iAW#i;'S%y;'S;=`&_<%lO%yXA]V{WOr%ysv%yw#T%y#T#U>d#U;'S%y;'S;=`&_<%lO%yXAwV{WOr%ysv%yw#c%y#c#dB^#d;'S%y;'S;=`&_<%lO%yXBcV{WOr%ysv%yw#V%y#V#WBx#W;'S%y;'S;=`&_<%lO%yXB}V{WOr%ysv%yw#h%y#h#iCd#i;'S%y;'S;=`&_<%lO%yXCiV{WOr%ysv%yw#m%y#m#nDO#n;'S%y;'S;=`&_<%lO%yXDTV{WOr%ysv%yw#d%y#d#eDj#e;'S%y;'S;=`&_<%lO%yXDoV{WOr%ysv%yw#X%y#X#Y9i#Y;'S%y;'S;=`&_<%lO%yXE]T!PP{WOr%ysv%yw;'S%y;'S;=`&_<%lO%yZEuWaQVP{WOr$nrs%_sv$nw!^$n!^!_%y!_;'S$n;'S;=`&e<%lO$n_FhW[UVP{WOr$nrs%_sv$nw!^$n!^!_%y!_;'S$n;'S;=`&e<%lO$nZGXYVP{WOr$nrs%_sv$nw!^$n!^!_%y!_!`$n!`!aGw!a;'S$n;'S;=`&e<%lO$nZHQW!OQVP{WOr$nrs%_sv$nw!^$n!^!_%y!_;'S$n;'S;=`&e<%lO$nZHqYVP{WOr$nrs%_sv$nw!^$n!^!_%y!_#P$n#P#QIa#Q;'S$n;'S;=`&e<%lO$nZIhYVP{WOr$nrs%_sv$nw!^$n!^!_%y!_!`$n!`!aJW!a;'S$n;'S;=`&e<%lO$nZJaWwQVP{WOr$nrs%_sv$nw!^$n!^!_%y!_;'S$n;'S;=`&e<%lO$n",
  tokenizers: [startTag, commentContent, piContent, cdataContent, 0, 1, 2, 3],
  topRules: {
    "Document": [0, 6]
  },
  tokenPrec: 0
});

// EXTERNAL MODULE: ./node_modules/@codemirror/language/dist/index.js
var language_dist = __webpack_require__(50478);
// EXTERNAL MODULE: ./node_modules/@codemirror/state/dist/index.js
var state_dist = __webpack_require__(15487);
// EXTERNAL MODULE: ./node_modules/@codemirror/view/dist/index.js + 1 modules
var view_dist = __webpack_require__(66173);
;// CONCATENATED MODULE: ./node_modules/@codemirror/lang-xml/dist/index.js




function tagName(doc, tag) {
  let name = tag && tag.getChild("TagName");
  return name ? doc.sliceString(name.from, name.to) : "";
}
function elementName$1(doc, tree) {
  let tag = tree && tree.firstChild;
  return !tag || tag.name != "OpenTag" ? "" : tagName(doc, tag);
}
function attrName(doc, tag, pos) {
  let attr = tag && tag.getChildren("Attribute").find(a => a.from <= pos && a.to >= pos);
  let name = attr && attr.getChild("AttributeName");
  return name ? doc.sliceString(name.from, name.to) : "";
}
function findParentElement(tree) {
  for (let cur = tree && tree.parent; cur; cur = cur.parent) if (cur.name == "Element") return cur;
  return null;
}
function findLocation(state, pos) {
  var _a;
  let at = (0,language_dist/* syntaxTree */.qz)(state).resolveInner(pos, -1),
    inTag = null;
  for (let cur = at; !inTag && cur.parent; cur = cur.parent) if (cur.name == "OpenTag" || cur.name == "CloseTag" || cur.name == "SelfClosingTag" || cur.name == "MismatchedCloseTag") inTag = cur;
  if (inTag && (inTag.to > pos || inTag.lastChild.type.isError)) {
    let elt = inTag.parent;
    if (at.name == "TagName") return inTag.name == "CloseTag" || inTag.name == "MismatchedCloseTag" ? {
      type: "closeTag",
      from: at.from,
      context: elt
    } : {
      type: "openTag",
      from: at.from,
      context: findParentElement(elt)
    };
    if (at.name == "AttributeName") return {
      type: "attrName",
      from: at.from,
      context: inTag
    };
    if (at.name == "AttributeValue") return {
      type: "attrValue",
      from: at.from,
      context: inTag
    };
    let before = at == inTag || at.name == "Attribute" ? at.childBefore(pos) : at;
    if ((before === null || before === void 0 ? void 0 : before.name) == "StartTag") return {
      type: "openTag",
      from: pos,
      context: findParentElement(elt)
    };
    if ((before === null || before === void 0 ? void 0 : before.name) == "StartCloseTag" && before.to <= pos) return {
      type: "closeTag",
      from: pos,
      context: elt
    };
    if ((before === null || before === void 0 ? void 0 : before.name) == "Is") return {
      type: "attrValue",
      from: pos,
      context: inTag
    };
    if (before) return {
      type: "attrName",
      from: pos,
      context: inTag
    };
    return null;
  } else if (at.name == "StartCloseTag") {
    return {
      type: "closeTag",
      from: pos,
      context: at.parent
    };
  }
  while (at.parent && at.to == pos && !((_a = at.lastChild) === null || _a === void 0 ? void 0 : _a.type.isError)) at = at.parent;
  if (at.name == "Element" || at.name == "Text" || at.name == "Document") return {
    type: "tag",
    from: pos,
    context: at.name == "Element" ? at : findParentElement(at)
  };
  return null;
}
class dist_Element {
  constructor(spec, attrs, attrValues) {
    this.attrs = attrs;
    this.attrValues = attrValues;
    this.children = [];
    this.name = spec.name;
    this.completion = Object.assign(Object.assign({
      type: "type"
    }, spec.completion || {}), {
      label: this.name
    });
    this.openCompletion = Object.assign(Object.assign({}, this.completion), {
      label: "<" + this.name
    });
    this.closeCompletion = Object.assign(Object.assign({}, this.completion), {
      label: "</" + this.name + ">",
      boost: 2
    });
    this.closeNameCompletion = Object.assign(Object.assign({}, this.completion), {
      label: this.name + ">"
    });
    this.text = spec.textContent ? spec.textContent.map(s => ({
      label: s,
      type: "text"
    })) : [];
  }
}
const Identifier = /^[:\-\.\w\u00b7-\uffff]*$/;
function attrCompletion(spec) {
  return Object.assign(Object.assign({
    type: "property"
  }, spec.completion || {}), {
    label: spec.name
  });
}
function valueCompletion(spec) {
  return typeof spec == "string" ? {
    label: `"${spec}"`,
    type: "constant"
  } : /^"/.test(spec.label) ? spec : Object.assign(Object.assign({}, spec), {
    label: `"${spec.label}"`
  });
}
/**
Create a completion source for the given schema.
*/
function completeFromSchema(eltSpecs, attrSpecs) {
  let allAttrs = [],
    globalAttrs = [];
  let attrValues = Object.create(null);
  for (let s of attrSpecs) {
    let completion = attrCompletion(s);
    allAttrs.push(completion);
    if (s.global) globalAttrs.push(completion);
    if (s.values) attrValues[s.name] = s.values.map(valueCompletion);
  }
  let allElements = [],
    topElements = [];
  let byName = Object.create(null);
  for (let s of eltSpecs) {
    let attrs = globalAttrs,
      attrVals = attrValues;
    if (s.attributes) attrs = attrs.concat(s.attributes.map(s => {
      if (typeof s == "string") return allAttrs.find(a => a.label == s) || {
        label: s,
        type: "property"
      };
      if (s.values) {
        if (attrVals == attrValues) attrVals = Object.create(attrVals);
        attrVals[s.name] = s.values.map(valueCompletion);
      }
      return attrCompletion(s);
    }));
    let elt = new dist_Element(s, attrs, attrVals);
    byName[elt.name] = elt;
    allElements.push(elt);
    if (s.top) topElements.push(elt);
  }
  if (!topElements.length) topElements = allElements;
  for (let i = 0; i < allElements.length; i++) {
    let s = eltSpecs[i],
      elt = allElements[i];
    if (s.children) {
      for (let ch of s.children) if (byName[ch]) elt.children.push(byName[ch]);
    } else {
      elt.children = allElements;
    }
  }
  return cx => {
    var _a;
    let {
        doc
      } = cx.state,
      loc = findLocation(cx.state, cx.pos);
    if (!loc || loc.type == "tag" && !cx.explicit) return null;
    let {
      type,
      from,
      context
    } = loc;
    if (type == "openTag") {
      let children = topElements;
      let parentName = elementName$1(doc, context);
      if (parentName) {
        let parent = byName[parentName];
        children = (parent === null || parent === void 0 ? void 0 : parent.children) || allElements;
      }
      return {
        from,
        options: children.map(ch => ch.completion),
        validFor: Identifier
      };
    } else if (type == "closeTag") {
      let parentName = elementName$1(doc, context);
      return parentName ? {
        from,
        to: cx.pos + (doc.sliceString(cx.pos, cx.pos + 1) == ">" ? 1 : 0),
        options: [((_a = byName[parentName]) === null || _a === void 0 ? void 0 : _a.closeNameCompletion) || {
          label: parentName + ">",
          type: "type"
        }],
        validFor: Identifier
      } : null;
    } else if (type == "attrName") {
      let parent = byName[tagName(doc, context)];
      return {
        from,
        options: (parent === null || parent === void 0 ? void 0 : parent.attrs) || globalAttrs,
        validFor: Identifier
      };
    } else if (type == "attrValue") {
      let attr = attrName(doc, context, from);
      if (!attr) return null;
      let parent = byName[tagName(doc, context)];
      let values = ((parent === null || parent === void 0 ? void 0 : parent.attrValues) || attrValues)[attr];
      if (!values || !values.length) return null;
      return {
        from,
        to: cx.pos + (doc.sliceString(cx.pos, cx.pos + 1) == '"' ? 1 : 0),
        options: values,
        validFor: /^"[^"]*"?$/
      };
    } else if (type == "tag") {
      let parentName = elementName$1(doc, context),
        parent = byName[parentName];
      let closing = [],
        last = context && context.lastChild;
      if (parentName && (!last || last.name != "CloseTag" || tagName(doc, last) != parentName)) closing.push(parent ? parent.closeCompletion : {
        label: "</" + parentName + ">",
        type: "type",
        boost: 2
      });
      let options = closing.concat(((parent === null || parent === void 0 ? void 0 : parent.children) || (context ? allElements : topElements)).map(e => e.openCompletion));
      if (context && (parent === null || parent === void 0 ? void 0 : parent.text.length)) {
        let openTag = context.firstChild;
        if (openTag.to > cx.pos - 20 && !/\S/.test(cx.state.sliceDoc(openTag.to, cx.pos))) options = options.concat(parent.text);
      }
      return {
        from,
        options,
        validFor: /^<\/?[:\-\.\w\u00b7-\uffff]*$/
      };
    } else {
      return null;
    }
  };
}

/**
A language provider based on the [Lezer XML
parser](https://github.com/lezer-parser/xml), extended with
highlighting and indentation information.
*/
const xmlLanguage = /*@__PURE__*/language_dist/* LRLanguage.define */.qp.define({
  name: "xml",
  parser: /*@__PURE__*/parser.configure({
    props: [/*@__PURE__*/language_dist/* indentNodeProp.add */.uj.add({
      Element(context) {
        let closed = /^\s*<\//.test(context.textAfter);
        return context.lineIndent(context.node.from) + (closed ? 0 : context.unit);
      },
      "OpenTag CloseTag SelfClosingTag"(context) {
        return context.column(context.node.from) + context.unit;
      }
    }), /*@__PURE__*/language_dist/* foldNodeProp.add */.x0.add({
      Element(subtree) {
        let first = subtree.firstChild,
          last = subtree.lastChild;
        if (!first || first.name != "OpenTag") return null;
        return {
          from: first.to,
          to: last.name == "CloseTag" ? last.from : subtree.to
        };
      }
    }), /*@__PURE__*/language_dist/* bracketMatchingHandle.add */.a0.add({
      "OpenTag CloseTag": node => node.getChild("TagName")
    })]
  }),
  languageData: {
    commentTokens: {
      block: {
        open: "<!--",
        close: "-->"
      }
    },
    indentOnInput: /^\s*<\/$/
  }
});
/**
XML language support. Includes schema-based autocompletion when
configured.
*/
function xml(conf = {}) {
  let support = [xmlLanguage.data.of({
    autocomplete: completeFromSchema(conf.elements || [], conf.attributes || [])
  })];
  if (conf.autoCloseTags !== false) support.push(autoCloseTags);
  return new language_dist/* LanguageSupport */.ri(xmlLanguage, support);
}
function elementName(doc, tree, max = doc.length) {
  if (!tree) return "";
  let tag = tree.firstChild;
  let name = tag && tag.getChild("TagName");
  return name ? doc.sliceString(name.from, Math.min(name.to, max)) : "";
}
/**
Extension that will automatically insert close tags when a `>` or
`/` is typed.
*/
const autoCloseTags = /*@__PURE__*/view_dist/* EditorView.inputHandler.of */.tk.inputHandler.of((view, from, to, text, insertTransaction) => {
  if (view.composing || view.state.readOnly || from != to || text != ">" && text != "/" || !xmlLanguage.isActiveAt(view.state, from, -1)) return false;
  let base = insertTransaction(),
    {
      state
    } = base;
  let closeTags = state.changeByRange(range => {
    var _a, _b, _c;
    let {
      head
    } = range;
    let didType = state.doc.sliceString(head - 1, head) == text;
    let after = (0,language_dist/* syntaxTree */.qz)(state).resolveInner(head, -1),
      name;
    if (didType && text == ">" && after.name == "EndTag") {
      let tag = after.parent;
      if (((_b = (_a = tag.parent) === null || _a === void 0 ? void 0 : _a.lastChild) === null || _b === void 0 ? void 0 : _b.name) != "CloseTag" && (name = elementName(state.doc, tag.parent, head))) {
        let to = head + (state.doc.sliceString(head, head + 1) === ">" ? 1 : 0);
        let insert = `</${name}>`;
        return {
          range,
          changes: {
            from: head,
            to,
            insert
          }
        };
      }
    } else if (didType && text == "/" && after.name == "StartCloseTag") {
      let base = after.parent;
      if (after.from == head - 2 && ((_c = base.lastChild) === null || _c === void 0 ? void 0 : _c.name) != "CloseTag" && (name = elementName(state.doc, base, head))) {
        let to = head + (state.doc.sliceString(head, head + 1) === ">" ? 1 : 0);
        let insert = `${name}>`;
        return {
          range: state_dist/* EditorSelection.cursor */.jT.cursor(head + insert.length, -1),
          changes: {
            from: head,
            to,
            insert
          }
        };
      }
    }
    return {
      range
    };
  });
  if (closeTags.changes.empty) return false;
  view.dispatch([base, state.update(closeTags, {
    userEvent: "input.complete",
    scrollIntoView: true
  })]);
  return true;
});


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzI4Mi5qdXB5dGVyLXZpZXdlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUNuSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AZGF0YWxheWVyL2p1cHl0ZXItdmlld2VyLy4vbm9kZV9tb2R1bGVzL0BsZXplci94bWwvZGlzdC9pbmRleC5qcyIsIndlYnBhY2s6Ly9AZGF0YWxheWVyL2p1cHl0ZXItdmlld2VyLy4vbm9kZV9tb2R1bGVzL0Bjb2RlbWlycm9yL2xhbmcteG1sL2Rpc3QvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ29udGV4dFRyYWNrZXIsIEV4dGVybmFsVG9rZW5pemVyLCBMUlBhcnNlciB9IGZyb20gJ0BsZXplci9scic7XG5pbXBvcnQgeyBzdHlsZVRhZ3MsIHRhZ3MgfSBmcm9tICdAbGV6ZXIvaGlnaGxpZ2h0JztcblxuLy8gVGhpcyBmaWxlIHdhcyBnZW5lcmF0ZWQgYnkgbGV6ZXItZ2VuZXJhdG9yLiBZb3UgcHJvYmFibHkgc2hvdWxkbid0IGVkaXQgaXQuXG5jb25zdCBTdGFydFRhZyA9IDEsXG4gIFN0YXJ0Q2xvc2VUYWcgPSAyLFxuICBNaXNzaW5nQ2xvc2VUYWcgPSAzLFxuICBtaXNtYXRjaGVkU3RhcnRDbG9zZVRhZyA9IDQsXG4gIGluY29tcGxldGVTdGFydENsb3NlVGFnID0gNSxcbiAgY29tbWVudENvbnRlbnQkMSA9IDM1LFxuICBwaUNvbnRlbnQkMSA9IDM2LFxuICBjZGF0YUNvbnRlbnQkMSA9IDM3LFxuICBFbGVtZW50ID0gMTEsXG4gIE9wZW5UYWcgPSAxMztcblxuLyogSGFuZC13cml0dGVuIHRva2VuaXplciBmb3IgWE1MIHRhZyBtYXRjaGluZy4gKi9cblxuZnVuY3Rpb24gbmFtZUNoYXIoY2gpIHtcbiAgcmV0dXJuIGNoID09IDQ1IHx8IGNoID09IDQ2IHx8IGNoID09IDU4IHx8IGNoID49IDY1ICYmIGNoIDw9IDkwIHx8IGNoID09IDk1IHx8IGNoID49IDk3ICYmIGNoIDw9IDEyMiB8fCBjaCA+PSAxNjE7XG59XG5mdW5jdGlvbiBpc1NwYWNlKGNoKSB7XG4gIHJldHVybiBjaCA9PSA5IHx8IGNoID09IDEwIHx8IGNoID09IDEzIHx8IGNoID09IDMyO1xufVxubGV0IGNhY2hlZE5hbWUgPSBudWxsLFxuICBjYWNoZWRJbnB1dCA9IG51bGwsXG4gIGNhY2hlZFBvcyA9IDA7XG5mdW5jdGlvbiB0YWdOYW1lQWZ0ZXIoaW5wdXQsIG9mZnNldCkge1xuICBsZXQgcG9zID0gaW5wdXQucG9zICsgb2Zmc2V0O1xuICBpZiAoY2FjaGVkSW5wdXQgPT0gaW5wdXQgJiYgY2FjaGVkUG9zID09IHBvcykgcmV0dXJuIGNhY2hlZE5hbWU7XG4gIHdoaWxlIChpc1NwYWNlKGlucHV0LnBlZWsob2Zmc2V0KSkpIG9mZnNldCsrO1xuICBsZXQgbmFtZSA9IFwiXCI7XG4gIGZvciAoOzspIHtcbiAgICBsZXQgbmV4dCA9IGlucHV0LnBlZWsob2Zmc2V0KTtcbiAgICBpZiAoIW5hbWVDaGFyKG5leHQpKSBicmVhaztcbiAgICBuYW1lICs9IFN0cmluZy5mcm9tQ2hhckNvZGUobmV4dCk7XG4gICAgb2Zmc2V0Kys7XG4gIH1cbiAgY2FjaGVkSW5wdXQgPSBpbnB1dDtcbiAgY2FjaGVkUG9zID0gcG9zO1xuICByZXR1cm4gY2FjaGVkTmFtZSA9IG5hbWUgfHwgbnVsbDtcbn1cbmZ1bmN0aW9uIEVsZW1lbnRDb250ZXh0KG5hbWUsIHBhcmVudCkge1xuICB0aGlzLm5hbWUgPSBuYW1lO1xuICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgdGhpcy5oYXNoID0gcGFyZW50ID8gcGFyZW50Lmhhc2ggOiAwO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IG5hbWUubGVuZ3RoOyBpKyspIHRoaXMuaGFzaCArPSAodGhpcy5oYXNoIDw8IDQpICsgbmFtZS5jaGFyQ29kZUF0KGkpICsgKG5hbWUuY2hhckNvZGVBdChpKSA8PCA4KTtcbn1cbmNvbnN0IGVsZW1lbnRDb250ZXh0ID0gbmV3IENvbnRleHRUcmFja2VyKHtcbiAgc3RhcnQ6IG51bGwsXG4gIHNoaWZ0KGNvbnRleHQsIHRlcm0sIHN0YWNrLCBpbnB1dCkge1xuICAgIHJldHVybiB0ZXJtID09IFN0YXJ0VGFnID8gbmV3IEVsZW1lbnRDb250ZXh0KHRhZ05hbWVBZnRlcihpbnB1dCwgMSkgfHwgXCJcIiwgY29udGV4dCkgOiBjb250ZXh0O1xuICB9LFxuICByZWR1Y2UoY29udGV4dCwgdGVybSkge1xuICAgIHJldHVybiB0ZXJtID09IEVsZW1lbnQgJiYgY29udGV4dCA/IGNvbnRleHQucGFyZW50IDogY29udGV4dDtcbiAgfSxcbiAgcmV1c2UoY29udGV4dCwgbm9kZSwgX3N0YWNrLCBpbnB1dCkge1xuICAgIGxldCB0eXBlID0gbm9kZS50eXBlLmlkO1xuICAgIHJldHVybiB0eXBlID09IFN0YXJ0VGFnIHx8IHR5cGUgPT0gT3BlblRhZyA/IG5ldyBFbGVtZW50Q29udGV4dCh0YWdOYW1lQWZ0ZXIoaW5wdXQsIDEpIHx8IFwiXCIsIGNvbnRleHQpIDogY29udGV4dDtcbiAgfSxcbiAgaGFzaChjb250ZXh0KSB7XG4gICAgcmV0dXJuIGNvbnRleHQgPyBjb250ZXh0Lmhhc2ggOiAwO1xuICB9LFxuICBzdHJpY3Q6IGZhbHNlXG59KTtcbmNvbnN0IHN0YXJ0VGFnID0gbmV3IEV4dGVybmFsVG9rZW5pemVyKChpbnB1dCwgc3RhY2spID0+IHtcbiAgaWYgKGlucHV0Lm5leHQgIT0gNjAgLyogJzwnICovKSByZXR1cm47XG4gIGlucHV0LmFkdmFuY2UoKTtcbiAgaWYgKGlucHV0Lm5leHQgPT0gNDcgLyogJy8nICovKSB7XG4gICAgaW5wdXQuYWR2YW5jZSgpO1xuICAgIGxldCBuYW1lID0gdGFnTmFtZUFmdGVyKGlucHV0LCAwKTtcbiAgICBpZiAoIW5hbWUpIHJldHVybiBpbnB1dC5hY2NlcHRUb2tlbihpbmNvbXBsZXRlU3RhcnRDbG9zZVRhZyk7XG4gICAgaWYgKHN0YWNrLmNvbnRleHQgJiYgbmFtZSA9PSBzdGFjay5jb250ZXh0Lm5hbWUpIHJldHVybiBpbnB1dC5hY2NlcHRUb2tlbihTdGFydENsb3NlVGFnKTtcbiAgICBmb3IgKGxldCBjeCA9IHN0YWNrLmNvbnRleHQ7IGN4OyBjeCA9IGN4LnBhcmVudCkgaWYgKGN4Lm5hbWUgPT0gbmFtZSkgcmV0dXJuIGlucHV0LmFjY2VwdFRva2VuKE1pc3NpbmdDbG9zZVRhZywgLTIpO1xuICAgIGlucHV0LmFjY2VwdFRva2VuKG1pc21hdGNoZWRTdGFydENsb3NlVGFnKTtcbiAgfSBlbHNlIGlmIChpbnB1dC5uZXh0ICE9IDMzIC8qICchJyAqLyAmJiBpbnB1dC5uZXh0ICE9IDYzIC8qICc/JyAqLykge1xuICAgIHJldHVybiBpbnB1dC5hY2NlcHRUb2tlbihTdGFydFRhZyk7XG4gIH1cbn0sIHtcbiAgY29udGV4dHVhbDogdHJ1ZVxufSk7XG5mdW5jdGlvbiBzY2FuVG8odHlwZSwgZW5kKSB7XG4gIHJldHVybiBuZXcgRXh0ZXJuYWxUb2tlbml6ZXIoaW5wdXQgPT4ge1xuICAgIGxldCBsZW4gPSAwLFxuICAgICAgZmlyc3QgPSBlbmQuY2hhckNvZGVBdCgwKTtcbiAgICBzY2FuOiBmb3IgKDs7IGlucHV0LmFkdmFuY2UoKSwgbGVuKyspIHtcbiAgICAgIGlmIChpbnB1dC5uZXh0IDwgMCkgYnJlYWs7XG4gICAgICBpZiAoaW5wdXQubmV4dCA9PSBmaXJzdCkge1xuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IGVuZC5sZW5ndGg7IGkrKykgaWYgKGlucHV0LnBlZWsoaSkgIT0gZW5kLmNoYXJDb2RlQXQoaSkpIGNvbnRpbnVlIHNjYW47XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobGVuKSBpbnB1dC5hY2NlcHRUb2tlbih0eXBlKTtcbiAgfSk7XG59XG5jb25zdCBjb21tZW50Q29udGVudCA9IHNjYW5Ubyhjb21tZW50Q29udGVudCQxLCBcIi0tPlwiKTtcbmNvbnN0IHBpQ29udGVudCA9IHNjYW5UbyhwaUNvbnRlbnQkMSwgXCI/PlwiKTtcbmNvbnN0IGNkYXRhQ29udGVudCA9IHNjYW5UbyhjZGF0YUNvbnRlbnQkMSwgXCJdXT5cIik7XG5jb25zdCB4bWxIaWdobGlnaHRpbmcgPSBzdHlsZVRhZ3Moe1xuICBUZXh0OiB0YWdzLmNvbnRlbnQsXG4gIFwiU3RhcnRUYWcgU3RhcnRDbG9zZVRhZyBFbmRUYWcgU2VsZkNsb3NlRW5kVGFnXCI6IHRhZ3MuYW5nbGVCcmFja2V0LFxuICBUYWdOYW1lOiB0YWdzLnRhZ05hbWUsXG4gIFwiTWlzbWF0Y2hlZENsb3NlVGFnL1RhZ05hbWVcIjogW3RhZ3MudGFnTmFtZSwgdGFncy5pbnZhbGlkXSxcbiAgQXR0cmlidXRlTmFtZTogdGFncy5hdHRyaWJ1dGVOYW1lLFxuICBBdHRyaWJ1dGVWYWx1ZTogdGFncy5hdHRyaWJ1dGVWYWx1ZSxcbiAgSXM6IHRhZ3MuZGVmaW5pdGlvbk9wZXJhdG9yLFxuICBcIkVudGl0eVJlZmVyZW5jZSBDaGFyYWN0ZXJSZWZlcmVuY2VcIjogdGFncy5jaGFyYWN0ZXIsXG4gIENvbW1lbnQ6IHRhZ3MuYmxvY2tDb21tZW50LFxuICBQcm9jZXNzaW5nSW5zdDogdGFncy5wcm9jZXNzaW5nSW5zdHJ1Y3Rpb24sXG4gIERvY3R5cGVEZWNsOiB0YWdzLmRvY3VtZW50TWV0YSxcbiAgQ2RhdGE6IHRhZ3Muc3BlY2lhbCh0YWdzLnN0cmluZylcbn0pO1xuXG4vLyBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBsZXplci1nZW5lcmF0b3IuIFlvdSBwcm9iYWJseSBzaG91bGRuJ3QgZWRpdCBpdC5cbmNvbnN0IHBhcnNlciA9IExSUGFyc2VyLmRlc2VyaWFsaXplKHtcbiAgdmVyc2lvbjogMTQsXG4gIHN0YXRlczogXCIsU09RT2FPT09yT3hPJyNDZk96T3BPJyNDaU8hdE9hTycjQ2dPT09QJyNDZycjQ2dPIXtPck8nI0NyTyNUT3RPJyNDc08jXU9wTycjQ3RPT09QJyNEUycjRFNPT09QJyNDdicjQ3ZRUU9hT09PT09XJyNDdycjQ3dPI2VPeE8sNTlRT09PUCw1OVEsNTlRT09PTycjQ3gnI0N4TyNtT3BPLDU5VE8jdU8hYk8sNTlUT09PUCcjQ3snI0N7TyRUT2FPLDU5Uk8kW09wTycjQ29PT09QLDU5Uiw1OVJPT09RJyNDfCcjQ3xPJGRPck8sNTleT09PUCw1OV4sNTleT09PUycjQ30nI0N9TyRsT3RPLDU5X09PT1AsNTlfLDU5X08kdE9wTyw1OWBPJHxPcE8sNTlgT09PUC1FNnQtRTZ0T09PVy1FNnUtRTZ1T09PUDFHLmwxRy5sT09PTy1FNnYtRTZ2TyVVTyFiTzFHLm9PJVVPIWJPMUcub08lZE9wTycjQ2tPJWxPIWJPJyNDeU8lek8hYk8xRy5vT09PUDFHLm8xRy5vT09PUDFHLncxRy53T09PUC1FNnktRTZ5T09PUDFHLm0xRy5tTyZWT3BPLDU5Wk8mX09wTyw1OVpPT09RLUU2ei1FNnpPT09QMUcueDFHLnhPT09TLUU2ey1FNntPT09QMUcueTFHLnlPJmdPcE8xRy56TyZnT3BPMUcuek9PT1AxRy56MUcuek8mb08hYk83KyRaTyZ9TyFiTzcrJFpPT09QNyskWjcrJFpPT09QNyskYzcrJGNPJ1lPcE8sNTlWTydiT3BPLDU5Vk8nak8hYk8sNTllT09PTy1FNnctRTZ3Tyd4T3BPMUcudU8neE9wTzFHLnVPT09QMUcudTFHLnVPKFFPcE83KyRmT09PUDcrJGY3KyRmTyhZTyFiTzw8R3VPT09QPDxHdTw8R3VPT09QPDxHfTw8R31PJ2JPcE8xRy5xTydiT3BPMUcucU8oZU8jdE8nI0NuT09PTzFHLnExRy5xTyhzT3BPNyskYU9PT1A3KyRhNyskYU9PT1A8PEhRPDxIUU9PT1BBTj1hQU49YU9PT1BBTj1pQU49aU8nYk9wTzcrJF1PT09PNyskXTcrJF1PT09PJyNDeicjQ3pPKHtPI3RPLDU5WU9PT08sNTlZLDU5WU9PT1A8PEd7PDxHe09PT088PEd3PDxHd09PT08tRTZ4LUU2eE9PT08xRy50MUcudFwiLFxuICBzdGF0ZURhdGE6IFwiKVp+T1BRT1NWT1RXT1ZXT1dXT1hXT2lYT3hQT31UTyFQVU9+T3VaT3ddT35PXmBPeV5Pfk9QUU9RY09TVk9UV09WV09XV09YV094UE99VE8hUFVPfk9SZE9+UCFTT3NlT3xnT35PdGhPIU9qT35PXmxPeV5Pfk91Wk93b09+T15xT3leT35PW3ZPYHNPZHdPeV5Pfk9SeU9+UCFTT157T3leT35Pc2VPfH1Pfk90aE8hTyFQT35PXiFRT3leT35PWyFTT3leT35PWyFWT2BzT2QhV095Xk9+T2EhWU95Xk9+T3leT1ttWGBtWGRtWH5PWyFWT2BzT2QhV09+T14hXU95Xk9+T1shX095Xk9+T1shYU95Xk9+T1shY09gc09kIWRPeV5Pfk9bIWNPYHNPZCFkT35PYSFlT3leT35PeV5PeiFnT35PeV5PW21hYG1hZG1hfk9bIWpPeV5Pfk9bIWtPeV5Pfk9bIWxPYHNPZCFtT35PVyFwT1ghcE96IXJPeyFwT35PWyFzT3leT35PVyFwT1ghcE96IXZPeyFwT35PXCIsXG4gIGdvdG86IFwiJVt3UFBQUFBQUFBQUHh4UCFPUCFVUFAhXyFpUCFveHh4UCF1IXsjUiRaJGokcCR2JHxQUFBQJVNYV09SWWJYUk9SWWJfdGBxcnUhVCFVIWJRIWghWVMhbyFlIWZSIXQhblFkUlJ5YlhTT1JZYlFZT1JtWVFbUFJuW1FfUVFrVmpwX2tyeiFSIVQhWCFaIV4hYCFmIWkhblFyYFF6Y1EhUmxRIVRxUSFYc1EhWnRRIV57USFgIVFRIWYhWVEhaSFdUiFuIWVRdWBTIVVxclUhW3UhVSFiUiFiIVRRIXEhZ1IhdSFxUWJSUnhiUWZUUnxmUWlVUiFPaVNYT1lUYVJiXCIsXG4gIG5vZGVOYW1lczogXCLimqAgU3RhcnRUYWcgU3RhcnRDbG9zZVRhZyBNaXNzaW5nQ2xvc2VUYWcgU3RhcnRDbG9zZVRhZyBTdGFydENsb3NlVGFnIERvY3VtZW50IFRleHQgRW50aXR5UmVmZXJlbmNlIENoYXJhY3RlclJlZmVyZW5jZSBDZGF0YSBFbGVtZW50IEVuZFRhZyBPcGVuVGFnIFRhZ05hbWUgQXR0cmlidXRlIEF0dHJpYnV0ZU5hbWUgSXMgQXR0cmlidXRlVmFsdWUgQ2xvc2VUYWcgU2VsZkNsb3NlRW5kVGFnIFNlbGZDbG9zaW5nVGFnIENvbW1lbnQgUHJvY2Vzc2luZ0luc3QgTWlzbWF0Y2hlZENsb3NlVGFnIERvY3R5cGVEZWNsXCIsXG4gIG1heFRlcm06IDQ3LFxuICBjb250ZXh0OiBlbGVtZW50Q29udGV4dCxcbiAgbm9kZVByb3BzOiBbW1wiY2xvc2VkQnlcIiwgMSwgXCJTZWxmQ2xvc2VFbmRUYWcgRW5kVGFnXCIsIDEzLCBcIkNsb3NlVGFnIE1pc3NpbmdDbG9zZVRhZ1wiXSwgW1wib3BlbmVkQnlcIiwgMTIsIFwiU3RhcnRUYWcgU3RhcnRDbG9zZVRhZ1wiLCAxOSwgXCJPcGVuVGFnXCIsIDIwLCBcIlN0YXJ0VGFnXCJdLCBbXCJpc29sYXRlXCIsIC02LCAxMywgMTgsIDE5LCAyMSwgMjIsIDI0LCBcIlwiXV0sXG4gIHByb3BTb3VyY2VzOiBbeG1sSGlnaGxpZ2h0aW5nXSxcbiAgc2tpcHBlZE5vZGVzOiBbMF0sXG4gIHJlcGVhdE5vZGVDb3VudDogOCxcbiAgdG9rZW5EYXRhOiBcIkp5flIhWE9YJG5YWSZrWVoma1pdJG5dXiZrXnAkbnBxJmtxciRucnMnc3N2JG52dyhad30kbn0hTyxeIU8hUCRuIVAhUS5tIVEhWyRuIVshXTBWIV0hXiRuIV4hXzNoIV8hYEVsIWAhYUZfIWEhYkdRIWIhYyRuIWMhfTBWIX0jUCRuI1AjUUhqI1EjUiRuI1IjUzBWI1MjVCRuI1QjbzBWI28lVyRuJVclbzBWJW8lcCRuJXAmYTBWJmEmYiRuJmIxcDBWMXA0VSRuNFU0ZDBWNGQ0ZSRuNGUkSVMwViRJUyRJYCRuJElgJEliMFYkSWIkS2gkbiRLaCUjdDBWJSN0Ji94JG4mL3gmRXQwViZFdCZGViRuJkZWOydTMFY7J1M7OmozYjs6ajs9YCZlPCVsPyZyJG4/JnI/QWgwVj9BaD9CWSRuP0JZP01uMFY/TW5PJG5YJHVXVlB7V09yJG5ycyVfc3YkbnchXiRuIV4hXyV5IV87J1MkbjsnUzs9YCZlPCVsTyRuUCVkVFZQT3YlX3chXiVfIV87J1MlXzsnUzs9YCVzPCVsTyVfUCV2UDs9YDwlbCVfVyZPVHtXT3IleXN2JXl3OydTJXk7J1M7PWAmXzwlbE8leVcmYlA7PWA8JWwleVgmaFA7PWA8JWwkbl8mdF9WUHtXeVVPWCRuWFkma1laJmtaXSRuXV4ma15wJG5wcSZrcXIkbnJzJV9zdiRudyFeJG4hXiFfJXkhXzsnUyRuOydTOz1gJmU8JWxPJG5aJ3pUellWUE92JV93IV4lXyFfOydTJV87J1M7PWAlczwlbE8lX34oXmFzdCljIVshXSpnIWMhfSpnI1IjUypnI1QjbypnJVclbypnJXAmYSpnJmIxcCpnNFU0ZCpnNGUkSVMqZyRJYCRJYipnJEtoJSN0KmcmL3gmRXQqZyZGVjsnUypnOydTOzpqLFc/JnI/QWgqZz9CWT9NbipnfilmUSFRIVspbCNsI20pen4pb1EhUSFbKWwhXSFeKXV+KXpPWH5+KX1SIVEhWypXIWMhaSpXI1QjWipXfipaUyFRIVsqVyFdIV4pdSFjIWkqVyNUI1oqV34qamd9IU8qZyFPIVAqZyFRIVsqZyFbIV0qZyFdIV4sUiFjIX0qZyNSI1MqZyNUI28qZyR9JU8qZyVXJW8qZyVwJmEqZyZiMXAqZzFwNFUqZzRVNGQqZzRlJElTKmckSWAkSWIqZyRKZSRKZypnJEtoJSN0KmcmL3gmRXQqZyZGVjsnUypnOydTOzpqLFc/JnI/QWgqZz9CWT9NbipnfixXT1d+fixaUDs9YDwlbCpnWixlWVZQe1dPciRucnMlX3N2JG53fSRufSFPLVQhTyFeJG4hXiFfJXkhXzsnUyRuOydTOz1gJmU8JWxPJG5aLVtZVlB7V09yJG5ycyVfc3YkbnchXiRuIV4hXyV5IV8hYCRuIWAhYS16IWE7J1MkbjsnUzs9YCZlPCVsTyRuWi5UV3xRVlB7V09yJG5ycyVfc3YkbnchXiRuIV4hXyV5IV87J1MkbjsnUzs9YCZlPCVsTyRuXS50WVZQe1dPciRucnMlX3N2JG53IV4kbiFeIV8leSFfIWAkbiFgIWEvZCFhOydTJG47J1M7PWAmZTwlbE8kbl0vbVdkU1ZQe1dPciRucnMlX3N2JG53IV4kbiFeIV8leSFfOydTJG47J1M7PWAmZTwlbE8kbl8wYiFPYFNeUVZQe1dPciRucnMlX3N2JG53fSRufSFPMFYhTyFQMFYhUCFRJG4hUSFbMFYhWyFdMFYhXSFeJG4hXiFfJXkhXyFjJG4hYyF9MFYhfSNSJG4jUiNTMFYjUyNUJG4jVCNvMFYjbyR9JG4kfSVPMFYlTyVXJG4lVyVvMFYlbyVwJG4lcCZhMFYmYSZiJG4mYjFwMFYxcDRVMFY0VTRkMFY0ZDRlJG40ZSRJUzBWJElTJElgJG4kSWAkSWIwViRJYiRKZSRuJEplJEpnMFYkSmckS2gkbiRLaCUjdDBWJSN0Ji94JG4mL3gmRXQwViZFdCZGViRuJkZWOydTMFY7J1M7OmozYjs6ajs9YCZlPCVsPyZyJG4/JnI/QWgwVj9BaD9CWSRuP0JZP01uMFY/TW5PJG5fM2VQOz1gPCVsMFZYM21Xe1dPcSV5cXI0VnN2JXl3IWEleSFhIWJFVSFiOydTJXk7J1M7PWAmXzwlbE8leVg0W117V09yJXlzdiV5d30leX0hTzVUIU8hZiV5IWYhZzZWIWchfSV5IX0jTztmI08jVyV5I1cjWEFyI1g7J1MleTsnUzs9YCZfPCVsTyV5WDVZVntXT3IleXN2JXl3fSV5fSFPNW8hTzsnUyV5OydTOz1gJl88JWxPJXlYNXZUfVB7V09yJXlzdiV5dzsnUyV5OydTOz1gJl88JWxPJXlYNltWe1dPciV5c3YleXchcSV5IXEhcjZxIXI7J1MleTsnUzs9YCZfPCVsTyV5WDZ2VntXT3IleXN2JXl3IWUleSFlIWY3XSFmOydTJXk7J1M7PWAmXzwlbE8leVg3YlZ7V09yJXlzdiV5dyF2JXkhdiF3N3chdzsnUyV5OydTOz1gJl88JWxPJXlYN3xWe1dPciV5c3YleXcheyV5IXshfDhjIXw7J1MleTsnUzs9YCZfPCVsTyV5WDhoVntXT3IleXN2JXl3IXIleSFyIXM4fSFzOydTJXk7J1M7PWAmXzwlbE8leVg5U1Z7V09yJXlzdiV5dyFnJXkhZyFoOWkhaDsnUyV5OydTOz1gJl88JWxPJXlYOW5Ye1dPcjlpcnM6WnN2OWl2dzpadyFgOWkhYCFhOnghYTsnUzlpOydTOz1gO2A8JWxPOWlQOl5UTyFgOlohYCFhOm0hYTsnUzpaOydTOz1gOnI8JWxPOlpQOnJPaVBQOnVQOz1gPCVsOlpYO1BUaVB7V09yJXlzdiV5dzsnUyV5OydTOz1gJl88JWxPJXlYO2NQOz1gPCVsOWlYO2tYe1dPciV5c3YleXchZSV5IWUhZjxXIWYjViV5I1YjVz9mI1c7J1MleTsnUzs9YCZfPCVsTyV5WDxdVntXT3IleXN2JXl3IWYleSFmIWc8ciFnOydTJXk7J1M7PWAmXzwlbE8leVg8d1Z7V09yJXlzdiV5dyFjJXkhYyFkPV4hZDsnUyV5OydTOz1gJl88JWxPJXlYPWNWe1dPciV5c3YleXchdiV5IXYhdz14IXc7J1MleTsnUzs9YCZfPCVsTyV5WD19VntXT3IleXN2JXl3IWMleSFjIWQ+ZCFkOydTJXk7J1M7PWAmXzwlbE8leVg+aVZ7V09yJXlzdiV5dyF9JXkhfSNPP08jTzsnUyV5OydTOz1gJl88JWxPJXlYP1ZUe1d4UE9yJXlzdiV5dzsnUyV5OydTOz1gJl88JWxPJXlYP2tWe1dPciV5c3YleXcjVyV5I1cjWEBRI1g7J1MleTsnUzs9YCZfPCVsTyV5WEBWVntXT3IleXN2JXl3I1QleSNUI1VAbCNVOydTJXk7J1M7PWAmXzwlbE8leVhAcVZ7V09yJXlzdiV5dyNoJXkjaCNpQVcjaTsnUyV5OydTOz1gJl88JWxPJXlYQV1We1dPciV5c3YleXcjVCV5I1QjVT5kI1U7J1MleTsnUzs9YCZfPCVsTyV5WEF3VntXT3IleXN2JXl3I2MleSNjI2RCXiNkOydTJXk7J1M7PWAmXzwlbE8leVhCY1Z7V09yJXlzdiV5dyNWJXkjViNXQngjVzsnUyV5OydTOz1gJl88JWxPJXlYQn1We1dPciV5c3YleXcjaCV5I2gjaUNkI2k7J1MleTsnUzs9YCZfPCVsTyV5WENpVntXT3IleXN2JXl3I20leSNtI25ETyNuOydTJXk7J1M7PWAmXzwlbE8leVhEVFZ7V09yJXlzdiV5dyNkJXkjZCNlRGojZTsnUyV5OydTOz1gJl88JWxPJXlYRG9We1dPciV5c3YleXcjWCV5I1gjWTlpI1k7J1MleTsnUzs9YCZfPCVsTyV5WEVdVCFQUHtXT3IleXN2JXl3OydTJXk7J1M7PWAmXzwlbE8leVpFdVdhUVZQe1dPciRucnMlX3N2JG53IV4kbiFeIV8leSFfOydTJG47J1M7PWAmZTwlbE8kbl9GaFdbVVZQe1dPciRucnMlX3N2JG53IV4kbiFeIV8leSFfOydTJG47J1M7PWAmZTwlbE8kblpHWFlWUHtXT3IkbnJzJV9zdiRudyFeJG4hXiFfJXkhXyFgJG4hYCFhR3chYTsnUyRuOydTOz1gJmU8JWxPJG5aSFFXIU9RVlB7V09yJG5ycyVfc3YkbnchXiRuIV4hXyV5IV87J1MkbjsnUzs9YCZlPCVsTyRuWkhxWVZQe1dPciRucnMlX3N2JG53IV4kbiFeIV8leSFfI1AkbiNQI1FJYSNROydTJG47J1M7PWAmZTwlbE8kblpJaFlWUHtXT3IkbnJzJV9zdiRudyFeJG4hXiFfJXkhXyFgJG4hYCFhSlchYTsnUyRuOydTOz1gJmU8JWxPJG5aSmFXd1FWUHtXT3IkbnJzJV9zdiRudyFeJG4hXiFfJXkhXzsnUyRuOydTOz1gJmU8JWxPJG5cIixcbiAgdG9rZW5pemVyczogW3N0YXJ0VGFnLCBjb21tZW50Q29udGVudCwgcGlDb250ZW50LCBjZGF0YUNvbnRlbnQsIDAsIDEsIDIsIDNdLFxuICB0b3BSdWxlczoge1xuICAgIFwiRG9jdW1lbnRcIjogWzAsIDZdXG4gIH0sXG4gIHRva2VuUHJlYzogMFxufSk7XG5leHBvcnQgeyBwYXJzZXIgfTsiLCJpbXBvcnQgeyBwYXJzZXIgfSBmcm9tICdAbGV6ZXIveG1sJztcbmltcG9ydCB7IHN5bnRheFRyZWUsIExSTGFuZ3VhZ2UsIGluZGVudE5vZGVQcm9wLCBmb2xkTm9kZVByb3AsIGJyYWNrZXRNYXRjaGluZ0hhbmRsZSwgTGFuZ3VhZ2VTdXBwb3J0IH0gZnJvbSAnQGNvZGVtaXJyb3IvbGFuZ3VhZ2UnO1xuaW1wb3J0IHsgRWRpdG9yU2VsZWN0aW9uIH0gZnJvbSAnQGNvZGVtaXJyb3Ivc3RhdGUnO1xuaW1wb3J0IHsgRWRpdG9yVmlldyB9IGZyb20gJ0Bjb2RlbWlycm9yL3ZpZXcnO1xuZnVuY3Rpb24gdGFnTmFtZShkb2MsIHRhZykge1xuICBsZXQgbmFtZSA9IHRhZyAmJiB0YWcuZ2V0Q2hpbGQoXCJUYWdOYW1lXCIpO1xuICByZXR1cm4gbmFtZSA/IGRvYy5zbGljZVN0cmluZyhuYW1lLmZyb20sIG5hbWUudG8pIDogXCJcIjtcbn1cbmZ1bmN0aW9uIGVsZW1lbnROYW1lJDEoZG9jLCB0cmVlKSB7XG4gIGxldCB0YWcgPSB0cmVlICYmIHRyZWUuZmlyc3RDaGlsZDtcbiAgcmV0dXJuICF0YWcgfHwgdGFnLm5hbWUgIT0gXCJPcGVuVGFnXCIgPyBcIlwiIDogdGFnTmFtZShkb2MsIHRhZyk7XG59XG5mdW5jdGlvbiBhdHRyTmFtZShkb2MsIHRhZywgcG9zKSB7XG4gIGxldCBhdHRyID0gdGFnICYmIHRhZy5nZXRDaGlsZHJlbihcIkF0dHJpYnV0ZVwiKS5maW5kKGEgPT4gYS5mcm9tIDw9IHBvcyAmJiBhLnRvID49IHBvcyk7XG4gIGxldCBuYW1lID0gYXR0ciAmJiBhdHRyLmdldENoaWxkKFwiQXR0cmlidXRlTmFtZVwiKTtcbiAgcmV0dXJuIG5hbWUgPyBkb2Muc2xpY2VTdHJpbmcobmFtZS5mcm9tLCBuYW1lLnRvKSA6IFwiXCI7XG59XG5mdW5jdGlvbiBmaW5kUGFyZW50RWxlbWVudCh0cmVlKSB7XG4gIGZvciAobGV0IGN1ciA9IHRyZWUgJiYgdHJlZS5wYXJlbnQ7IGN1cjsgY3VyID0gY3VyLnBhcmVudCkgaWYgKGN1ci5uYW1lID09IFwiRWxlbWVudFwiKSByZXR1cm4gY3VyO1xuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGZpbmRMb2NhdGlvbihzdGF0ZSwgcG9zKSB7XG4gIHZhciBfYTtcbiAgbGV0IGF0ID0gc3ludGF4VHJlZShzdGF0ZSkucmVzb2x2ZUlubmVyKHBvcywgLTEpLFxuICAgIGluVGFnID0gbnVsbDtcbiAgZm9yIChsZXQgY3VyID0gYXQ7ICFpblRhZyAmJiBjdXIucGFyZW50OyBjdXIgPSBjdXIucGFyZW50KSBpZiAoY3VyLm5hbWUgPT0gXCJPcGVuVGFnXCIgfHwgY3VyLm5hbWUgPT0gXCJDbG9zZVRhZ1wiIHx8IGN1ci5uYW1lID09IFwiU2VsZkNsb3NpbmdUYWdcIiB8fCBjdXIubmFtZSA9PSBcIk1pc21hdGNoZWRDbG9zZVRhZ1wiKSBpblRhZyA9IGN1cjtcbiAgaWYgKGluVGFnICYmIChpblRhZy50byA+IHBvcyB8fCBpblRhZy5sYXN0Q2hpbGQudHlwZS5pc0Vycm9yKSkge1xuICAgIGxldCBlbHQgPSBpblRhZy5wYXJlbnQ7XG4gICAgaWYgKGF0Lm5hbWUgPT0gXCJUYWdOYW1lXCIpIHJldHVybiBpblRhZy5uYW1lID09IFwiQ2xvc2VUYWdcIiB8fCBpblRhZy5uYW1lID09IFwiTWlzbWF0Y2hlZENsb3NlVGFnXCIgPyB7XG4gICAgICB0eXBlOiBcImNsb3NlVGFnXCIsXG4gICAgICBmcm9tOiBhdC5mcm9tLFxuICAgICAgY29udGV4dDogZWx0XG4gICAgfSA6IHtcbiAgICAgIHR5cGU6IFwib3BlblRhZ1wiLFxuICAgICAgZnJvbTogYXQuZnJvbSxcbiAgICAgIGNvbnRleHQ6IGZpbmRQYXJlbnRFbGVtZW50KGVsdClcbiAgICB9O1xuICAgIGlmIChhdC5uYW1lID09IFwiQXR0cmlidXRlTmFtZVwiKSByZXR1cm4ge1xuICAgICAgdHlwZTogXCJhdHRyTmFtZVwiLFxuICAgICAgZnJvbTogYXQuZnJvbSxcbiAgICAgIGNvbnRleHQ6IGluVGFnXG4gICAgfTtcbiAgICBpZiAoYXQubmFtZSA9PSBcIkF0dHJpYnV0ZVZhbHVlXCIpIHJldHVybiB7XG4gICAgICB0eXBlOiBcImF0dHJWYWx1ZVwiLFxuICAgICAgZnJvbTogYXQuZnJvbSxcbiAgICAgIGNvbnRleHQ6IGluVGFnXG4gICAgfTtcbiAgICBsZXQgYmVmb3JlID0gYXQgPT0gaW5UYWcgfHwgYXQubmFtZSA9PSBcIkF0dHJpYnV0ZVwiID8gYXQuY2hpbGRCZWZvcmUocG9zKSA6IGF0O1xuICAgIGlmICgoYmVmb3JlID09PSBudWxsIHx8IGJlZm9yZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogYmVmb3JlLm5hbWUpID09IFwiU3RhcnRUYWdcIikgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwib3BlblRhZ1wiLFxuICAgICAgZnJvbTogcG9zLFxuICAgICAgY29udGV4dDogZmluZFBhcmVudEVsZW1lbnQoZWx0KVxuICAgIH07XG4gICAgaWYgKChiZWZvcmUgPT09IG51bGwgfHwgYmVmb3JlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBiZWZvcmUubmFtZSkgPT0gXCJTdGFydENsb3NlVGFnXCIgJiYgYmVmb3JlLnRvIDw9IHBvcykgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiY2xvc2VUYWdcIixcbiAgICAgIGZyb206IHBvcyxcbiAgICAgIGNvbnRleHQ6IGVsdFxuICAgIH07XG4gICAgaWYgKChiZWZvcmUgPT09IG51bGwgfHwgYmVmb3JlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBiZWZvcmUubmFtZSkgPT0gXCJJc1wiKSByZXR1cm4ge1xuICAgICAgdHlwZTogXCJhdHRyVmFsdWVcIixcbiAgICAgIGZyb206IHBvcyxcbiAgICAgIGNvbnRleHQ6IGluVGFnXG4gICAgfTtcbiAgICBpZiAoYmVmb3JlKSByZXR1cm4ge1xuICAgICAgdHlwZTogXCJhdHRyTmFtZVwiLFxuICAgICAgZnJvbTogcG9zLFxuICAgICAgY29udGV4dDogaW5UYWdcbiAgICB9O1xuICAgIHJldHVybiBudWxsO1xuICB9IGVsc2UgaWYgKGF0Lm5hbWUgPT0gXCJTdGFydENsb3NlVGFnXCIpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJjbG9zZVRhZ1wiLFxuICAgICAgZnJvbTogcG9zLFxuICAgICAgY29udGV4dDogYXQucGFyZW50XG4gICAgfTtcbiAgfVxuICB3aGlsZSAoYXQucGFyZW50ICYmIGF0LnRvID09IHBvcyAmJiAhKChfYSA9IGF0Lmxhc3RDaGlsZCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnR5cGUuaXNFcnJvcikpIGF0ID0gYXQucGFyZW50O1xuICBpZiAoYXQubmFtZSA9PSBcIkVsZW1lbnRcIiB8fCBhdC5uYW1lID09IFwiVGV4dFwiIHx8IGF0Lm5hbWUgPT0gXCJEb2N1bWVudFwiKSByZXR1cm4ge1xuICAgIHR5cGU6IFwidGFnXCIsXG4gICAgZnJvbTogcG9zLFxuICAgIGNvbnRleHQ6IGF0Lm5hbWUgPT0gXCJFbGVtZW50XCIgPyBhdCA6IGZpbmRQYXJlbnRFbGVtZW50KGF0KVxuICB9O1xuICByZXR1cm4gbnVsbDtcbn1cbmNsYXNzIEVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcihzcGVjLCBhdHRycywgYXR0clZhbHVlcykge1xuICAgIHRoaXMuYXR0cnMgPSBhdHRycztcbiAgICB0aGlzLmF0dHJWYWx1ZXMgPSBhdHRyVmFsdWVzO1xuICAgIHRoaXMuY2hpbGRyZW4gPSBbXTtcbiAgICB0aGlzLm5hbWUgPSBzcGVjLm5hbWU7XG4gICAgdGhpcy5jb21wbGV0aW9uID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHtcbiAgICAgIHR5cGU6IFwidHlwZVwiXG4gICAgfSwgc3BlYy5jb21wbGV0aW9uIHx8IHt9KSwge1xuICAgICAgbGFiZWw6IHRoaXMubmFtZVxuICAgIH0pO1xuICAgIHRoaXMub3BlbkNvbXBsZXRpb24gPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMuY29tcGxldGlvbiksIHtcbiAgICAgIGxhYmVsOiBcIjxcIiArIHRoaXMubmFtZVxuICAgIH0pO1xuICAgIHRoaXMuY2xvc2VDb21wbGV0aW9uID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmNvbXBsZXRpb24pLCB7XG4gICAgICBsYWJlbDogXCI8L1wiICsgdGhpcy5uYW1lICsgXCI+XCIsXG4gICAgICBib29zdDogMlxuICAgIH0pO1xuICAgIHRoaXMuY2xvc2VOYW1lQ29tcGxldGlvbiA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5jb21wbGV0aW9uKSwge1xuICAgICAgbGFiZWw6IHRoaXMubmFtZSArIFwiPlwiXG4gICAgfSk7XG4gICAgdGhpcy50ZXh0ID0gc3BlYy50ZXh0Q29udGVudCA/IHNwZWMudGV4dENvbnRlbnQubWFwKHMgPT4gKHtcbiAgICAgIGxhYmVsOiBzLFxuICAgICAgdHlwZTogXCJ0ZXh0XCJcbiAgICB9KSkgOiBbXTtcbiAgfVxufVxuY29uc3QgSWRlbnRpZmllciA9IC9eWzpcXC1cXC5cXHdcXHUwMGI3LVxcdWZmZmZdKiQvO1xuZnVuY3Rpb24gYXR0ckNvbXBsZXRpb24oc3BlYykge1xuICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHtcbiAgICB0eXBlOiBcInByb3BlcnR5XCJcbiAgfSwgc3BlYy5jb21wbGV0aW9uIHx8IHt9KSwge1xuICAgIGxhYmVsOiBzcGVjLm5hbWVcbiAgfSk7XG59XG5mdW5jdGlvbiB2YWx1ZUNvbXBsZXRpb24oc3BlYykge1xuICByZXR1cm4gdHlwZW9mIHNwZWMgPT0gXCJzdHJpbmdcIiA/IHtcbiAgICBsYWJlbDogYFwiJHtzcGVjfVwiYCxcbiAgICB0eXBlOiBcImNvbnN0YW50XCJcbiAgfSA6IC9eXCIvLnRlc3Qoc3BlYy5sYWJlbCkgPyBzcGVjIDogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBzcGVjKSwge1xuICAgIGxhYmVsOiBgXCIke3NwZWMubGFiZWx9XCJgXG4gIH0pO1xufVxuLyoqXG5DcmVhdGUgYSBjb21wbGV0aW9uIHNvdXJjZSBmb3IgdGhlIGdpdmVuIHNjaGVtYS5cbiovXG5mdW5jdGlvbiBjb21wbGV0ZUZyb21TY2hlbWEoZWx0U3BlY3MsIGF0dHJTcGVjcykge1xuICBsZXQgYWxsQXR0cnMgPSBbXSxcbiAgICBnbG9iYWxBdHRycyA9IFtdO1xuICBsZXQgYXR0clZhbHVlcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIGZvciAobGV0IHMgb2YgYXR0clNwZWNzKSB7XG4gICAgbGV0IGNvbXBsZXRpb24gPSBhdHRyQ29tcGxldGlvbihzKTtcbiAgICBhbGxBdHRycy5wdXNoKGNvbXBsZXRpb24pO1xuICAgIGlmIChzLmdsb2JhbCkgZ2xvYmFsQXR0cnMucHVzaChjb21wbGV0aW9uKTtcbiAgICBpZiAocy52YWx1ZXMpIGF0dHJWYWx1ZXNbcy5uYW1lXSA9IHMudmFsdWVzLm1hcCh2YWx1ZUNvbXBsZXRpb24pO1xuICB9XG4gIGxldCBhbGxFbGVtZW50cyA9IFtdLFxuICAgIHRvcEVsZW1lbnRzID0gW107XG4gIGxldCBieU5hbWUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBmb3IgKGxldCBzIG9mIGVsdFNwZWNzKSB7XG4gICAgbGV0IGF0dHJzID0gZ2xvYmFsQXR0cnMsXG4gICAgICBhdHRyVmFscyA9IGF0dHJWYWx1ZXM7XG4gICAgaWYgKHMuYXR0cmlidXRlcykgYXR0cnMgPSBhdHRycy5jb25jYXQocy5hdHRyaWJ1dGVzLm1hcChzID0+IHtcbiAgICAgIGlmICh0eXBlb2YgcyA9PSBcInN0cmluZ1wiKSByZXR1cm4gYWxsQXR0cnMuZmluZChhID0+IGEubGFiZWwgPT0gcykgfHwge1xuICAgICAgICBsYWJlbDogcyxcbiAgICAgICAgdHlwZTogXCJwcm9wZXJ0eVwiXG4gICAgICB9O1xuICAgICAgaWYgKHMudmFsdWVzKSB7XG4gICAgICAgIGlmIChhdHRyVmFscyA9PSBhdHRyVmFsdWVzKSBhdHRyVmFscyA9IE9iamVjdC5jcmVhdGUoYXR0clZhbHMpO1xuICAgICAgICBhdHRyVmFsc1tzLm5hbWVdID0gcy52YWx1ZXMubWFwKHZhbHVlQ29tcGxldGlvbik7XG4gICAgICB9XG4gICAgICByZXR1cm4gYXR0ckNvbXBsZXRpb24ocyk7XG4gICAgfSkpO1xuICAgIGxldCBlbHQgPSBuZXcgRWxlbWVudChzLCBhdHRycywgYXR0clZhbHMpO1xuICAgIGJ5TmFtZVtlbHQubmFtZV0gPSBlbHQ7XG4gICAgYWxsRWxlbWVudHMucHVzaChlbHQpO1xuICAgIGlmIChzLnRvcCkgdG9wRWxlbWVudHMucHVzaChlbHQpO1xuICB9XG4gIGlmICghdG9wRWxlbWVudHMubGVuZ3RoKSB0b3BFbGVtZW50cyA9IGFsbEVsZW1lbnRzO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGFsbEVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgbGV0IHMgPSBlbHRTcGVjc1tpXSxcbiAgICAgIGVsdCA9IGFsbEVsZW1lbnRzW2ldO1xuICAgIGlmIChzLmNoaWxkcmVuKSB7XG4gICAgICBmb3IgKGxldCBjaCBvZiBzLmNoaWxkcmVuKSBpZiAoYnlOYW1lW2NoXSkgZWx0LmNoaWxkcmVuLnB1c2goYnlOYW1lW2NoXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsdC5jaGlsZHJlbiA9IGFsbEVsZW1lbnRzO1xuICAgIH1cbiAgfVxuICByZXR1cm4gY3ggPT4ge1xuICAgIHZhciBfYTtcbiAgICBsZXQge1xuICAgICAgICBkb2NcbiAgICAgIH0gPSBjeC5zdGF0ZSxcbiAgICAgIGxvYyA9IGZpbmRMb2NhdGlvbihjeC5zdGF0ZSwgY3gucG9zKTtcbiAgICBpZiAoIWxvYyB8fCBsb2MudHlwZSA9PSBcInRhZ1wiICYmICFjeC5leHBsaWNpdCkgcmV0dXJuIG51bGw7XG4gICAgbGV0IHtcbiAgICAgIHR5cGUsXG4gICAgICBmcm9tLFxuICAgICAgY29udGV4dFxuICAgIH0gPSBsb2M7XG4gICAgaWYgKHR5cGUgPT0gXCJvcGVuVGFnXCIpIHtcbiAgICAgIGxldCBjaGlsZHJlbiA9IHRvcEVsZW1lbnRzO1xuICAgICAgbGV0IHBhcmVudE5hbWUgPSBlbGVtZW50TmFtZSQxKGRvYywgY29udGV4dCk7XG4gICAgICBpZiAocGFyZW50TmFtZSkge1xuICAgICAgICBsZXQgcGFyZW50ID0gYnlOYW1lW3BhcmVudE5hbWVdO1xuICAgICAgICBjaGlsZHJlbiA9IChwYXJlbnQgPT09IG51bGwgfHwgcGFyZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJlbnQuY2hpbGRyZW4pIHx8IGFsbEVsZW1lbnRzO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZnJvbSxcbiAgICAgICAgb3B0aW9uczogY2hpbGRyZW4ubWFwKGNoID0+IGNoLmNvbXBsZXRpb24pLFxuICAgICAgICB2YWxpZEZvcjogSWRlbnRpZmllclxuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT0gXCJjbG9zZVRhZ1wiKSB7XG4gICAgICBsZXQgcGFyZW50TmFtZSA9IGVsZW1lbnROYW1lJDEoZG9jLCBjb250ZXh0KTtcbiAgICAgIHJldHVybiBwYXJlbnROYW1lID8ge1xuICAgICAgICBmcm9tLFxuICAgICAgICB0bzogY3gucG9zICsgKGRvYy5zbGljZVN0cmluZyhjeC5wb3MsIGN4LnBvcyArIDEpID09IFwiPlwiID8gMSA6IDApLFxuICAgICAgICBvcHRpb25zOiBbKChfYSA9IGJ5TmFtZVtwYXJlbnROYW1lXSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNsb3NlTmFtZUNvbXBsZXRpb24pIHx8IHtcbiAgICAgICAgICBsYWJlbDogcGFyZW50TmFtZSArIFwiPlwiLFxuICAgICAgICAgIHR5cGU6IFwidHlwZVwiXG4gICAgICAgIH1dLFxuICAgICAgICB2YWxpZEZvcjogSWRlbnRpZmllclxuICAgICAgfSA6IG51bGw7XG4gICAgfSBlbHNlIGlmICh0eXBlID09IFwiYXR0ck5hbWVcIikge1xuICAgICAgbGV0IHBhcmVudCA9IGJ5TmFtZVt0YWdOYW1lKGRvYywgY29udGV4dCldO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZnJvbSxcbiAgICAgICAgb3B0aW9uczogKHBhcmVudCA9PT0gbnVsbCB8fCBwYXJlbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmVudC5hdHRycykgfHwgZ2xvYmFsQXR0cnMsXG4gICAgICAgIHZhbGlkRm9yOiBJZGVudGlmaWVyXG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PSBcImF0dHJWYWx1ZVwiKSB7XG4gICAgICBsZXQgYXR0ciA9IGF0dHJOYW1lKGRvYywgY29udGV4dCwgZnJvbSk7XG4gICAgICBpZiAoIWF0dHIpIHJldHVybiBudWxsO1xuICAgICAgbGV0IHBhcmVudCA9IGJ5TmFtZVt0YWdOYW1lKGRvYywgY29udGV4dCldO1xuICAgICAgbGV0IHZhbHVlcyA9ICgocGFyZW50ID09PSBudWxsIHx8IHBhcmVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyZW50LmF0dHJWYWx1ZXMpIHx8IGF0dHJWYWx1ZXMpW2F0dHJdO1xuICAgICAgaWYgKCF2YWx1ZXMgfHwgIXZhbHVlcy5sZW5ndGgpIHJldHVybiBudWxsO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZnJvbSxcbiAgICAgICAgdG86IGN4LnBvcyArIChkb2Muc2xpY2VTdHJpbmcoY3gucG9zLCBjeC5wb3MgKyAxKSA9PSAnXCInID8gMSA6IDApLFxuICAgICAgICBvcHRpb25zOiB2YWx1ZXMsXG4gICAgICAgIHZhbGlkRm9yOiAvXlwiW15cIl0qXCI/JC9cbiAgICAgIH07XG4gICAgfSBlbHNlIGlmICh0eXBlID09IFwidGFnXCIpIHtcbiAgICAgIGxldCBwYXJlbnROYW1lID0gZWxlbWVudE5hbWUkMShkb2MsIGNvbnRleHQpLFxuICAgICAgICBwYXJlbnQgPSBieU5hbWVbcGFyZW50TmFtZV07XG4gICAgICBsZXQgY2xvc2luZyA9IFtdLFxuICAgICAgICBsYXN0ID0gY29udGV4dCAmJiBjb250ZXh0Lmxhc3RDaGlsZDtcbiAgICAgIGlmIChwYXJlbnROYW1lICYmICghbGFzdCB8fCBsYXN0Lm5hbWUgIT0gXCJDbG9zZVRhZ1wiIHx8IHRhZ05hbWUoZG9jLCBsYXN0KSAhPSBwYXJlbnROYW1lKSkgY2xvc2luZy5wdXNoKHBhcmVudCA/IHBhcmVudC5jbG9zZUNvbXBsZXRpb24gOiB7XG4gICAgICAgIGxhYmVsOiBcIjwvXCIgKyBwYXJlbnROYW1lICsgXCI+XCIsXG4gICAgICAgIHR5cGU6IFwidHlwZVwiLFxuICAgICAgICBib29zdDogMlxuICAgICAgfSk7XG4gICAgICBsZXQgb3B0aW9ucyA9IGNsb3NpbmcuY29uY2F0KCgocGFyZW50ID09PSBudWxsIHx8IHBhcmVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyZW50LmNoaWxkcmVuKSB8fCAoY29udGV4dCA/IGFsbEVsZW1lbnRzIDogdG9wRWxlbWVudHMpKS5tYXAoZSA9PiBlLm9wZW5Db21wbGV0aW9uKSk7XG4gICAgICBpZiAoY29udGV4dCAmJiAocGFyZW50ID09PSBudWxsIHx8IHBhcmVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyZW50LnRleHQubGVuZ3RoKSkge1xuICAgICAgICBsZXQgb3BlblRhZyA9IGNvbnRleHQuZmlyc3RDaGlsZDtcbiAgICAgICAgaWYgKG9wZW5UYWcudG8gPiBjeC5wb3MgLSAyMCAmJiAhL1xcUy8udGVzdChjeC5zdGF0ZS5zbGljZURvYyhvcGVuVGFnLnRvLCBjeC5wb3MpKSkgb3B0aW9ucyA9IG9wdGlvbnMuY29uY2F0KHBhcmVudC50ZXh0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGZyb20sXG4gICAgICAgIG9wdGlvbnMsXG4gICAgICAgIHZhbGlkRm9yOiAvXjxcXC8/WzpcXC1cXC5cXHdcXHUwMGI3LVxcdWZmZmZdKiQvXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH07XG59XG5cbi8qKlxuQSBsYW5ndWFnZSBwcm92aWRlciBiYXNlZCBvbiB0aGUgW0xlemVyIFhNTFxucGFyc2VyXShodHRwczovL2dpdGh1Yi5jb20vbGV6ZXItcGFyc2VyL3htbCksIGV4dGVuZGVkIHdpdGhcbmhpZ2hsaWdodGluZyBhbmQgaW5kZW50YXRpb24gaW5mb3JtYXRpb24uXG4qL1xuY29uc3QgeG1sTGFuZ3VhZ2UgPSAvKkBfX1BVUkVfXyovTFJMYW5ndWFnZS5kZWZpbmUoe1xuICBuYW1lOiBcInhtbFwiLFxuICBwYXJzZXI6IC8qQF9fUFVSRV9fKi9wYXJzZXIuY29uZmlndXJlKHtcbiAgICBwcm9wczogWy8qQF9fUFVSRV9fKi9pbmRlbnROb2RlUHJvcC5hZGQoe1xuICAgICAgRWxlbWVudChjb250ZXh0KSB7XG4gICAgICAgIGxldCBjbG9zZWQgPSAvXlxccyo8XFwvLy50ZXN0KGNvbnRleHQudGV4dEFmdGVyKTtcbiAgICAgICAgcmV0dXJuIGNvbnRleHQubGluZUluZGVudChjb250ZXh0Lm5vZGUuZnJvbSkgKyAoY2xvc2VkID8gMCA6IGNvbnRleHQudW5pdCk7XG4gICAgICB9LFxuICAgICAgXCJPcGVuVGFnIENsb3NlVGFnIFNlbGZDbG9zaW5nVGFnXCIoY29udGV4dCkge1xuICAgICAgICByZXR1cm4gY29udGV4dC5jb2x1bW4oY29udGV4dC5ub2RlLmZyb20pICsgY29udGV4dC51bml0O1xuICAgICAgfVxuICAgIH0pLCAvKkBfX1BVUkVfXyovZm9sZE5vZGVQcm9wLmFkZCh7XG4gICAgICBFbGVtZW50KHN1YnRyZWUpIHtcbiAgICAgICAgbGV0IGZpcnN0ID0gc3VidHJlZS5maXJzdENoaWxkLFxuICAgICAgICAgIGxhc3QgPSBzdWJ0cmVlLmxhc3RDaGlsZDtcbiAgICAgICAgaWYgKCFmaXJzdCB8fCBmaXJzdC5uYW1lICE9IFwiT3BlblRhZ1wiKSByZXR1cm4gbnVsbDtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBmcm9tOiBmaXJzdC50byxcbiAgICAgICAgICB0bzogbGFzdC5uYW1lID09IFwiQ2xvc2VUYWdcIiA/IGxhc3QuZnJvbSA6IHN1YnRyZWUudG9cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9KSwgLypAX19QVVJFX18qL2JyYWNrZXRNYXRjaGluZ0hhbmRsZS5hZGQoe1xuICAgICAgXCJPcGVuVGFnIENsb3NlVGFnXCI6IG5vZGUgPT4gbm9kZS5nZXRDaGlsZChcIlRhZ05hbWVcIilcbiAgICB9KV1cbiAgfSksXG4gIGxhbmd1YWdlRGF0YToge1xuICAgIGNvbW1lbnRUb2tlbnM6IHtcbiAgICAgIGJsb2NrOiB7XG4gICAgICAgIG9wZW46IFwiPCEtLVwiLFxuICAgICAgICBjbG9zZTogXCItLT5cIlxuICAgICAgfVxuICAgIH0sXG4gICAgaW5kZW50T25JbnB1dDogL15cXHMqPFxcLyQvXG4gIH1cbn0pO1xuLyoqXG5YTUwgbGFuZ3VhZ2Ugc3VwcG9ydC4gSW5jbHVkZXMgc2NoZW1hLWJhc2VkIGF1dG9jb21wbGV0aW9uIHdoZW5cbmNvbmZpZ3VyZWQuXG4qL1xuZnVuY3Rpb24geG1sKGNvbmYgPSB7fSkge1xuICBsZXQgc3VwcG9ydCA9IFt4bWxMYW5ndWFnZS5kYXRhLm9mKHtcbiAgICBhdXRvY29tcGxldGU6IGNvbXBsZXRlRnJvbVNjaGVtYShjb25mLmVsZW1lbnRzIHx8IFtdLCBjb25mLmF0dHJpYnV0ZXMgfHwgW10pXG4gIH0pXTtcbiAgaWYgKGNvbmYuYXV0b0Nsb3NlVGFncyAhPT0gZmFsc2UpIHN1cHBvcnQucHVzaChhdXRvQ2xvc2VUYWdzKTtcbiAgcmV0dXJuIG5ldyBMYW5ndWFnZVN1cHBvcnQoeG1sTGFuZ3VhZ2UsIHN1cHBvcnQpO1xufVxuZnVuY3Rpb24gZWxlbWVudE5hbWUoZG9jLCB0cmVlLCBtYXggPSBkb2MubGVuZ3RoKSB7XG4gIGlmICghdHJlZSkgcmV0dXJuIFwiXCI7XG4gIGxldCB0YWcgPSB0cmVlLmZpcnN0Q2hpbGQ7XG4gIGxldCBuYW1lID0gdGFnICYmIHRhZy5nZXRDaGlsZChcIlRhZ05hbWVcIik7XG4gIHJldHVybiBuYW1lID8gZG9jLnNsaWNlU3RyaW5nKG5hbWUuZnJvbSwgTWF0aC5taW4obmFtZS50bywgbWF4KSkgOiBcIlwiO1xufVxuLyoqXG5FeHRlbnNpb24gdGhhdCB3aWxsIGF1dG9tYXRpY2FsbHkgaW5zZXJ0IGNsb3NlIHRhZ3Mgd2hlbiBhIGA+YCBvclxuYC9gIGlzIHR5cGVkLlxuKi9cbmNvbnN0IGF1dG9DbG9zZVRhZ3MgPSAvKkBfX1BVUkVfXyovRWRpdG9yVmlldy5pbnB1dEhhbmRsZXIub2YoKHZpZXcsIGZyb20sIHRvLCB0ZXh0LCBpbnNlcnRUcmFuc2FjdGlvbikgPT4ge1xuICBpZiAodmlldy5jb21wb3NpbmcgfHwgdmlldy5zdGF0ZS5yZWFkT25seSB8fCBmcm9tICE9IHRvIHx8IHRleHQgIT0gXCI+XCIgJiYgdGV4dCAhPSBcIi9cIiB8fCAheG1sTGFuZ3VhZ2UuaXNBY3RpdmVBdCh2aWV3LnN0YXRlLCBmcm9tLCAtMSkpIHJldHVybiBmYWxzZTtcbiAgbGV0IGJhc2UgPSBpbnNlcnRUcmFuc2FjdGlvbigpLFxuICAgIHtcbiAgICAgIHN0YXRlXG4gICAgfSA9IGJhc2U7XG4gIGxldCBjbG9zZVRhZ3MgPSBzdGF0ZS5jaGFuZ2VCeVJhbmdlKHJhbmdlID0+IHtcbiAgICB2YXIgX2EsIF9iLCBfYztcbiAgICBsZXQge1xuICAgICAgaGVhZFxuICAgIH0gPSByYW5nZTtcbiAgICBsZXQgZGlkVHlwZSA9IHN0YXRlLmRvYy5zbGljZVN0cmluZyhoZWFkIC0gMSwgaGVhZCkgPT0gdGV4dDtcbiAgICBsZXQgYWZ0ZXIgPSBzeW50YXhUcmVlKHN0YXRlKS5yZXNvbHZlSW5uZXIoaGVhZCwgLTEpLFxuICAgICAgbmFtZTtcbiAgICBpZiAoZGlkVHlwZSAmJiB0ZXh0ID09IFwiPlwiICYmIGFmdGVyLm5hbWUgPT0gXCJFbmRUYWdcIikge1xuICAgICAgbGV0IHRhZyA9IGFmdGVyLnBhcmVudDtcbiAgICAgIGlmICgoKF9iID0gKF9hID0gdGFnLnBhcmVudCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmxhc3RDaGlsZCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLm5hbWUpICE9IFwiQ2xvc2VUYWdcIiAmJiAobmFtZSA9IGVsZW1lbnROYW1lKHN0YXRlLmRvYywgdGFnLnBhcmVudCwgaGVhZCkpKSB7XG4gICAgICAgIGxldCB0byA9IGhlYWQgKyAoc3RhdGUuZG9jLnNsaWNlU3RyaW5nKGhlYWQsIGhlYWQgKyAxKSA9PT0gXCI+XCIgPyAxIDogMCk7XG4gICAgICAgIGxldCBpbnNlcnQgPSBgPC8ke25hbWV9PmA7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcmFuZ2UsXG4gICAgICAgICAgY2hhbmdlczoge1xuICAgICAgICAgICAgZnJvbTogaGVhZCxcbiAgICAgICAgICAgIHRvLFxuICAgICAgICAgICAgaW5zZXJ0XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZGlkVHlwZSAmJiB0ZXh0ID09IFwiL1wiICYmIGFmdGVyLm5hbWUgPT0gXCJTdGFydENsb3NlVGFnXCIpIHtcbiAgICAgIGxldCBiYXNlID0gYWZ0ZXIucGFyZW50O1xuICAgICAgaWYgKGFmdGVyLmZyb20gPT0gaGVhZCAtIDIgJiYgKChfYyA9IGJhc2UubGFzdENoaWxkKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MubmFtZSkgIT0gXCJDbG9zZVRhZ1wiICYmIChuYW1lID0gZWxlbWVudE5hbWUoc3RhdGUuZG9jLCBiYXNlLCBoZWFkKSkpIHtcbiAgICAgICAgbGV0IHRvID0gaGVhZCArIChzdGF0ZS5kb2Muc2xpY2VTdHJpbmcoaGVhZCwgaGVhZCArIDEpID09PSBcIj5cIiA/IDEgOiAwKTtcbiAgICAgICAgbGV0IGluc2VydCA9IGAke25hbWV9PmA7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcmFuZ2U6IEVkaXRvclNlbGVjdGlvbi5jdXJzb3IoaGVhZCArIGluc2VydC5sZW5ndGgsIC0xKSxcbiAgICAgICAgICBjaGFuZ2VzOiB7XG4gICAgICAgICAgICBmcm9tOiBoZWFkLFxuICAgICAgICAgICAgdG8sXG4gICAgICAgICAgICBpbnNlcnRcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICByYW5nZVxuICAgIH07XG4gIH0pO1xuICBpZiAoY2xvc2VUYWdzLmNoYW5nZXMuZW1wdHkpIHJldHVybiBmYWxzZTtcbiAgdmlldy5kaXNwYXRjaChbYmFzZSwgc3RhdGUudXBkYXRlKGNsb3NlVGFncywge1xuICAgIHVzZXJFdmVudDogXCJpbnB1dC5jb21wbGV0ZVwiLFxuICAgIHNjcm9sbEludG9WaWV3OiB0cnVlXG4gIH0pXSk7XG4gIHJldHVybiB0cnVlO1xufSk7XG5leHBvcnQgeyBhdXRvQ2xvc2VUYWdzLCBjb21wbGV0ZUZyb21TY2hlbWEsIHhtbCwgeG1sTGFuZ3VhZ2UgfTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=