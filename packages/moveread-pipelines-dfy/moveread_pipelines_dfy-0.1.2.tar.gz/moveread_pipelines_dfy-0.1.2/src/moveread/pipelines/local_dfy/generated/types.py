"""
Code generated by `q.pipelines`
- Timestamp: 2024-05-05 20:09:39.109826
- Input file: "../dfy/src/moveread/pipelines/dfy/spec.py"
- Input spec: Tasks({
  'input_task': 'inputval',
  'Input': moveread.pipelines.dfy.spec.Input,  # class
  'Output': moveread.pipelines.dfy.spec.Result,  # class
  'tasks': {
    'inputval': Task(Input -> preprocess),
    'preprocess': Task(Input -> ocr),
    'ocr': Task(Preprocessed -> gamecorr),
    'gamecorr': Task(Predicted -> output | inputval)
  }
})
"""
from typing import Literal, TypedDict, Union, overload, TypeAlias
from q.api import ReadQueue, WriteQueue
from q.pipelines import TaskQueues, Pipeline
from ..spec import Input, Predicted, Preprocessed, Result


class Inputval:
  In = Input
  Out = Union[
    tuple[Literal['preprocess'], Input],
  ] # type: ignore
  QueueIn = ReadQueue[In]
  QueueOut = WriteQueue[Out]
  Queues = TaskQueues[In, Out]

  @classmethod
  @overload
  def next(cls, task: Literal['preprocess'], data: Input) -> 'Inputval.Out': ... # type: ignore
  @classmethod
  def next(cls, task, data):
    return task, data

class Preprocess:
  In = Input
  Out = Union[
    tuple[Literal['ocr'], Preprocessed],
  ] # type: ignore
  QueueIn = ReadQueue[In]
  QueueOut = WriteQueue[Out]
  Queues = TaskQueues[In, Out]

  @classmethod
  @overload
  def next(cls, task: Literal['ocr'], data: Preprocessed) -> 'Preprocess.Out': ... # type: ignore
  @classmethod
  def next(cls, task, data):
    return task, data

class Ocr:
  In = Preprocessed
  Out = Union[
    tuple[Literal['gamecorr'], Predicted],
  ] # type: ignore
  QueueIn = ReadQueue[In]
  QueueOut = WriteQueue[Out]
  Queues = TaskQueues[In, Out]

  @classmethod
  @overload
  def next(cls, task: Literal['gamecorr'], data: Predicted) -> 'Ocr.Out': ... # type: ignore
  @classmethod
  def next(cls, task, data):
    return task, data

class Gamecorr:
  In = Predicted
  Out = Union[
    tuple[Literal['output'], Result],
    tuple[Literal['inputval'], Input],
  ] # type: ignore
  QueueIn = ReadQueue[In]
  QueueOut = WriteQueue[Out]
  Queues = TaskQueues[In, Out]

  @classmethod
  @overload
  def next(cls, task: Literal['output'], data: Result) -> 'Gamecorr.Out': ... # type: ignore
  @classmethod
  @overload
  def next(cls, task: Literal['inputval'], data: Input) -> 'Gamecorr.Out': ... # type: ignore
  @classmethod
  def next(cls, task, data):
    return task, data

class Queues(TypedDict):
  inputval: TaskQueues[Inputval.In, Inputval.Out]
  preprocess: TaskQueues[Preprocess.In, Preprocess.Out]
  ocr: TaskQueues[Ocr.In, Ocr.Out]
  gamecorr: TaskQueues[Gamecorr.In, Gamecorr.Out]

class Pipelines(TypedDict):
  inputval: Pipeline[Inputval.In, Inputval.Out]
  preprocess: Pipeline[Preprocess.In, Preprocess.Out]
  ocr: Pipeline[Ocr.In, Ocr.Out]
  gamecorr: Pipeline[Gamecorr.In, Gamecorr.Out]

QueueIn: TypeAlias = ReadQueue[Input]
QueueOut: TypeAlias = WriteQueue[Result]

__all__ = [
  'Inputval',
  'Preprocess',
  'Ocr',
  'Gamecorr',
  'Queues', 'Pipelines', 'QueueIn', 'QueueOut',
]