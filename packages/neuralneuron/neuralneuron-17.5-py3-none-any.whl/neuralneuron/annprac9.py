# -*- coding: utf-8 -*-
"""ANNprac9.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1qsvPVI9QztDX8LjeOAyR8K2ZjHrf0UOL

**Small Image Classification Using Convolutional Neural Network (CNN)**

In this notebook, we will classify small images cifar10 dataset from tensorflow keras datasets. There are total 10 classes as shown below. We will use CNN for classification

Loading necessary libraries
"""

import tensorflow as tf
from tensorflow.keras import datasets, layers, models
import matplotlib.pyplot as plt
import numpy as np

"""Loading dataset"""

(X_train, y_train), (X_test,y_test) = datasets.cifar10.load_data()

print(X_train.shape)
print(X_test.shape)
print(y_train.shape)
print(y_test.shape)

"""Here we see there are 50000 training images and 10000 test images

Normalize pixel values to between 0 and 1
"""

X_train = X_train/255.0
X_test = X_test/255.0

y_train[:5]

"""y_train is a 2D array, for our classification having 1D array is good enough. so we will convert this to now 1D array"""

y_train = y_train.reshape(-1,)
y_train[:5]

y_test = y_test.reshape(-1,)

classes = ["airplane","automobile","bird","cat","deer","dog","frog","horse","ship","truck"]

"""Let's plot some images to see what they are"""

def plot_sample(X, y, index):
    plt.figure(figsize = (15,2))
    plt.imshow(X[index])
    plt.xlabel(classes[y[index]])

plot_sample(X_train, y_train, 0)

plot_sample(X_train, y_train, 1)

"""Now let us build a **Convolutional Neural Network** to train our images"""

cnn = models.Sequential([
    layers.Conv2D(filters=32, kernel_size=(3, 3), activation='relu', input_shape=(32, 32, 3)),
    layers.MaxPooling2D((2, 2)),

    layers.Conv2D(filters=64, kernel_size=(3, 3), activation='relu'),
    layers.MaxPooling2D((2, 2)),

    layers.Flatten(),
    layers.Dense(64, activation='relu'),
    layers.Dense(10, activation='softmax')
])

cnn.summary()

import pydot
from tensorflow import keras
keras.utils.plot_model(cnn)

"""Number of parameters in a CONV layer would be :

((m * n * d)+1)* k), added 1 because of the bias term for each filter. The same expression can be written as follows:

((shape of width of the filter (m) * shape of height of the filter (n)* number of filters in the previous layer (d)+1)*number of filters (k)).

 Where the term “filter” refers to the number of filters in the current layer.


First Conv2D Layer= ((3x3x3) +1) x 32 = 896

---




Second Conv2D Layer = ((3x3x32)+1) x 64= 18496


Dense_3= (2304x64)+64= 147520


Dense_4=(64x10)+10=650
"""

cnn.compile(optimizer='adam',
              loss='sparse_categorical_crossentropy',
              metrics=['accuracy'])

cnn.fit(X_train, y_train, epochs=5)

"""**With CNN, at the end 5 epochs, accuracy was at around 71% which is a significant improvement over ANN. CNN's are best for image classification and gives superb accuracy. Also computation is much less compared to simple ANN as maxpooling reduces the image dimensions while still preserving the features**"""

cnn.evaluate(X_test,y_test)

y_pred = cnn.predict(X_test)
y_pred[:5]

y_classes = [np.argmax(element) for element in y_pred]
y_classes[:5]

y_test[:5]

plot_sample(X_test, y_test,3)

classes[y_classes[3]]