"""
Code generated by `q.pipelines`
- Timestamp: 2024-05-04 16:49:42.795053
- Input file: "preprocess/src/moveread/pipelines/preprocess/spec.py"
- Input spec: Tasks({
  'input_task': 'extract',
  'Input': moveread.pipelines.preprocess.types.Input,  # class
  'Output': moveread.pipelines.preprocess.types.Result,  # class
  'tasks': {
    'extract': Task(Input -> validate | correct),
    'validate': Task(Extracted -> preoutput | correct | select),
    'correct': Task(Input -> extract | reextract),
    'reextract': Task(Corrected -> revalidate | select),
    'revalidate': Task(Extracted -> preoutput | select),
    'select': Task(Corrected -> preoutput | correct),
    'preoutput': Task(RootOutput -> output)
  }
})
"""
from typing import Literal, TypedDict, Union, overload, TypeAlias
from q.api import ReadQueue, WriteQueue
from q.pipelines import TaskQueues, Pipeline
from ..spec import Input, Corrected, Extracted, RootOutput, Result


class Extract:
  In = Input
  Out = Union[
    tuple[Literal['validate'], Extracted],
    tuple[Literal['correct'], Input],
  ] # type: ignore
  QueueIn = ReadQueue[In]
  QueueOut = WriteQueue[Out]
  Queues = TaskQueues[In, Out]

  @classmethod
  @overload
  def next(cls, task: Literal['validate'], data: Extracted) -> 'Extract.Out': ... # type: ignore
  @classmethod
  @overload
  def next(cls, task: Literal['correct'], data: Input) -> 'Extract.Out': ... # type: ignore
  @classmethod
  def next(cls, task, data):
    return task, data

class Validate:
  In = Extracted
  Out = Union[
    tuple[Literal['preoutput'], RootOutput],
    tuple[Literal['correct'], Input],
    tuple[Literal['select'], Corrected],
  ] # type: ignore
  QueueIn = ReadQueue[In]
  QueueOut = WriteQueue[Out]
  Queues = TaskQueues[In, Out]

  @classmethod
  @overload
  def next(cls, task: Literal['preoutput'], data: RootOutput) -> 'Validate.Out': ... # type: ignore
  @classmethod
  @overload
  def next(cls, task: Literal['correct'], data: Input) -> 'Validate.Out': ... # type: ignore
  @classmethod
  @overload
  def next(cls, task: Literal['select'], data: Corrected) -> 'Validate.Out': ... # type: ignore
  @classmethod
  def next(cls, task, data):
    return task, data

class Correct:
  In = Input
  Out = Union[
    tuple[Literal['extract'], Input],
    tuple[Literal['reextract'], Corrected],
  ] # type: ignore
  QueueIn = ReadQueue[In]
  QueueOut = WriteQueue[Out]
  Queues = TaskQueues[In, Out]

  @classmethod
  @overload
  def next(cls, task: Literal['extract'], data: Input) -> 'Correct.Out': ... # type: ignore
  @classmethod
  @overload
  def next(cls, task: Literal['reextract'], data: Corrected) -> 'Correct.Out': ... # type: ignore
  @classmethod
  def next(cls, task, data):
    return task, data

class Reextract:
  In = Corrected
  Out = Union[
    tuple[Literal['revalidate'], Extracted],
    tuple[Literal['select'], Corrected],
  ] # type: ignore
  QueueIn = ReadQueue[In]
  QueueOut = WriteQueue[Out]
  Queues = TaskQueues[In, Out]

  @classmethod
  @overload
  def next(cls, task: Literal['revalidate'], data: Extracted) -> 'Reextract.Out': ... # type: ignore
  @classmethod
  @overload
  def next(cls, task: Literal['select'], data: Corrected) -> 'Reextract.Out': ... # type: ignore
  @classmethod
  def next(cls, task, data):
    return task, data

class Revalidate:
  In = Extracted
  Out = Union[
    tuple[Literal['preoutput'], RootOutput],
    tuple[Literal['select'], Corrected],
  ] # type: ignore
  QueueIn = ReadQueue[In]
  QueueOut = WriteQueue[Out]
  Queues = TaskQueues[In, Out]

  @classmethod
  @overload
  def next(cls, task: Literal['preoutput'], data: RootOutput) -> 'Revalidate.Out': ... # type: ignore
  @classmethod
  @overload
  def next(cls, task: Literal['select'], data: Corrected) -> 'Revalidate.Out': ... # type: ignore
  @classmethod
  def next(cls, task, data):
    return task, data

class Select:
  In = Corrected
  Out = Union[
    tuple[Literal['preoutput'], RootOutput],
    tuple[Literal['correct'], Input],
  ] # type: ignore
  QueueIn = ReadQueue[In]
  QueueOut = WriteQueue[Out]
  Queues = TaskQueues[In, Out]

  @classmethod
  @overload
  def next(cls, task: Literal['preoutput'], data: RootOutput) -> 'Select.Out': ... # type: ignore
  @classmethod
  @overload
  def next(cls, task: Literal['correct'], data: Input) -> 'Select.Out': ... # type: ignore
  @classmethod
  def next(cls, task, data):
    return task, data

class Preoutput:
  In = RootOutput
  Out = Union[
    tuple[Literal['output'], Result],
  ] # type: ignore
  QueueIn = ReadQueue[In]
  QueueOut = WriteQueue[Out]
  Queues = TaskQueues[In, Out]

  @classmethod
  @overload
  def next(cls, task: Literal['output'], data: Result) -> 'Preoutput.Out': ... # type: ignore
  @classmethod
  def next(cls, task, data):
    return task, data

class Queues(TypedDict):
  extract: TaskQueues[Extract.In, Extract.Out]
  validate: TaskQueues[Validate.In, Validate.Out]
  correct: TaskQueues[Correct.In, Correct.Out]
  reextract: TaskQueues[Reextract.In, Reextract.Out]
  revalidate: TaskQueues[Revalidate.In, Revalidate.Out]
  select: TaskQueues[Select.In, Select.Out]
  preoutput: TaskQueues[Preoutput.In, Preoutput.Out]

class Pipelines(TypedDict):
  extract: Pipeline[Extract.In, Extract.Out]
  validate: Pipeline[Validate.In, Validate.Out]
  correct: Pipeline[Correct.In, Correct.Out]
  reextract: Pipeline[Reextract.In, Reextract.Out]
  revalidate: Pipeline[Revalidate.In, Revalidate.Out]
  select: Pipeline[Select.In, Select.Out]
  preoutput: Pipeline[Preoutput.In, Preoutput.Out]

QueueIn: TypeAlias = ReadQueue[Input]
QueueOut: TypeAlias = WriteQueue[Result]

__all__ = [
  'Extract',
  'Validate',
  'Correct',
  'Reextract',
  'Revalidate',
  'Select',
  'Preoutput',
  'Queues', 'Pipelines', 'QueueIn', 'QueueOut',
]