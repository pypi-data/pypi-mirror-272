# AUTOGENERATED! DO NOT EDIT! File to edit: ../../../nbs/agents/benchmark_agents/12_Dual_Sourcing_Agents.ipynb.

# %% auto 0
__all__ = ['DualSourcingBaseAgent', 'SingleIndexAgent', 'DualIndexAgent', 'SingleIndexPolicy', 'DualIndexPolicy']

# %% ../../../nbs/agents/benchmark_agents/12_Dual_Sourcing_Agents.ipynb 4
# General libraries:
import numpy as np
from scipy.stats import norm
from tqdm import tqdm

# Mushroom libraries
from mushroom_rl.core import Agent

import time

# %% ../../../nbs/agents/benchmark_agents/12_Dual_Sourcing_Agents.ipynb 6
class DualSourcingBaseAgent(Agent):

    def fit(self, features = None, demand=None, mask=None):

        """ 
        xxx
        """

        assert isinstance(demand, np.ndarray)
        assert demand.ndim == 2

        self.policy.set_params(demand, self._preprocessors[0])


class SingleIndexAgent(DualSourcingBaseAgent):

    """
    xxx

    """

    def __init__(self,
                  mdp_info,
                  mdp,
                  l, # lead time
                  l_e, # expedited lead time
                  unit_size = 0.01,
                  preprocessors = None,
                  postprocessors = None,
                  agent_name = None,
                  precision = 5,
                  num_iterations_per_parameter = 12,
                  algorithm = "brute_0_1", 
                  full_grid=False,# "brute_0_1": brute force for demand between 0 and 1 and unit-size <1, "brute_variable": brute force for demand large 1 and unit size 1 
                  #search_space = 3 # applies only for brute_variable - grid size in multiple of average demand
        ):

        mdp._mdp_info.horizon = mdp.demand.shape[0]
        mdp.reset(0)

        policy = SingleIndexPolicy(
            l = l,
            l_e = l_e,
            mdp = mdp,
            unit_size = unit_size,
            preprocessors = preprocessors,
            postprocessors = postprocessors,
            num_iterations_per_parameter = num_iterations_per_parameter,
            algorithm = algorithm,
            full_grid = full_grid,
            #search_space = search_space
        )

        self.precision=precision

        if agent_name is None:
            self.name = 'Single_Index_Agent'
        else:
            self.name = agent_name
        
        self.train_directly=True
        self.train_mode = "direct"

        super().__init__(mdp_info, policy)

class DualIndexAgent(DualSourcingBaseAgent):

    """
    xxx

    """

    def __init__(self,
                  mdp_info,
                  mdp,
                  l, # lead time
                  l_e, # expedited lead time
                  unit_size = 0.01,
                  preprocessors = None,
                  postprocessors = None,
                  agent_name = None,
                  precision = 5,
                  num_iterations_per_parameter = 12,
                  algorithm = "brute_0_1",
                  full_grid=False, # "brute_0_1": brute force for demand between 0 and 1 and unit-size <1, "brute_variable": brute force for demand large 1 and unit size 1 
                  return_levels=False,
                  #search_space = 3 # applies only for brute_variable - grid size in multiple of average demand
        ):

        mdp._mdp_info.horizon = mdp.demand.shape[0]
        mdp.reset(0)

        policy = DualIndexPolicy(
            l = l,
            l_e = l_e,
            mdp = mdp,
            unit_size = unit_size,
            preprocessors = preprocessors,
            postprocessors = postprocessors,
            num_iterations_per_parameter = num_iterations_per_parameter,
            algorithm = algorithm,
            full_grid = full_grid,
            return_levels = return_levels,
            #search_space = search_space
        )

        self.precision=precision

        if agent_name is None:
            self.name = 'Dual_Index_Agent'
        else:
            self.name = agent_name
        
        self.train_directly=True
        self.train_mode = "direct"

        super().__init__(mdp_info, policy)


class SingleIndexPolicy():

    """
    xxx
    """

    def __init__(self,
                 l, 
                 l_e, 
                 mdp,
                 unit_size = 0.01,
                 preprocessors = None,
                 postprocessors = None,
                 num_iterations_per_parameter = 12,
                 algorithm = "brute_0_1", 
                 full_grid = False,# "brute_0_1": brute force for demand between 0 and 1 and unit-size <1, "brute_0_1": brute force for demand large 1 and unit size 1
                 ):
        self.l = l
        self.l_e = l_e
        self.unit_size = unit_size
        self.num_products = len(l)

        if preprocessors is None:
            self.preprocessors = []
        else:
            self.preprocessors = preprocessors
        if postprocessors is None:
            self.postprocessors = []
        else:
            self.postprocessors = postprocessors

        self.mdp = mdp

        self.num_iterations_per_parameter = num_iterations_per_parameter

        self.S = 0.5 #0.97 # initial value
        self.S_e = 0.5 #0.86 # initial value

        self.algorithm = algorithm

        self.full_grid = full_grid
    
    def set_and_calculate_grid(self, S, S_e, step_size, full_grid=False, plot=False,):
        


        if full_grid:
            S_candidates = np.arange(0, 1+step_size, step_size)
            S_e_candidates = np.arange(0, 1+step_size, step_size)
            
        else:

            S_candidates = np.arange(S-step_size*self.num_iterations_per_parameter, S+step_size*(self.num_iterations_per_parameter+1), step_size)
            S_e_candidates = np.arange(S_e-step_size*self.num_iterations_per_parameter, S_e+step_size*(self.num_iterations_per_parameter+1), step_size)

            # only use positive or zero candidates
            S_candidates = S_candidates[S_candidates >= 0]
            S_e_candidates = S_e_candidates[S_e_candidates >= 0]

        print("base S:", S)
        print("base S_e:", S_e)
        print("S candidates:", S_candidates)
        print("S_e candidates:", S_e_candidates)

        best_S, best_S_e, best_cost, _ = self.calculate_grid(S_candidates, S_e_candidates)

        return best_S, best_S_e, best_cost

    def calculate_grid(self, S_candidates, S_e_candidates):
    
        cost_matrix = np.zeros((len(S_candidates), len(S_e_candidates)))

        for i, S_candidate in enumerate(S_candidates):
            for j, S_e_candidate in enumerate(S_e_candidates):
                if S_e_candidate > S_candidate:
                    cost_value = np.inf
                else:
                    cost_value = self.run_simulation(S_candidate, S_e_candidate)

                cost_matrix[i, j] = cost_value
                print("S:", np.round(S_candidate,2), "S_e:", np.round(S_e_candidate,2), "cost:", np.round(cost_value))

        best_cost = np.min(cost_matrix)
        best_S_index, best_S_e_index = np.unravel_index(np.argmin(cost_matrix), cost_matrix.shape)
        best_S = S_candidates[best_S_index]
        best_S_e = S_e_candidates[best_S_e_index]

        print("max S index:", len(S_candidates), "best S index:", best_S_index)
        print("max S_e index:", len(S_e_candidates), "best S_e index:", best_S_e_index)

        print("best S and S_e:", best_S, best_S_e)

        if best_S_index == 0 or best_S_index == len(S_candidates)-1:
            warn_edge = True
        elif best_S_e_index == 0 or best_S_e_index == len(S_e_candidates)-1:
            warn_edge = True
        else:
            warn_edge = False
        
        if warn_edge:
            print("Warning: Optimal value at the edge of search space")

        return best_S, best_S_e, best_cost, warn_edge

    def run_simulation(self, S, S_e):

        total_cost = 0

        state = self.mdp.reset(0)

        for t in range(self.mdp.info.horizon):

            state = self.preprocessor(state)
            action = self.draw_action_train(state, S, S_e)
                
            state, reward, _, _ = self.mdp.step(action)
            
            total_cost += -reward

        return total_cost

    def set_params(self, demand, preprocessor):
        
        """
        Set the optimal order quantity (q_star) for each product.

        This method calculates and assigns the optimal order quantity based on the EOQ formula.

        Returns:
            None

        """

        self.preprocessor = preprocessor

        if self.algorithm == "brute_0_1":

            if self.full_grid:
                self.S, self.S_e, cost = self.set_and_calculate_grid(self.S, self.S_e, step_size = self.unit_size, full_grid=True)
                print("result:", "S:", self.S, "S_e:", self.S_e, "cost:", cost)
            else:
                self.S, self.S_e, cost = self.set_and_calculate_grid(self.S, self.S_e, step_size = self.unit_size*10)
                print("iteration 1:", "S:", self.S, "S_e:", self.S_e, "cost:", cost)
                self.S, self.S_e, cost = self.set_and_calculate_grid(self.S, self.S_e, step_size = self.unit_size*3)
                print("iteration 2:", "S:", self.S, "S_e:", self.S_e, "cost:", cost)
                self.S, self.S_e, cost = self.set_and_calculate_grid(self.S, self.S_e, step_size = self.unit_size)
                print("iteration 3:", "S:", self.S, "S_e:", self.S_e, "cost:", cost)
        
        elif self.algorithm == "brute_variable":
            # rais not implemented

            raise NotImplementedError("only implemented for values normalized between 0 and 1")


            # self.run_brute_variable(demand)
        
        else:
            # error
            raise ValueError("Algorithm unknown")
    
    # def run_brute_variable(self, demand):
        
    #     # starting reorder point average demand times lead time
    #     self.s = np.mean(demand) * np.max(self.l)
    #     eoq = np.sqrt(2 * np.mean(demand) * self.c_s/self.h)
    #     self.S = eoq + self.s

    #     self.s = np.round(self.s)
    #     self.S = np.round(self.S)

    #     # define search space

    #     unit_size = 10
    #     counter_outer = 0

    #     while unit_size >= 1:

    #         if counter_outer == 0:
    #             unit_size = np.mean(demand)*self.search_space/10
    #             # print("unit_sie:", unit_size)
    #             unit_size = np.maximum(unit_size, 1)
    #             # print("unit_sie:", unit_size)
    #             unit_size = np.round(unit_size)

    #             # print("unit size:", unit_size)

    #         warn_edge = True
    #         counter = 0
    #         while warn_edge:
    #             search_space_s = np.arange(self.s-unit_size*10, self.s+unit_size*10, unit_size)
    #             search_space_S = np.arange(self.S-unit_size*10, self.S+unit_size*10, unit_size)

    #             # print("averfage demand:", np.mean(demand))
    #             # print("search space s:", search_space_s)
    #             # print("search space S:", search_space_S)

    #             # only use positive or zero candidates
    #             search_space_s = search_space_s[search_space_s >= -0.1]
    #             search_space_S = search_space_S[search_space_S >= 0]
    #             self.s, self.S, cost, warn_edge = self.calculate_grid(search_space_s, search_space_S)

    #             # print("s:", self.s, "S:", self.S, "cost:", cost)

    #             counter += 1
    #             if counter > 10:
    #                 print("Warning: search space too large, no convergence")
    #                 break

    #         if unit_size == 1:
    #             break
        
    #         counter_outer += 1

    #         unit_size = unit_size/3
    #         unit_size = np.maximum(unit_size, 1)
    #         unit_size = np.round(unit_size)

    def draw_action(self, input):

        """
        Generate an action based on the current state.

        # TODO adjust description

        Returns zero for products which have still sufficient inventory, and the optimal order quantity for products which are running out of stock.

        Parameters:
            input (numpy.ndarray): The current inventory level and potentially order pipeline for each product.

        Returns:
            numpy.ndarray: The action to be taken, indicating the quantity to order for each product.

        """

        for preprocessor in self.preprocessors:
            input = preprocessor(input)
        
        # print("input")
        total_inventory_position = np.sum(input)
        # print(total_inventory_position)
        if total_inventory_position < self.S_e:
            q_e = self.S_e - total_inventory_position
            q = self.S-self.S_e
        elif total_inventory_position < self.S:
            q_e=0
            q = self.S - total_inventory_position
        else:
            q_e=0
            q = 0

        # print("q", q, "q_e", q_e)
        action = np.array([q, q_e])

        for postprocessor in self.postprocessors:
            action = postprocessor(action)

        return action
    
    def draw_action_train(self, input, S, S_e):

        """
        Generate an action based on the current state.

        # TODO adjust description

        Returns zero for products which have still sufficient inventory, and the optimal order quantity for products which are running out of stock.

        Parameters:
            input (numpy.ndarray): The current inventory level and potentially order pipeline for each product.

        Returns:
            numpy.ndarray: The action to be taken, indicating the quantity to order for each product.

        """

        for preprocessor in self.preprocessors:
            input = preprocessor(input)

        total_inventory_position = np.sum(input)
        if total_inventory_position < S_e:
            q_e = S_e - total_inventory_position
            q = S-S_e
        elif total_inventory_position < S:
            q_e=0
            q = S - total_inventory_position 
        else:
            q_e=0
            q = 0 

        action = np.array([q, q_e])

        for postprocessor in self.postprocessors:
            action = postprocessor(action)

        return action
    
    def reset(self):
        pass

class DualIndexPolicy(SingleIndexPolicy):

    """
    xxx
    """

    def __init__(self,
                 l, 
                 l_e, 
                 mdp,
                 unit_size = 0.01,
                 preprocessors = None,
                 postprocessors = None,
                 num_iterations_per_parameter = 12,
                 algorithm = "brute_0_1", # "brute_0_1": brute force for demand between 0 and 1 and unit-size <1, "brute_0_1": brute force for demand large 1 and unit size 1
                 full_grid = False,
                 return_levels = False
                 ):
        
        self.return_levels = return_levels
        
        super().__init__(l, l_e, mdp, unit_size, preprocessors, postprocessors, num_iterations_per_parameter, algorithm, full_grid)
    
    def draw_action(self, input):
        
        """
        Generate an action based on the current state.

        # TODO adjust description

        Returns zero for products which have still sufficient inventory, and the optimal order quantity for products which are running out of stock.

        Parameters:
            input (numpy.ndarray): The current inventory level and potentially order pipeline for each product.

        Returns:
            numpy.ndarray: The action to be taken, indicating the quantity to order for each product.

        """

        for preprocessor in self.preprocessors:
            input = preprocessor(input)

        total_inventory_position = np.sum(input)
        expedited_inventory_position = input[0]+np.sum(input[-(self.l_e)]) # first position is inventory, rest is pipeline vector

        if expedited_inventory_position < self.S_e:
            q_e = self.S_e - expedited_inventory_position
            q = np.maximum(self.S-total_inventory_position-q_e,0)
        elif total_inventory_position < self.S:
            q_e=0
            q = self.S - total_inventory_position 
        else:
            q_e=0
            q = 0

        action = np.array([q, q_e])

        for postprocessor in self.postprocessors:
            action = postprocessor(action)

        if self.return_levels:
            action = np.array([self.S, self.S_e])

        return action

    def draw_action_train(self, input, S, S_e):

        """
        Generate an action based on the current state.

        # TODO adjust description

        Returns zero for products which have still sufficient inventory, and the optimal order quantity for products which are running out of stock.

        Parameters:
            input (numpy.ndarray): The current inventory level and potentially order pipeline for each product.

        Returns:
            numpy.ndarray: The action to be taken, indicating the quantity to order for each product.

        """

        for preprocessor in self.preprocessors:
            input = preprocessor(input)

        total_inventory_position = np.sum(input)
        expedited_inventory_position = input[0]+np.sum(input[-(self.l_e)]) # first position is inventory, rest is pipeline vector

        if expedited_inventory_position < S_e:
            q_e = S_e - expedited_inventory_position
            q = np.maximum(S-total_inventory_position-q_e,0)
        elif total_inventory_position < S:
            q_e=0
            q = S - total_inventory_position 
        else:
            q_e=0
            q = 0

        action = np.array([q, q_e])

        for postprocessor in self.postprocessors:
            action = postprocessor(action)

        if self.return_levels:
            action = np.array([S, S_e])

        return action
