Index: README.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+># py-travel
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/README.md b/README.md
--- a/README.md	(revision ba2ffedac4db2ae39aa2322085f733d385a36f03)
+++ b/README.md	(date 1715003843076)
@@ -1,1 +1,70 @@
-# py-travel
\ No newline at end of file
+# py-travel
+
+This is a Python library to use in conjunction with the Google Maps API (at least for now) in order to plan trips and
+much more!
+
+## Getting started
+
+These instructions will get you a copy of the project up and running on your local machine for development and testing
+purposes.
+
+### Prerequisites
+
+You will need the following:
+
+ - Python >= 3.10
+ - A Google Maps API key (for testing outside the testing environment)
+
+### Installing
+
+For a local installation, just clone this repository inside the parent directory of your project.
+
+````bash
+git clone https://github.com/diagmatrix/py-travel.git
+````
+
+Then install the dependencies of **py-travel**.
+
+````bash
+pip install -r requirements.txt
+````
+
+And there you have it! You can now use this library freely.
+
+## Using py-travel
+
+There are currently two ways of using the classes provided in the package: by using the built-in
+Google Maps API clients or by using the `googlemaps` client directly. The first method will initialize an API client for
+each of the classes of **py-travel** that use them, while the second approach will give you more control on which ones
+can access it.
+
+### Using built-in client
+
+````python
+from py_travel import init_clients
+from py_travel.trip import Trip
+
+init_clients(api_key="<API KEY>")  # Initialize all API clients
+my_trip = Trip(origin=(39.25, -4.47), destination="Aveiro, Portugal", config={'mode': 'walking'})
+
+# Get the kms between the points
+kms = my_trip.distance
+````
+
+### Using `googlemaps` directly
+
+````python
+from py_travel.trip import Trip
+import googlemaps
+
+cli = googlemaps.Client(key="<API KEY>")
+Trip.set_client(cli)  # Initialize client for the trip class
+my_trip = Trip(origin=(39.25, -4.47), destination="Aveiro, Portugal", config={'mode': 'walking'})
+
+# Get the kms between the points
+kms = my_trip.distance
+````
+
+## Running the tests
+
+In order to run the tests 
\ No newline at end of file
Index: py_travel/trip/trip.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>from datetime import datetime, date, timedelta\r\nfrom typing import Tuple, List, Dict, TypedDict, Any\r\n\r\nfrom py_travel.exceptions import ClientNotInitializedError, TripWarning, InvalidResponseError\r\nfrom py_travel.location import Location, input_to_location\r\nfrom py_travel.utils import meters_to_miles, get_distance, get_duration, get_steps, calculate_stage_steps\r\nfrom .auxiliary_types import (\r\n    Stop,\r\n    TRIP_MODES,\r\n    AVOID_FEATURES,\r\n    TRANSIT_MODES,\r\n    TRANSIT_PREFERENCES,\r\n    TRAFFIC_MODE,\r\n    METRIC_SYSTEMS,\r\n)\r\n\r\n\r\nclass TripConfig(TypedDict, total=False):\r\n    \"\"\"\r\n    Contains the trip configuration variables\r\n\r\n    Attributes:\r\n        mode: Trip mode: driving, walking, bicycling or transit.\r\n        avoid: Features to avoid: tolls, highways, ferries, indoor or a combination of them\r\n        units: Unit system for the calculations: metric or imperial.\r\n        transit_mode: Transit mode if the mode is 'transit': bus, subway, train, tram, rail or a combination of them.\r\n        transit_routing_preference: Preference in calculations for transit: less_walking or fewer_transfer.\r\n        traffic_model: Traffic model to use if mode is 'driving': best_guess, optimistic or pessimistic.\r\n    \"\"\"\r\n\r\n    mode: TRIP_MODES\r\n    avoid: List[AVOID_FEATURES] | AVOID_FEATURES\r\n    units: METRIC_SYSTEMS\r\n    transit_mode: List[TRANSIT_MODES] | TRANSIT_MODES\r\n    transit_routing_preference: TRANSIT_PREFERENCES\r\n    traffic_model: TRAFFIC_MODE\r\n\r\n\r\nclass Trip:\r\n    \"\"\"\r\n    Trip class\r\n\r\n    Attributes:\r\n        client: Client object for the Google Maps API calls\r\n        origin: Origin of the trip\r\n        destination: Destination of the trip\r\n        departure_date: Start date of the trip\r\n        arrival_date: End date of the trip\r\n        stops: List of stops associated with the trip\r\n        updated: Boolean indicating if the object needs to call the Google Maps API to get the results\r\n        api_response: Raw Google Maps API response\r\n    \"\"\"\r\n\r\n    client: Any = None\r\n\r\n    def __init__(\r\n        self,\r\n        origin: Tuple[float, float] | str | Location,\r\n        destination: Tuple[float, float] | str | Location,\r\n        stops: List[Tuple[Tuple[float, float] | str | Location, datetime]] = None,\r\n        departure_date: datetime = None,\r\n        arrival_date: datetime = None,\r\n        config: TripConfig = None,\r\n    ) -> None:\r\n        \"\"\"\r\n        Initialize Trip object\r\n\r\n        :param origin: Origin of the trip in pair (latitude, longitude) or address or Location object\r\n        :param destination: Destination of the trip in pair (latitude, longitude) or address or Location object\r\n        :param stops: A list of tuples containing the stop location (either a tuple containing the coordinates, the\r\n            address or a Location object) and the departure date from the stop\r\n        :param departure_date: Start date of the trip (optional)\r\n        :param arrival_date: End date of the trip (optional)\r\n        :param config: Trip configuration either as a dictionary or as a TripConfig object (optional)\r\n        \"\"\"\r\n\r\n        self.__origin = input_to_location(origin)\r\n        self.__destination = input_to_location(destination)\r\n\r\n        self.__stops = (\r\n            [Stop(input_to_location(loc), dep_date) for loc, dep_date in stops]\r\n            if stops\r\n            else []\r\n        )\r\n        self.__stops.sort(key=lambda stop: stop.departure_date)\r\n\r\n        self.__departure_date = departure_date\r\n        self.__arrival_date = arrival_date\r\n\r\n        self.__config = config if config else {}\r\n\r\n        self.__api_response: Dict = {}\r\n        self.__updated = True\r\n\r\n    @property\r\n    def origin(self) -> Location:\r\n        \"\"\"\r\n        :return: The origin location of the trip\r\n        \"\"\"\r\n        return self.__origin\r\n\r\n    @origin.setter\r\n    def origin(self, new_origin: Tuple[float, float] | str | Location) -> None:\r\n        \"\"\"\r\n        Sets the origin location of the trip\r\n\r\n        Warning: This will mark the trip as updated, possibly causing calls to the Google Maps API in the future.\r\n\r\n        :param new_origin: Origin of the trip in pair (latitude, longitude), string with address or Location object\r\n        \"\"\"\r\n        self.__origin = input_to_location(new_origin)\r\n        self.__updated = True\r\n\r\n    @property\r\n    def destination(self) -> Location:\r\n        \"\"\"\r\n        :return: The destination location of the trip\r\n        \"\"\"\r\n        return self.__destination\r\n\r\n    @destination.setter\r\n    def destination(\r\n        self, new_destination: Tuple[float, float] | str | Location\r\n    ) -> None:\r\n        \"\"\"\r\n        Sets the destination location of the trip\r\n\r\n        Warning: This will mark the trip as updated, possibly causing calls to the Google Maps API in the future.\r\n\r\n        :param new_destination: Destination of the trip in pair (latitude, longitude), string with address or Location\r\n            object\r\n        \"\"\"\r\n        self.__destination = input_to_location(new_destination)\r\n        self.__updated = True\r\n\r\n    @property\r\n    def stops(self) -> List[Stop]:\r\n        \"\"\"\r\n        :return: The list of stops\r\n        \"\"\"\r\n        return self.__stops\r\n\r\n    @stops.setter\r\n    def stops(\r\n        self, stops: List[Tuple[Tuple[float, float] | str | Location, datetime]] | List[Stop]\r\n    ) -> None:\r\n        \"\"\"\r\n        Sets the stops for the trip\r\n\r\n        Warning: This will mark the trip as updated, possibly causing calls to the Google Maps API in the future.\r\n\r\n        :param stops: A list of tuples containing the stop location (either a tuple containing the coordinates, the\r\n            address or a Location object) and the departure date from the stop, or a list of Stop objects\r\n        \"\"\"\r\n\r\n        self.__stops = []\r\n        for stop in stops:\r\n            if isinstance(stop, Stop):\r\n                self.__stops.append(stop)\r\n            else:\r\n                self.__stops.append(Stop(input_to_location(stop[0]), stop[1]))\r\n\r\n        self.__stops.sort(key=lambda s: s.departure_date)\r\n        self.__updated = True\r\n\r\n    @property\r\n    def departure_date(self) -> datetime:\r\n        \"\"\"\r\n        :return: The departure date of the trip\r\n        \"\"\"\r\n        return self.__departure_date\r\n\r\n    @departure_date.setter\r\n    def departure_date(self, new_departure_date: datetime) -> None:\r\n        \"\"\"\r\n        Sets the departure date of the trip\r\n\r\n        Warning: This will mark the trip as updated, possibly causing calls to the Google Maps API in the future.\r\n\r\n        :param new_departure_date: The departure date of the trip\r\n        \"\"\"\r\n        self.__departure_date = new_departure_date\r\n        self.__updated = True\r\n\r\n    @property\r\n    def arrival_date(self) -> datetime:\r\n        \"\"\"\r\n        :return: The arrival date of the trip\r\n        \"\"\"\r\n        return self.__arrival_date\r\n\r\n    @arrival_date.setter\r\n    def arrival_date(self, new_arrival_date: datetime) -> None:\r\n        \"\"\"\r\n        Sets the arrival date of the trip\r\n\r\n        Warning: This will mark the trip as updated, possibly causing calls to the Google Maps API in the future.\r\n\r\n        :param new_arrival_date: The arrival date of the trip\r\n        \"\"\"\r\n        self.__arrival_date = new_arrival_date\r\n        self.__updated = True\r\n\r\n    @property\r\n    def config(self) -> TripConfig:\r\n        \"\"\"\r\n        :return: The configuration parameters of the trip\r\n        \"\"\"\r\n        return self.__config\r\n\r\n    @config.setter\r\n    def config(self, new_config: TripConfig) -> None:\r\n        \"\"\"\r\n        Set the configuration for the calculations\r\n\r\n        Warning: This method will mark the trip as updated, possibly causing calls to the Google Maps API in the future.\r\n\r\n        :param new_config: Trip configuration\r\n        \"\"\"\r\n\r\n        self.__config = new_config\r\n        self.__updated = True\r\n\r\n    @property\r\n    def api_response(self) -> Dict:\r\n        \"\"\"\r\n        :return: The response from the Google Maps API\r\n        \"\"\"\r\n        return self.__api_response\r\n\r\n    @property\r\n    def distance(self) -> float:\r\n        \"\"\"\r\n        Warning: If the trip is marked as updated, it will first calculate the trip\r\n        :return: The total distance of the trip in the unit given in the config ('metric' if not configured).\r\n        \"\"\"\r\n\r\n        if self.__updated:\r\n            self.calculate_trip()\r\n\r\n        if self.__stops:\r\n            meters = sum(get_distance(stage) for stage in self.__api_response.values())\r\n        else:\r\n            meters = get_distance(self.__api_response)\r\n\r\n        return (\r\n            meters / 1000\r\n            if self.__config.get(\"units\", \"metric\") == \"metric\"\r\n            else meters_to_miles(meters)\r\n        )\r\n\r\n    @property\r\n    def seconds(self) -> int:\r\n        \"\"\"\r\n        Warning: If the trip is marked as updated, it will first calculate the trip\r\n        :return: The amount of seconds travelled in the trip\r\n        \"\"\"\r\n\r\n        if self.__updated:\r\n            self.calculate_trip()\r\n\r\n        if self.__stops:\r\n            seconds = sum(get_duration(stage) for stage in self.__api_response.values())\r\n        else:\r\n            seconds = get_duration(self.__api_response)\r\n\r\n        return seconds\r\n\r\n    @property\r\n    def days(self) -> int:\r\n        \"\"\"\r\n        Warning: If the trip is marked as updated, it will first calculate the trip\r\n        :return: Duration in days of the trip (rounded up)\r\n        \"\"\"\r\n\r\n        if self.__updated:\r\n            self.calculate_trip()  # This will call update_dates()\r\n\r\n        return (self.__arrival_date.date() - self.__departure_date.date()).days + 1\r\n\r\n    @property\r\n    def stages_distances(self) -> List[float]:\r\n        \"\"\"\r\n        Returns the distances between the locations of the trip in a list starting from origin - 1st stop and ending\r\n        with last stop - destination. If the trip does not contain stops, the list will be of size 1.\r\n\r\n        Warning: If the trip is marked as updated, it will first calculate the trip\r\n\r\n        :return: A list of distances between the locations of the trip in order\r\n        \"\"\"\r\n\r\n        if self.__updated:\r\n            self.calculate_trip()\r\n\r\n        distances: List[float] = []\r\n        if self.__stops:\r\n            for stage in self.__api_response.values():\r\n                stage_meters = (\r\n                    stage.get(\"legs\", [{}])[0].get(\"distance\", {}).get(\"value\", None)\r\n                )\r\n                if not stage_meters:\r\n                    raise InvalidResponseError(\"legs[0].distance.value\")\r\n\r\n                distances.append(stage_meters)\r\n        else:\r\n            meters = (\r\n                self.__api_response.get(\"legs\", [{}])[0]\r\n                .get(\"distance\", {})\r\n                .get(\"value\", None)\r\n            )\r\n            if not meters:\r\n                raise InvalidResponseError(\"legs[0].distance.value\")\r\n            distances.append(meters)\r\n\r\n        return [\r\n            (\r\n                distance / 1000\r\n                if self.__config.get(\"units\", \"metric\") == \"metric\"\r\n                else meters_to_miles(distance)\r\n            )\r\n            for distance in distances\r\n        ]\r\n\r\n    @property\r\n    def stages_seconds(self) -> List[int]:\r\n        \"\"\"\r\n        Returns the seconds travelled between the locations of the trip in a list starting from origin - 1st stop and\r\n        ending last stop - destination. If the trip does not contain stops, the list will be of size 1.\r\n\r\n        Warning: If the trip is marked as updated, it will first calculate the trip\r\n\r\n        :return: A list of seconds between the locations of the trip in order\r\n        \"\"\"\r\n\r\n        if self.__updated:\r\n            self.calculate_trip()\r\n\r\n        seconds: List[int] = []\r\n        if self.__stops:\r\n            for stage in self.__api_response.values():\r\n                stage_seconds = (\r\n                    stage.get(\"legs\", [{}])[0].get(\"duration\", {}).get(\"value\", None)\r\n                )\r\n                if not stage_seconds:\r\n                    raise InvalidResponseError(\"legs[0].duration.value\")\r\n\r\n                seconds.append(stage_seconds)\r\n        else:\r\n            seconds_trip = (\r\n                self.__api_response.get(\"legs\", [{}])[0]\r\n                .get(\"duration\", {})\r\n                .get(\"value\", None)\r\n            )\r\n            if not seconds_trip:\r\n                raise InvalidResponseError(\"legs[0].duration.value\")\r\n            seconds.append(seconds_trip)\r\n\r\n        return seconds\r\n\r\n    @property\r\n    def trip_calendar(self) -> List[Tuple[date, float]]:\r\n        \"\"\"\r\n        Creates a list of pairs day-distance travelled from the trip.\r\n\r\n        Because the Google Maps API does not provide exact data for this calculation, the distances travelled will be\r\n        an estimation.\r\n\r\n        Warning: If the trip is marked as updated, it will first calculate the trip\r\n\r\n        :return: A list of pairs day-distance travelled in the unit given in the config ('metric' if not configured).\r\n        \"\"\"\r\n\r\n        if self.__updated:\r\n            self.calculate_trip()\r\n\r\n        # Create calendar\r\n        calendar = {\r\n            self.__departure_date.date() + timedelta(days=i): 0.0\r\n            for i in range(self.days)\r\n        }\r\n\r\n        # Calculate kms travelled per day\r\n        if self.__stops:\r\n            current_date = self.__departure_date\r\n            for index, stage in enumerate(self.__api_response.values()):\r\n                steps = get_steps(stage)\r\n                calendar = calculate_stage_steps(steps, current_date, calendar)\r\n                current_date = self.__stops[index].departure_date if index < len(self.__stops) else None  # :)\r\n\r\n        else:\r\n            steps = get_steps(self.__api_response)\r\n            calendar = calculate_stage_steps(steps, self.__departure_date, calendar)\r\n\r\n        return [\r\n            (\r\n                day,\r\n                meters / 1000 if self.__config.get(\"units\", \"metric\") == \"metric\" else meters_to_miles(meters)\r\n            )\r\n            for day, meters in calendar.items() if meters > 0\r\n        ]\r\n\r\n    @classmethod\r\n    def set_client(cls, client: Any) -> None:\r\n        \"\"\"\r\n        Initializes the client for the directions request\r\n\r\n        :param client: A client object. Must contain a method called 'directions' that returns the raw Google Maps\r\n            Directions API response and takes the following parameters: origin, destination, mode, avoid, units,\r\n            departure_time, arrival_time, transit_mode, transit_routing_preference and traffic_model\r\n        \"\"\"\r\n\r\n        cls.client = client\r\n\r\n    def calculate_trip(self, trip_config: TripConfig = None) -> Dict:\r\n        \"\"\"\r\n        Calls the Google Maps API to calculate the trip, only if the trip needs to be updated.\r\n\r\n        This method will make at least one call to the Google Maps API and at most 1 + the number of stops.\r\n\r\n        :param trip_config: Trip configuration\r\n        :return: The raw API response if no stops are provided, otherwise a dictionary with the raw API responses\r\n        :raises ClientNotInitializedError: If the googlemaps client is not initialized\r\n        :raises TripWarning: If a trip attribute is ignored based on the config given\r\n        \"\"\"\r\n\r\n        if trip_config:\r\n            self.config = trip_config\r\n\r\n        if not self.__updated:\r\n            return self.__api_response\r\n\r\n        if not self.client:\r\n            raise ClientNotInitializedError()\r\n\r\n        if self.__arrival_date and self.__stops:\r\n            TripWarning.ignore_field(\"arrival_date\", \"Ignored for trips with stops\")\r\n        elif (\r\n            self.__arrival_date\r\n            and not self.__config.get(\"mode\", \"not_configured\") == \"transit\"\r\n        ):\r\n            TripWarning.ignore_field(\"arrival_date\", \"Only used for transit mode\")\r\n\r\n        # Make calls to the API\r\n        if self.__stops:\r\n            current_location = self.__origin.get_data()\r\n            current_date = (\r\n                self.__departure_date if self.__departure_date else datetime.now()\r\n            )  # Fixes HTTP 400 error\r\n\r\n            # Call for each stop\r\n            for index, stop in enumerate(self.__stops):\r\n                key = f\"stage_{index}\" if index > 0 else \"departure\"\r\n\r\n                self.__api_response[key] = self.client.directions(\r\n                    origin=current_location,\r\n                    destination=stop.location.get_data(),\r\n                    departure_time=current_date,\r\n                    **self.__config,\r\n                )[0]\r\n\r\n                current_location = stop.location.get_data()\r\n                current_date = stop.departure_date\r\n\r\n            # Call for last stage of the trip\r\n            self.__api_response[\"arrival\"] = self.client.directions(\r\n                origin=current_location,\r\n                destination=self.__destination.get_data(),\r\n                departure_time=current_date,\r\n                **self.__config,\r\n            )[0]\r\n\r\n        else:\r\n            # Date argument depending on the given fields and configuration\r\n            if self.__departure_date:\r\n                date_argument = {\"departure_time\": self.__departure_date}\r\n            elif (\r\n                self.__arrival_date\r\n                and self.__config.get(\"mode\", \"not_configured\") == \"transit\"\r\n            ):\r\n                date_argument = {\"arrival_time\": self.__arrival_date}\r\n            else:\r\n                date_argument = {\r\n                    \"departure_time\": datetime.now()\r\n                }  # Fixes HTTP 400 error\r\n\r\n            self.__api_response = self.client.directions(\r\n                origin=self.__origin.get_data(),\r\n                destination=self.__destination.get_data(),\r\n                **date_argument,\r\n                **self.__config,\r\n            )[0]\r\n\r\n        self.__updated = False\r\n        self.update_dates()  # Update dates\r\n        return self.__api_response\r\n\r\n    def update_dates(self) -> None:\r\n        \"\"\"\r\n        Checks the given dates make sense and updates the ones that don't. If both departure and arrival dates are\r\n        found, departure date has preference for conflict resolution.\r\n\r\n        Warning: If the trip is marked as updated, it will first calculate the trip\r\n        \"\"\"\r\n\r\n        if self.__updated:\r\n            self.calculate_trip()\r\n\r\n        travel_times = self.stages_seconds\r\n\r\n        # Check departure date\r\n        if not self.__departure_date and not self.__arrival_date:\r\n            self.__departure_date = datetime.now()\r\n            TripWarning.update_date(\"departure\", \"No departure date provided\")\r\n        elif not self.__departure_date:\r\n            if not self.__stops:\r\n                self.__departure_date = self.__arrival_date - timedelta(\r\n                    seconds=travel_times[0]\r\n                )\r\n            else:\r\n                self.__departure_date = self.__stops[0].departure_date - timedelta(\r\n                    seconds=travel_times[0]\r\n                )\r\n            TripWarning.update_date(\"departure\", \"No departure date provided\")\r\n\r\n        # Check stop dates\r\n        if self.__stops:\r\n            current_date = self.__departure_date\r\n            for index, stop in enumerate(self.__stops):\r\n                stop_arrival = current_date + timedelta(seconds=travel_times[index])\r\n                if stop.departure_date < stop_arrival:\r\n                    TripWarning.update_date(\r\n                        \"stop\", \"Calculated arrival before departure date\"\r\n                    )\r\n                    self.__stops[index] = Stop(stop.location, stop_arrival)\r\n\r\n                current_date = stop.departure_date\r\n\r\n        # Check arrival date\r\n        if not self.__stops:\r\n            new_arrival = self.__departure_date + timedelta(seconds=travel_times[0])\r\n        else:\r\n            new_arrival = self.__stops[-1].departure_date + timedelta(\r\n                seconds=travel_times[-1]\r\n            )\r\n\r\n        if not self.__arrival_date:\r\n            self.__arrival_date = new_arrival\r\n            TripWarning.update_date(\"arrival\", \"No arrival date provided\")\r\n        elif self.__arrival_date != new_arrival:\r\n            self.__arrival_date = new_arrival\r\n            TripWarning.update_date(\"arrival\", \"Calculated arrival does not match\")\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/py_travel/trip/trip.py b/py_travel/trip/trip.py
--- a/py_travel/trip/trip.py	(revision ba2ffedac4db2ae39aa2322085f733d385a36f03)
+++ b/py_travel/trip/trip.py	(date 1715003084679)
@@ -532,8 +532,9 @@
                         "stop", "Calculated arrival before departure date"
                     )
                     self.__stops[index] = Stop(stop.location, stop_arrival)
-
-                current_date = stop.departure_date
+                    current_date = stop_arrival
+                else:
+                    current_date = stop.departure_date
 
         # Check arrival date
         if not self.__stops:
Index: requirements.txt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>googlemaps\r\npytest
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/requirements.txt b/requirements.txt
--- a/requirements.txt	(revision ba2ffedac4db2ae39aa2322085f733d385a36f03)
+++ b/requirements.txt	(date 1715003053065)
@@ -1,2 +1,1 @@
 googlemaps
-pytest
\ No newline at end of file
Index: main.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/main.py b/main.py
new file mode 100644
--- /dev/null	(date 1715003586842)
+++ b/main.py	(date 1715003586842)
@@ -0,0 +1,31 @@
+from py_travel import init_clients
+from py_travel.trip import Trip, TripConfig
+from datetime import datetime
+import googlemaps
+
+cli = googlemaps.Client(key='AIzaSyBxcVfBoBTyqPGTQfTV4d3vM3_lkpaKbJ4')
+Trip.set_client(cli)
+# init_clients(api_key="AIzaSyBxcVfBoBTyqPGTQfTV4d3vM3_lkpaKbJ4")
+
+my_trip = Trip(origin=(39.25, -4.47), destination="Aveiro, Portugal", config={'mode': 'walking'})
+
+print(my_trip.distance)
+
+# CONFIG = TripConfig(mode="driving", units="metric", traffic_model="pessimistic")
+# b_date = datetime(year=2024, month=6, day=1, hour=13, minute=40)
+# trip = Trip(
+#     "Granada",
+#     "Berlín, Alemania",
+#     config=CONFIG,
+#     departure_date=b_date
+# )
+# trip.stops = [
+#     ("Guadix", datetime(year=2024, month=5, day=7, hour=11, minute=40)),
+#     ("Úbeda", datetime(year=2024, month=5, day=9, hour=7, minute=40)),
+# ]
+# # print(trip.departure_date, trip.arrival_date)
+# # print([s.departure_date for s in trip.stops])
+#
+# calendar = trip.trip_calendar
+# print(calendar)
+# print(trip.distance, sum(c[1] for c in calendar))
